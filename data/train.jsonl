{"image_path": "data\\train\\00000.png", "code": "def create_like(session: Session, activity: CreateActivity) -> Like:\r\n    with session() as db:\r\n        like: Like = Like(\r\n            author_id=activity.user_id,\r\n            post_id=activity.post_id\r\n        )\r\n        db.add(like)\r\n        db.commit()\r\n        db.refresh(like)\r\n    return like"}
{"image_path": "data\\train\\00001.png", "code": "def create_like(session: Session, activity: CreateActivity) -> Like:\r\n    with session() as db:\r\n        like: Like = Like(\r\n            author_id=activity.user_id,\r\n            post_id=activity.post_id\r\n        )\r\n        db.add(like)\r\n        db.commit()\r\n        db.refresh(like)\r\n    return like"}
{"image_path": "data\\train\\00002.png", "code": "def create_like(session: Session, activity: CreateActivity) -> Like:\r\n    with session() as db:\r\n        like: Like = Like(\r\n            author_id=activity.user_id,\r\n            post_id=activity.post_id\r\n        )\r\n        db.add(like)\r\n        db.commit()\r\n        db.refresh(like)\r\n    return like"}
{"image_path": "data\\train\\00003.png", "code": "def create_like(session: Session, activity: CreateActivity) -> Like:\r\n    with session() as db:\r\n        like: Like = Like(\r\n            author_id=activity.user_id,\r\n            post_id=activity.post_id\r\n        )\r\n        db.add(like)\r\n        db.commit()\r\n        db.refresh(like)\r\n    return like"}
{"image_path": "data\\train\\00004.png", "code": "def create_like(session: Session, activity: CreateActivity) -> Like:\r\n    with session() as db:\r\n        like: Like = Like(\r\n            author_id=activity.user_id,\r\n            post_id=activity.post_id\r\n        )\r\n        db.add(like)\r\n        db.commit()\r\n        db.refresh(like)\r\n    return like"}
{"image_path": "data\\train\\00005.png", "code": "def delete_like(session: Session, activity: CreateActivity) -> Like:\r\n    with session() as db:\r\n        like: Like = db.query(Like).filter(Like.author_id==activity.user_id, Like.post_id==activity.post_id).first()\r\n        db.delete(like)\r\n        db.commit()\r\n    return like\r\n\r\ndef has_liked(session: Session, activity: CreateActivity) -> Like:\r\n    with session() as db:\r\n        like: Like = db.query(Like).filter(Like.author_id==activity.user_id, Like.post_id==activity.post_id).first()\r\n        if like:\r\n            return True\r\n    return False"}
{"image_path": "data\\train\\00006.png", "code": "def list_user_likes(session: Session, user_data: GetUser) -> list[Like]:\r\n    with session() as db:\r\n        user: User = db.query(User).filter(User.id == user_data.user_id).first()\r\n        likes: list[Like] = user.likes\r\n    return likes\r\n\r\ndef list_post_likes(session: Session, post_data: GetPost):\r\n    with session() as db:\r\n        post: Post = db.query(Post).filter(Post.id == post_data.post_id).first()\r\n        likes: list[Like] = post.likes\r\n        for like in likes:\r\n            like.author\r\n    return likes\r\n\r\ndef get_key_like(session: Session, post_data: GetPost):\r\n    from random import choice\r\n    with session() as db:\r\n        post: Post = db.query(Post).filter(Post.id == post_data.post_id).first()\r\n        likes: list[Like] = post.likes\r\n        for like in likes:\r\n            like.author\r\n    return choice(likes).author if likes else None"}
{"image_path": "data\\train\\00007.png", "code": "def list_user_likes(session: Session, user_data: GetUser) -> list[Like]:\r\n    with session() as db:\r\n        user: User = db.query(User).filter(User.id == user_data.user_id).first()\r\n        likes: list[Like] = user.likes\r\n    return likes\r\n\r\ndef list_post_likes(session: Session, post_data: GetPost):\r\n    with session() as db:\r\n        post: Post = db.query(Post).filter(Post.id == post_data.post_id).first()\r\n        likes: list[Like] = post.likes\r\n        for like in likes:\r\n            like.author\r\n    return likes\r\n\r\ndef get_key_like(session: Session, post_data: GetPost):\r\n    from random import choice\r\n    with session() as db:\r\n        post: Post = db.query(Post).filter(Post.id == post_data.post_id).first()\r\n        likes: list[Like] = post.likes\r\n        for like in likes:\r\n            like.author\r\n    return choice(likes).author if likes else None"}
{"image_path": "data\\train\\00008.png", "code": "from sqlalchemy.orm import Session\r\nfrom ..models.post import Post\r\nfrom ..schemas.post import (\r\n    CreatePost, GetPosts, GetPost, UpdatePost\r\n)\r\nfrom werkzeug.datastructures import FileStorage\r\nfrom flask import current_app\r\nfrom uuid import uuid4\r\nfrom werkzeug.utils import secure_filename\r\nimport os\r\nimport secrets\r\nfrom typing import Callable"}
{"image_path": "data\\train\\00009.png", "code": "ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\r\n\r\ndef get_file_extension(filename: str) -> str:\r\n    if '.' in filename and filename.rsplit('.', 1)[1].lower():\r\n        return filename.rsplit('.', 1)[1].lower()\r\n    return ''\r\n\r\ndef allowed_file(filename: str) -> bool:\r\n    file_extension: str = get_file_extension(filename)\r\n    if file_extension and file_extension in ALLOWED_EXTENSIONS:\r\n        return True\r\n    return False\r\n\r\n\r\ndef save_post_photo_locally(post_image: dict) -> None:\r\n    \"\"\"Save the uploadeded post image.\"\"\"\r\n    file: FileStorage = post_image['post_image']\r\n    upload_folder = os.path.join(current_app.root_path, 'static', 'img')\r\n    if file and allowed_file(file.filename):\r\n        filename = f'{secrets.token_hex(8)}.{get_file_extension(file.filename)}' \r\n        # Use celery task\r\n        file.save(os.path.join(upload_folder, filename))\r\n        return filename\r\n    return ''"}
{"image_path": "data\\train\\00010.png", "code": "def save_post_photo_aws_s3(post_image: dict) -> None:\r\n    \"\"\"Save the uploadeded post image.\"\"\"\r\n    file: FileStorage = post_image['post_image']\r\n    if file and allowed_file(file.filename):\r\n        filename = f'{secrets.token_hex(8)}.{get_file_extension(file.filename)}'\r\n        # Use celery task\r\n        return filename\r\n    return ''\r\n\r\ndef no_save_post_photo(post_image: dict) -> None:\r\n    \"\"\"Save the uploadeded post image.\"\"\"\r\n    file: FileStorage = post_image['post_image']\r\n    if file and allowed_file(file.filename):\r\n        filename = f'{secrets.token_hex(8)}.{get_file_extension(file.filename)}'\r\n        return filename\r\n    return ''\r\n\r\n\r\ndef save_post_photo(post_image: dict, save_location: str = '') -> str:\r\n    \"\"\"Save the uploadeded post image.\"\"\"\r\n    save_photo_funcs: dict[str, Callable[[dict], str]] = {\r\n        'locally': save_post_photo_locally,\r\n        'aws_s3': save_post_photo_aws_s3,\r\n        'default': no_save_post_photo\r\n    }\r\n    if save_photo_funcs.get(save_location):\r\n        filename: str = save_photo_funcs[save_location](post_image)\r\n    else:\r\n        filename: str = save_photo_funcs['default'](post_image)\r\n    return filename"}
{"image_path": "data\\train\\00011.png", "code": "def create_post(post_data: CreatePost, post_image: dict, session: Session):\r\n    post_image_url: str = save_post_photo(post_image)\r\n    post: Post = Post(\r\n        id='Post_' + str(uuid4()),\r\n        author_id=post_data.author_id,\r\n        location=post_data.location,\r\n        text=post_data.text,\r\n        image_url=post_image_url\r\n    )\r\n    with session() as db:\r\n        db.add(post)\r\n        db.commit()\r\n        db.refresh(post)\r\n    return post"}
{"image_path": "data\\train\\00012.png", "code": "def create_post(post_data: CreatePost, post_image: dict, session: Session):\r\n    post_image_url: str = save_post_photo(post_image)\r\n    post: Post = Post(\r\n        id='Post_' + str(uuid4()),\r\n        author_id=post_data.author_id,\r\n        location=post_data.location,\r\n        text=post_data.text,\r\n        image_url=post_image_url\r\n    )\r\n    with session() as db:\r\n        db.add(post)\r\n        db.commit()\r\n        db.refresh(post)\r\n    return post"}
{"image_path": "data\\train\\00013.png", "code": "def create_post(post_data: CreatePost, post_image: dict, session: Session):\r\n    post_image_url: str = save_post_photo(post_image)\r\n    post: Post = Post(\r\n        id='Post_' + str(uuid4()),\r\n        author_id=post_data.author_id,\r\n        location=post_data.location,\r\n        text=post_data.text,\r\n        image_url=post_image_url\r\n    )\r\n    with session() as db:\r\n        db.add(post)\r\n        db.commit()\r\n        db.refresh(post)\r\n    return post"}
{"image_path": "data\\train\\00014.png", "code": "def create_post(post_data: CreatePost, post_image: dict, session: Session):\r\n    post_image_url: str = save_post_photo(post_image)\r\n    post: Post = Post(\r\n        id='Post_' + str(uuid4()),\r\n        author_id=post_data.author_id,\r\n        location=post_data.location,\r\n        text=post_data.text,\r\n        image_url=post_image_url\r\n    )\r\n    with session() as db:\r\n        db.add(post)\r\n        db.commit()\r\n        db.refresh(post)\r\n    return post"}
{"image_path": "data\\train\\00015.png", "code": "def create_post(post_data: CreatePost, post_image: dict, session: Session):\r\n    post_image_url: str = save_post_photo(post_image)\r\n    post: Post = Post(\r\n        id='Post_' + str(uuid4()),\r\n        author_id=post_data.author_id,\r\n        location=post_data.location,\r\n        text=post_data.text,\r\n        image_url=post_image_url\r\n    )\r\n    with session() as db:\r\n        db.add(post)\r\n        db.commit()\r\n        db.refresh(post)\r\n    return post"}
{"image_path": "data\\train\\00016.png", "code": "def update_post(post_data: UpdatePost, post_image: dict, session: Session):\r\n    post_image_url: str = save_post_photo(post_image)\r\n    with session() as db:\r\n        post: Post = db.query(Post).filter(Post.id == post_data.post_id).first()\r\n        if post_data.location:\r\n            post.location = post_data.location\r\n        if post_data.text:\r\n            post.text = post_data.text\r\n        if post_image_url:\r\n            post.image_url = post_image_url\r\n        db.commit()\r\n        db.refresh(post)\r\n    return post\r\n\r\ndef get_post(session: Session, post_data: GetPost):\r\n    with session() as db:\r\n        post = db.query(Post).filter(Post.id == post_data.post_id).first()\r\n    return post"}
{"image_path": "data\\train\\00017.png", "code": "def get_posts(session: Session, post_data: GetPosts):\r\n    with session() as db:\r\n        posts: list[Post] = db.query(Post).offset(post_data.offset).limit(post_data.limit).all()\r\n        for post in posts:\r\n            post.author\r\n        return posts\r\n\r\ndef delete_post(session: Session, post_data: GetPost):\r\n    with session() as db:\r\n        post = db.query(Post).filter(Post.id == post_data.post_id).first()\r\n        db.delete(post)\r\n        db.commit()\r\n        \r\n    return post"}
{"image_path": "data\\train\\00018.png", "code": "def get_posts(session: Session, post_data: GetPosts):\r\n    with session() as db:\r\n        posts: list[Post] = db.query(Post).offset(post_data.offset).limit(post_data.limit).all()\r\n        for post in posts:\r\n            post.author\r\n        return posts\r\n\r\ndef delete_post(session: Session, post_data: GetPost):\r\n    with session() as db:\r\n        post = db.query(Post).filter(Post.id == post_data.post_id).first()\r\n        db.delete(post)\r\n        db.commit()\r\n        \r\n    return post"}
{"image_path": "data\\train\\00019.png", "code": "def get_posts(session: Session, post_data: GetPosts):\r\n    with session() as db:\r\n        posts: list[Post] = db.query(Post).offset(post_data.offset).limit(post_data.limit).all()\r\n        for post in posts:\r\n            post.author\r\n        return posts\r\n\r\ndef delete_post(session: Session, post_data: GetPost):\r\n    with session() as db:\r\n        post = db.query(Post).filter(Post.id == post_data.post_id).first()\r\n        db.delete(post)\r\n        db.commit()\r\n        \r\n    return post"}
{"image_path": "data\\train\\00020.png", "code": "from ..schemas.user import UserCreate\r\nfrom sqlalchemy.orm import Session\r\nfrom ....extensions.extensions import bcrypt\r\nfrom ..models.user import User\r\nfrom ..schemas.user import User as Userschemas\r\nfrom ..schemas.user import (\r\n    GetUser, GetUsers, ActivateUser, LoginUser, RequestPasswordReset, PasswordReset\r\n)\r\nfrom typing import Optional\r\nfrom jwt import ExpiredSignatureError, InvalidTokenError\r\nfrom uuid import uuid4\r\nfrom typing import Callable"}
{"image_path": "data\\train\\00021.png", "code": "def send_email_local(user_email_address: str, message: str) -> None:\r\n    pass\r\n\r\ndef send_email_aws_ses(user_email_address: str, message: str) -> None:\r\n    pass\r\n\r\ndef send_account_activation_email(user_email_address: str, message: str) -> None:\r\n    pass\r\n\r\ndef send_password_reset_email(user_email_address: str, message: str) -> None:\r\n    pass\r\n\r\ndef generate_account_activation_email(message: str) -> None:\r\n    pass\r\n\r\ndef generate_password_reset_email(message: str) -> None:\r\n    pass"}
{"image_path": "data\\train\\00022.png", "code": "def send_email_local(user_email_address: str, message: str) -> None:\r\n    pass\r\n\r\ndef send_email_aws_ses(user_email_address: str, message: str) -> None:\r\n    pass\r\n\r\ndef send_account_activation_email(user_email_address: str, message: str) -> None:\r\n    pass\r\n\r\ndef send_password_reset_email(user_email_address: str, message: str) -> None:\r\n    pass\r\n\r\ndef generate_account_activation_email(message: str) -> None:\r\n    pass\r\n\r\ndef generate_password_reset_email(message: str) -> None:\r\n    pass"}
{"image_path": "data\\train\\00023.png", "code": "def generate_email(user_email_address: str, email_type: str) -> str:\r\n    email_types: dict[str, Callable] = {\r\n        'password_reset': send_password_reset_email,\r\n        'account_activation': send_account_activation_email\r\n    }\r\n    return email_types[email_type]\r\n\r\ndef send_email(user_email_address: str, email_sender: str) -> None:\r\n    email_senders: dict[str, Callable] = {\r\n        'local': send_email_local,\r\n        'aws_ses': send_email_aws_ses\r\n    }\r\n    return email_sender[email_sender]"}
{"image_path": "data\\train\\00024.png", "code": "def create_user(user_data: UserCreate, session: Session):\r\n    hashed_password = User.hash_password(user_data.password)\r\n    user = User(\r\n        id='User_' + str(uuid4()),\r\n        first_name=user_data.first_name,\r\n        last_name=user_data.last_name,\r\n        email_address=user_data.email_address,\r\n        password=hashed_password\r\n    )\r\n    with session() as db:\r\n        db.add(user)\r\n        db.commit()\r\n        db.refresh(user)\r\n    return user\r\n\r\ndef get_user_by_email(session: Session, email: str):\r\n    with session() as db:\r\n        user = db.query(User).filter(User.email_address == email).first()\r\n    return user"}
{"image_path": "data\\train\\00025.png", "code": "def get_random_user(session: Session):\r\n    from random import choice\r\n    with session() as db:\r\n        user = choice(db.query(User).all())\r\n    return user\r\n\r\ndef get_user(session: Session, user_data: GetUser):\r\n    with session() as db:\r\n        user = db.query(User).filter(User.id == user_data.user_id).first()\r\n    return user\r\n\r\ndef get_users(session: Session, user_data: GetUsers):\r\n    with session() as db:\r\n        users = db.query(User).offset(user_data.offset).limit(user_data.limit).all()\r\n    return users"}
{"image_path": "data\\train\\00026.png", "code": "def delete_user(session: Session, user_data: GetUser):\r\n    with session() as db:\r\n        user = db.query(User).filter(User.id == user_data.user_id).first()\r\n        db.delete(user)\r\n        db.commit()\r\n        \r\n    return user\r\n\r\n\r\ndef user_account_active(session: Session, user_data: GetUser):\r\n    with session() as db:\r\n        user: User = db.query(User).filter(User.id == user_data.user_id).first()\r\n    return user.activated"}
{"image_path": "data\\train\\00027.png", "code": "def delete_user(session: Session, user_data: GetUser):\r\n    with session() as db:\r\n        user = db.query(User).filter(User.id == user_data.user_id).first()\r\n        db.delete(user)\r\n        db.commit()\r\n        \r\n    return user\r\n\r\n\r\ndef user_account_active(session: Session, user_data: GetUser):\r\n    with session() as db:\r\n        user: User = db.query(User).filter(User.id == user_data.user_id).first()\r\n    return user.activated"}
{"image_path": "data\\train\\00028.png", "code": "def activate_user_account(session: Session, activation_data: ActivateUser):\r\n    with session() as db:\r\n        user: User = db.query(User).filter(User.id == activation_data.user_id).first()\r\n        if user.id == User.decode_auth_token(activation_data.activation_token):\r\n            user.activated = True\r\n            db.commit()\r\n            return True\r\n    raise InvalidTokenError('Invalid or Expired token.')\r\n\r\n\r\ndef loggin_user(session: Session, login_data: LoginUser):\r\n    with session() as db:\r\n        user: User = db.query(User).filter(User.email_address == login_data.email_address).first()\r\n        if user and user.check_password(login_data.password):\r\n            return True\r\n    raise ValueError('Invalid email address and or password.')\r\n"}
{"image_path": "data\\train\\00029.png", "code": "def activate_user_account(session: Session, activation_data: ActivateUser):\r\n    with session() as db:\r\n        user: User = db.query(User).filter(User.id == activation_data.user_id).first()\r\n        if user.id == User.decode_auth_token(activation_data.activation_token):\r\n            user.activated = True\r\n            db.commit()\r\n            return True\r\n    raise InvalidTokenError('Invalid or Expired token.')\r\n\r\n\r\ndef loggin_user(session: Session, login_data: LoginUser):\r\n    with session() as db:\r\n        user: User = db.query(User).filter(User.email_address == login_data.email_address).first()\r\n        if user and user.check_password(login_data.password):\r\n            return True\r\n    raise ValueError('Invalid email address and or password.')\r\n"}
{"image_path": "data\\train\\00030.png", "code": "def generate_password_reset_token(session: Session, reset_password_request: RequestPasswordReset):\r\n    with session() as db:\r\n        user: User = db.query(User).filter(User.email_address == reset_password_request.email_address).first()\r\n    resp = {\r\n        'user_id': user.id,\r\n        'email_address': user.email_address,\r\n        'password_reset_token': user.generate_password_reset_token()\r\n    }\r\n    return resp\r\n\r\n\r\ndef password_repeated(session: Session, password_reset: PasswordReset):\r\n    with session() as db:\r\n        user: User = db.query(User).filter(User.email_address == password_reset.email_address).first()\r\n    return user.check_password(password_reset.password)"}
{"image_path": "data\\train\\00031.png", "code": "def reset_password(session: Session, password_reset: PasswordReset):\r\n    with session() as db:\r\n        user: User = db.query(User).filter(User.email_address == password_reset.email_address).first()\r\n        email_address = user.decode_password_token(password_reset.password_reset_token)\r\n        if email_address == user.email_address:\r\n            user.password = user.hash_password(password_reset.password)\r\n            db.commit()\r\n            return True"}
{"image_path": "data\\train\\00032.png", "code": "from ..schemas.activity import CreateActivity, GetRepeatableActivity\r\nfrom sqlalchemy.orm import Session\r\nfrom ..models.view import View\r\nfrom ..models.user import User\r\nfrom ..models.post import Post\r\nfrom ..schemas.user import GetUser\r\nfrom ..schemas.post import GetPost\r\nfrom uuid import uuid4\r\n\r\n\r\ndef create_view(session: Session, activity: CreateActivity) -> View:\r\n    with session() as db:\r\n        view: View = View(\r\n            author_id=activity.user_id,\r\n            post_id=activity.post_id,\r\n            id='View_' + str(uuid4())\r\n        )\r\n        db.add(view)\r\n        db.commit()\r\n        db.refresh(view)\r\n    return view"}
{"image_path": "data\\train\\00033.png", "code": "from ..schemas.activity import CreateActivity, GetRepeatableActivity\r\nfrom sqlalchemy.orm import Session\r\nfrom ..models.view import View\r\nfrom ..models.user import User\r\nfrom ..models.post import Post\r\nfrom ..schemas.user import GetUser\r\nfrom ..schemas.post import GetPost\r\nfrom uuid import uuid4\r\n\r\n\r\ndef create_view(session: Session, activity: CreateActivity) -> View:\r\n    with session() as db:\r\n        view: View = View(\r\n            author_id=activity.user_id,\r\n            post_id=activity.post_id,\r\n            id='View_' + str(uuid4())\r\n        )\r\n        db.add(view)\r\n        db.commit()\r\n        db.refresh(view)\r\n    return view"}
{"image_path": "data\\train\\00034.png", "code": "def has_viewed(session: Session, activity: CreateActivity) -> View:\r\n    with session() as db:\r\n        view: View = db.query(View).filter(View.author_id==activity.user_id, View.post_id==activity.post_id).first()\r\n        if view:\r\n            return True\r\n    return False\r\n\r\ndef list_user_views(session: Session, user_data: GetUser) -> list[View]:\r\n    with session() as db:\r\n        user: User = db.query(User).filter(User.id == user_data.user_id).first()\r\n        views: list[View] = user.views\r\n    return views\r\n\r\ndef list_post_views(session: Session, post_data: GetPost):\r\n    with session() as db:\r\n        post: Post = db.query(Post).filter(Post.id == post_data.post_id).first()\r\n        views: list[View] = post.views\r\n    return views"}
{"image_path": "data\\train\\00035.png", "code": "from .user import User\r\nfrom .post import Post\r\nfrom .like import Like\r\nfrom .bookmark import Bookmark\r\nfrom .view import View\r\nfrom .view import View\r\nfrom .comment import Comment"}
{"image_path": "data\\train\\00036.png", "code": "from datetime import datetime\r\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\r\nfrom ..database import Base\r\nfrom sqlalchemy import ForeignKey\r\n\r\n\r\nclass Bookmark(Base):\r\n    __tablename__ = 'bookmarks'\r\n    \r\n    author_id: Mapped[str] = mapped_column(ForeignKey('users.id'), primary_key=True)\r\n    post_id: Mapped[str] = mapped_column(ForeignKey('posts.id'), primary_key=True)\r\n    bookmark_date: Mapped[datetime] = mapped_column(default_factory=datetime.utcnow)\r\n    \r\n    author = relationship('User', back_populates='bookmarks')\r\n    post = relationship('Post', back_populates='bookmarks')"}
{"image_path": "data\\train\\00037.png", "code": "from datetime import datetime\r\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\r\nfrom ..database import Base\r\nfrom sqlalchemy import ForeignKey\r\n\r\n\r\nclass Comment(Base):\r\n    __tablename__ = 'comments'\r\n    \r\n    id: Mapped[str] = mapped_column(primary_key=True)\r\n    author_id: Mapped[str] = mapped_column(ForeignKey('users.id'))\r\n    post_id: Mapped[str] = mapped_column(ForeignKey('posts.id'))\r\n    comment_text: Mapped[str]\r\n    comment_date: Mapped[datetime] = mapped_column(default_factory=datetime.utcnow)\r\n    \r\n    author = relationship('User', back_populates='comments')\r\n    post = relationship('Post', back_populates='comments')"}
{"image_path": "data\\train\\00038.png", "code": "from datetime import datetime\r\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\r\nfrom ..database import Base\r\nfrom sqlalchemy import ForeignKey\r\n\r\n\r\nclass Like(Base):\r\n    __tablename__ = 'likes'\r\n    \r\n    author_id: Mapped[str] = mapped_column(ForeignKey('users.id'), primary_key=True)\r\n    post_id: Mapped[str] = mapped_column(ForeignKey('posts.id'), primary_key=True)\r\n    like_date: Mapped[datetime] = mapped_column(default_factory=datetime.utcnow)\r\n    \r\n    author = relationship('User', back_populates='likes')\r\n    post = relationship('Post', back_populates='likes')"}
{"image_path": "data\\train\\00039.png", "code": "from datetime import datetime\r\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\r\nfrom sqlalchemy import ForeignKey\r\nfrom ..database import Base\r\n\r\n\r\nclass Post(Base):\r\n    __tablename__ = 'posts'\r\n    \r\n    id: Mapped[str] = mapped_column(primary_key=True)\r\n    author_id: Mapped[str] = mapped_column(ForeignKey('users.id'))\r\n    location: Mapped[str]\r\n    text: Mapped[str]\r\n    image_url: Mapped[str]\r\n    date_published: Mapped[datetime] = mapped_column(default_factory=datetime.utcnow)\r\n    date_updated: Mapped[datetime] = mapped_column(onupdate=datetime.utcnow, default_factory=datetime.utcnow)\r\n    \r\n    author = relationship('User', back_populates='posts')\r\n    bookmarks = relationship('Bookmark', back_populates='post')\r\n    likes = relationship('Like', back_populates='post')\r\n    comments = relationship('Comment', back_populates='post')\r\n    views = relationship('View', back_populates='post')"}
{"image_path": "data\\train\\00040.png", "code": "class User(Base):\r\n    __tablename__ = 'users'\r\n    \r\n    id: Mapped[str] = mapped_column(primary_key=True)\r\n    first_name: Mapped[str]\r\n    last_name: Mapped[str]\r\n    email_address: Mapped[str] = mapped_column(unique=True)\r\n    password: Mapped[str]\r\n    registration_date: Mapped[datetime] = mapped_column(default_factory=datetime.utcnow)\r\n    role: Mapped[str] = mapped_column(default='user')\r\n    activated: Mapped[bool] = mapped_column(default=False)\r\n    profile_picture_url: Mapped[str] = mapped_column(default='default.jpeg')\r\n    \r\n    posts = relationship('Post', back_populates='author')\r\n    bookmarks = relationship('Bookmark', back_populates='author')\r\n    likes = relationship('Like', back_populates='author')\r\n    comments = relationship('Comment', back_populates='author')\r\n    views = relationship('View', back_populates='author')\r\n    \r\n    @staticmethod\r\n    def hash_password(password: str) -> str:\r\n        return bcrypt.generate_password_hash(password).decode(\"utf-8\")\r\n\r\n    def check_password(self, password: str) -> bool:\r\n        return bcrypt.check_password_hash(self.password, password)"}
{"image_path": "data\\train\\00041.png", "code": "@staticmethod\r\n    def hash_password(password: str) -> str:\r\n        return bcrypt.generate_password_hash(password).decode(\"utf-8\")\r\n\r\n    def check_password(self, password: str) -> bool:\r\n        return bcrypt.check_password_hash(self.password, password)\r\n    \r\n    @staticmethod\r\n    def encode_auth_token(user_id: int):\r\n        try:\r\n            payload = {\r\n                \"exp\": datetime.utcnow() + timedelta(days=0, hours=2),\r\n                \"iat\": datetime.utcnow(),\r\n                \"sub\": user_id,\r\n            }\r\n            return jwt.encode(payload, current_app.config.get(\"SECRET_KEY\"), algorithm=\"HS256\")\r\n        except Exception as e:\r\n            return e\r\n        \r\n    @staticmethod\r\n    def decode_auth_token(auth_token: str):\r\n        try:\r\n            payload = jwt.decode(auth_token, current_app.config.get(\"SECRET_KEY\"), algorithms=\"HS256\")\r\n            return payload[\"sub\"]\r\n        except (ExpiredSignatureError, InvalidTokenError) as e:\r\n            raise e"}
{"image_path": "data\\train\\00042.png", "code": "@staticmethod\r\n    def hash_password(password: str) -> str:\r\n        return bcrypt.generate_password_hash(password).decode(\"utf-8\")\r\n\r\n    def check_password(self, password: str) -> bool:\r\n        return bcrypt.check_password_hash(self.password, password)\r\n    \r\n    @staticmethod\r\n    def encode_auth_token(user_id: int):\r\n        try:\r\n            payload = {\r\n                \"exp\": datetime.utcnow() + timedelta(days=0, hours=2),\r\n                \"iat\": datetime.utcnow(),\r\n                \"sub\": user_id,\r\n            }\r\n            return jwt.encode(payload, current_app.config.get(\"SECRET_KEY\"), algorithm=\"HS256\")\r\n        except Exception as e:\r\n            return e\r\n        \r\n    @staticmethod\r\n    def decode_auth_token(auth_token: str):\r\n        try:\r\n            payload = jwt.decode(auth_token, current_app.config.get(\"SECRET_KEY\"), algorithms=\"HS256\")\r\n            return payload[\"sub\"]\r\n        except (ExpiredSignatureError, InvalidTokenError) as e:\r\n            raise e"}
{"image_path": "data\\train\\00043.png", "code": "from datetime import datetime\r\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\r\nfrom ..database import Base\r\nfrom sqlalchemy import ForeignKey\r\n\r\n\r\nclass View(Base):\r\n    __tablename__ = 'views'\r\n    \r\n    id: Mapped[str] = mapped_column(primary_key=True)\r\n    author_id: Mapped[str] = mapped_column(ForeignKey('users.id'))\r\n    post_id: Mapped[str] = mapped_column(ForeignKey('posts.id'))\r\n    view_date: Mapped[datetime] = mapped_column(default_factory=datetime.utcnow)\r\n    \r\n    author = relationship('User', back_populates='views')\r\n    post = relationship('Post', back_populates='views')"}
{"image_path": "data\\train\\00044.png", "code": "from pydantic import BaseModel\r\nfrom typing import Optional\r\nfrom datetime import datetime\r\n\r\n\r\nclass CreateActivity(BaseModel):\r\n    user_id: str\r\n    post_id: str\r\n    \r\n\r\nclass ActivityCreated(CreateActivity):\r\n    date_created: datetime\r\n    \r\nclass RepeatableActivityCreated(ActivityCreated):\r\n    id: str\r\n    \r\nclass GetRepeatableActivity(BaseModel):\r\n    id: str\r\n    \r\nclass CreateComment(CreateActivity):\r\n    comment: str\r\n    \r\nclass CommentCreated(CreateComment):\r\n    comment_id: str\r\n    date_created: datetime"}
{"image_path": "data\\train\\00045.png", "code": "from pydantic import BaseModel\r\nfrom .post import PostAuthor\r\n    \r\nclass CommentSchema(BaseModel):\r\n    author: PostAuthor\r\n    text: str"}
{"image_path": "data\\train\\00046.png", "code": "from pydantic import BaseModel, Field\r\nfrom typing import Optional\r\nfrom datetime import datetime\r\n\r\n\r\nclass PostBase(BaseModel):\r\n    location: str\r\n    text: str\r\n    author_id: str\r\n\r\n\r\nclass CreatePost(PostBase):\r\n    pass\r\n\r\nclass UpdatePost(BaseModel):\r\n    post_id: str\r\n    author_id: str\r\n    location: Optional[str]\r\n    text: Optional[str]\r\n\r\nclass CreatedPost(PostBase):\r\n    date_published: datetime\r\n    id: str\r\n    image_url: str\r\n    likes: list\r\n    \r\nclass GetPost(BaseModel):\r\n    post_id: str"}
{"image_path": "data\\train\\00047.png", "code": "class GetPosts(BaseModel):\r\n    offset: Optional[int] = 0\r\n    limit: Optional[int] = 10\r\n    \r\nclass PostAuthor(BaseModel):\r\n    id: str\r\n    profile_picture: str\r\n    name: str\r\n    \r\nclass PostLike(BaseModel):\r\n    liked: bool\r\n    liked_by: Optional[list[PostAuthor]] = Field(default_factory=list)\r\n    key_like: Optional[PostAuthor] = None\r\n    likes_count: Optional[int] = Field(default=0)\r\n    \r\nclass KeyComment(BaseModel):\r\n    author: PostAuthor\r\n    text: str\r\n    comments_count: int\r\n    \r\nclass PostSchema(BaseModel):\r\n    id: str\r\n    text: str\r\n    image: str\r\n    author: PostAuthor\r\n    date_published: str\r\n    location: str\r\n    like: PostLike\r\n    bookmarked: bool\r\n    key_comment: Optional[KeyComment] = None"}
{"image_path": "data\\train\\00048.png", "code": "class GetPosts(BaseModel):\r\n    offset: Optional[int] = 0\r\n    limit: Optional[int] = 10\r\n    \r\nclass PostAuthor(BaseModel):\r\n    id: str\r\n    profile_picture: str\r\n    name: str\r\n    \r\nclass PostLike(BaseModel):\r\n    liked: bool\r\n    liked_by: Optional[list[PostAuthor]] = Field(default_factory=list)\r\n    key_like: Optional[PostAuthor] = None\r\n    likes_count: Optional[int] = Field(default=0)\r\n    \r\nclass KeyComment(BaseModel):\r\n    author: PostAuthor\r\n    text: str\r\n    comments_count: int\r\n    \r\nclass PostSchema(BaseModel):\r\n    id: str\r\n    text: str\r\n    image: str\r\n    author: PostAuthor\r\n    date_published: str\r\n    location: str\r\n    like: PostLike\r\n    bookmarked: bool\r\n    key_comment: Optional[KeyComment] = None"}
{"image_path": "data\\train\\00049.png", "code": "class GetPosts(BaseModel):\r\n    offset: Optional[int] = 0\r\n    limit: Optional[int] = 10\r\n    \r\nclass PostAuthor(BaseModel):\r\n    id: str\r\n    profile_picture: str\r\n    name: str\r\n    \r\nclass PostLike(BaseModel):\r\n    liked: bool\r\n    liked_by: Optional[list[PostAuthor]] = Field(default_factory=list)\r\n    key_like: Optional[PostAuthor] = None\r\n    likes_count: Optional[int] = Field(default=0)\r\n    \r\nclass KeyComment(BaseModel):\r\n    author: PostAuthor\r\n    text: str\r\n    comments_count: int\r\n    \r\nclass PostSchema(BaseModel):\r\n    id: str\r\n    text: str\r\n    image: str\r\n    author: PostAuthor\r\n    date_published: str\r\n    location: str\r\n    like: PostLike\r\n    bookmarked: bool\r\n    key_comment: Optional[KeyComment] = None"}
{"image_path": "data\\train\\00050.png", "code": "from pydantic import BaseModel\r\nfrom typing import Optional\r\n\r\n\r\nclass UserBase(BaseModel):\r\n  first_name: str\r\n  last_name: str\r\n  email_address: str\r\n\r\n  \r\nclass UserCreate(UserBase):\r\n    password: str\r\n    role: str = 'user'\r\n    activated: bool = False\r\n    \r\nclass UserCreated(UserBase):\r\n    id: str\r\n    activation_token: str\r\n\r\nclass User(UserBase):\r\n    id: str\r\n    \r\n    class Config:\r\n        from_attributes = True\r\n        \r\nclass GetUser(BaseModel):\r\n    user_id: str\r\n    \r\nclass GetUsers(BaseModel):\r\n    offset: Optional[int] = 0\r\n    limit: Optional[int] = 10\r\n    \r\nclass ActivateUser(BaseModel):\r\n    user_id: str\r\n    activation_token: str\r\n    \r\nclass LoginUser(BaseModel):\r\n    email_address: str\r\n    password: str"}
{"image_path": "data\\train\\00051.png", "code": "class LoggedInUser(BaseModel):\r\n    email_address: str\r\n    access_token: str\r\n    refresh_token: str\r\n    \r\nclass RequestPasswordReset(BaseModel):\r\n    user_id: str\r\n    email_address: str\r\n    \r\nclass RequestPasswordResetToken(RequestPasswordReset):\r\n    password_reset_token: str\r\n    \r\nclass PasswordReset(BaseModel):\r\n    email_address: str\r\n    password_reset_token: str\r\n    password: str\r\n    confirm_password: str"}
{"image_path": "data\\train\\00052.png", "code": "from sqlalchemy import create_engine\r\nfrom sqlalchemy.orm import DeclarativeBase, MappedAsDataclass\r\nfrom sqlalchemy.orm import sessionmaker\r\nfrom ...config.config import BaseConfig\r\nfrom contextlib import contextmanager\r\nfrom flask import current_app\r\n\r\n\r\nclass Base(MappedAsDataclass, DeclarativeBase):\r\n    pass\r\n\r\nSQLALCHEMY_DATABASE_URI = BaseConfig().db_conn_string\r\nengine = create_engine(SQLALCHEMY_DATABASE_URI)\r\nSession = sessionmaker(bind=engine, autocommit=False, autoflush=False)\r\n\r\ndef create_all():\r\n    Base.metadata.create_all(bind=engine)\r\n    \r\ndef drop_all():\r\n    Base.metadata.drop_all(bind=engine)\r\n\r\n@contextmanager\r\ndef get_db():\r\n    try:\r\n        db = Session()\r\n        yield db\r\n    finally:\r\n        db.close()"}
{"image_path": "data\\train\\00053.png", "code": "from sqlalchemy import create_engine\r\nfrom sqlalchemy.orm import DeclarativeBase, MappedAsDataclass\r\nfrom sqlalchemy.orm import sessionmaker\r\nfrom ...config.config import BaseConfig\r\nfrom contextlib import contextmanager\r\nfrom flask import current_app\r\n\r\n\r\nclass Base(MappedAsDataclass, DeclarativeBase):\r\n    pass\r\n\r\nSQLALCHEMY_DATABASE_URI = BaseConfig().db_conn_string\r\nengine = create_engine(SQLALCHEMY_DATABASE_URI)\r\nSession = sessionmaker(bind=engine, autocommit=False, autoflush=False)\r\n\r\ndef create_all():\r\n    Base.metadata.create_all(bind=engine)\r\n    \r\ndef drop_all():\r\n    Base.metadata.drop_all(bind=engine)\r\n\r\n@contextmanager\r\ndef get_db():\r\n    try:\r\n        db = Session()\r\n        yield db\r\n    finally:\r\n        db.close()"}
{"image_path": "data\\train\\00054.png", "code": "from sqlalchemy import create_engine\r\nfrom sqlalchemy.orm import DeclarativeBase, MappedAsDataclass\r\nfrom sqlalchemy.orm import sessionmaker\r\nfrom ...config.config import BaseConfig\r\nfrom contextlib import contextmanager\r\nfrom flask import current_app\r\n\r\n\r\nclass Base(MappedAsDataclass, DeclarativeBase):\r\n    pass\r\n\r\nSQLALCHEMY_DATABASE_URI = BaseConfig().db_conn_string\r\nengine = create_engine(SQLALCHEMY_DATABASE_URI)\r\nSession = sessionmaker(bind=engine, autocommit=False, autoflush=False)\r\n\r\ndef create_all():\r\n    Base.metadata.create_all(bind=engine)\r\n    \r\ndef drop_all():\r\n    Base.metadata.drop_all(bind=engine)\r\n\r\n@contextmanager\r\ndef get_db():\r\n    try:\r\n        db = Session()\r\n        yield db\r\n    finally:\r\n        db.close()"}
{"image_path": "data\\train\\00055.png", "code": "from sqlalchemy import create_engine\r\nfrom sqlalchemy.orm import DeclarativeBase, MappedAsDataclass\r\nfrom sqlalchemy.orm import sessionmaker\r\nfrom ...config.config import BaseConfig\r\nfrom contextlib import contextmanager\r\nfrom flask import current_app\r\n\r\n\r\nclass Base(MappedAsDataclass, DeclarativeBase):\r\n    pass\r\n\r\nSQLALCHEMY_DATABASE_URI = BaseConfig().db_conn_string\r\nengine = create_engine(SQLALCHEMY_DATABASE_URI)\r\nSession = sessionmaker(bind=engine, autocommit=False, autoflush=False)\r\n\r\ndef create_all():\r\n    Base.metadata.create_all(bind=engine)\r\n    \r\ndef drop_all():\r\n    Base.metadata.drop_all(bind=engine)\r\n\r\n@contextmanager\r\ndef get_db():\r\n    try:\r\n        db = Session()\r\n        yield db\r\n    finally:\r\n        db.close()"}
{"image_path": "data\\train\\00056.png", "code": "from ..database.crud.user import get_random_user\r\nfrom ..database.crud.post import get_posts\r\nfrom ..database.crud.like import list_post_likes, get_key_like, has_liked\r\nfrom ..database.crud.comment import get_key_comment, list_post_comments\r\nfrom ..database.crud.bookmark import has_bookmarked\r\nfrom ..database.database import get_db\r\nfrom ..database.models import (\r\n    User, Post, Like, Bookmark, Comment\r\n)\r\nfrom ..database.schemas.post import (\r\n    GetPosts, PostAuthor, GetPost, PostLike, KeyComment, PostSchema\r\n)\r\nfrom ..database.schemas.activity import CreateActivity\r\nfrom flask import url_for\r\nfrom pydantic import ValidationError\r\nfrom sqlalchemy.exc import OperationalError, IntegrityError\r\nfrom datetime import datetime"}
{"image_path": "data\\train\\00057.png", "code": "\"\"\"This module contains routes for the app.\"\"\"\r\nfrom flask import Blueprint, render_template, jsonify, request, url_for\r\nfrom http import HTTPStatus\r\nfrom ..database.schemas.activity import (\r\n    ActivityCreated, CreateActivity, RepeatableActivityCreated,\r\n    CreateComment, CommentCreated)\r\nfrom ..database.models import (\r\n    User, Post, Comment, Bookmark, Like, View\r\n)\r\nfrom ..database.schemas.user import GetUser\r\nfrom ..database.schemas.post import GetPost\r\nfrom ..database.database import get_db\r\nfrom ..database.crud.user import get_user, get_random_user\r\nfrom ..database.crud.post import get_post\r\nfrom ..database.crud.bookmark import (\r\n    create_bookmark, delete_bookmark, list_user_bookmarks, has_bookmarked\r\n)\r\nfrom ..database.crud.view import (\r\n    create_view, list_user_views, has_viewed\r\n)\r\nfrom ..database.crud.like import (\r\n    create_like, delete_like, list_user_likes, has_liked, list_post_likes, \r\n    get_key_like\r\n)\r\nfrom ..database.crud.comment import (\r\n    create_comment, list_user_comments, list_post_comments\r\n)\r\nfrom pydantic import ValidationError\r\nfrom sqlalchemy.exc import OperationalError, IntegrityError\r\nfrom ..database.schemas.post import (\r\n    CreatePost, CreatedPost, GetPost, GetPosts, UpdatePost, PostSchema, PostAuthor, \r\n    PostLike, KeyComment\r\n)\r\nfrom ..database.crud.post import (\r\n    create_post, get_post, get_posts, delete_post, update_post\r\n)\r\nfrom ..database.crud.comment import get_key_comment"}
{"image_path": "data\\train\\00058.png", "code": "\"\"\"This module contains routes for the app.\"\"\"\r\nfrom flask import Blueprint, flash, jsonify, redirect, render_template, request, url_for\r\nfrom http import HTTPStatus\r\nfrom ..database.schemas.post import (\r\n    CreatePost, CreatedPost, GetPost, GetPosts, UpdatePost, PostSchema, PostAuthor\r\n)\r\nfrom ..database.crud.post import (\r\n    create_post, get_post, get_posts, delete_post, update_post\r\n)\r\nfrom ..database.models.post import Post\r\nfrom ..database.database import get_db\r\nfrom pydantic import ValidationError\r\nfrom sqlalchemy.exc import OperationalError, IntegrityError\r\nfrom ..database.models.user import User\r\nfrom ..database.crud.user import get_user\r\nfrom ..database.schemas.user import GetUser\r\nfrom ..database.models.bookmark import Bookmark\r\nfrom ..database.crud.bookmark import list_post_bookmarks\r\nfrom ..database.schemas.activity import ActivityCreated, RepeatableActivityCreated, CommentCreated\r\nfrom ..database.crud.like import list_post_likes\r\nfrom ..database.models.like import Like\r\nfrom ..database.models.comment import Comment\r\nfrom ..database.models.view import View\r\nfrom ..database.schemas.comment import CommentSchema\r\nfrom ..database.crud.view import (\r\n    list_post_views\r\n)\r\nfrom ..database.crud.comment import list_post_comments\r\nfrom ..home.helpers import load_posts\r\n\r\npost = Blueprint(\"post\", __name__)"}
{"image_path": "data\\train\\00059.png", "code": "@post.route(\"/create\", methods=[\"POST\", \"GET\"])\r\ndef create_new_post():\r\n    \"\"\"Create a new post.\"\"\"\r\n    if request.method == 'GET':\r\n        return {'success': 'post creation form'}, HTTPStatus.OK\r\n    elif request.method == 'POST':\r\n        try:\r\n            post_data = CreatePost(**request.form) \r\n        except ValidationError:\r\n            return {'Error': 'The data provided is invalid or incomplete!'}, HTTPStatus.BAD_REQUEST\r\n        try:\r\n            user_data = GetUser(user_id=post_data.author_id)\r\n            user = get_user(session=get_db, user_data=user_data)\r\n            if not user:\r\n                return {'Error': f'User with id {user_data.user_id} does not exists'}, HTTPStatus.NOT_FOUND \r\n            post: Post = create_post(post_data=post_data, post_image=request.files, session=get_db) \r\n        except (OperationalError, IntegrityError) as e:\r\n            print(e)\r\n            # Send email to\r\n            return {'Error': 'The application is experiencing a tempoary error. Please try again in a few minutes.'}, HTTPStatus.INTERNAL_SERVER_ERROR\r\n        resp = CreatedPost(\r\n            id=post.id,\r\n            location=post.location,\r\n            text=post.text,\r\n            image_url=post.image_url,\r\n            author_id=post.author_id,\r\n            date_published=post.date_published\r\n        )\r\n        return resp.model_dump_json(indent=4), HTTPStatus.CREATED"}
{"image_path": "data\\train\\00060.png", "code": "@post.route(\"/create\", methods=[\"POST\", \"GET\"])\r\ndef create_new_post():\r\n    \"\"\"Create a new post.\"\"\"\r\n    if request.method == 'GET':\r\n        return {'success': 'post creation form'}, HTTPStatus.OK\r\n    elif request.method == 'POST':\r\n        try:\r\n            post_data = CreatePost(**request.form) \r\n        except ValidationError:\r\n            return {'Error': 'The data provided is invalid or incomplete!'}, HTTPStatus.BAD_REQUEST\r\n        try:\r\n            user_data = GetUser(user_id=post_data.author_id)\r\n            user = get_user(session=get_db, user_data=user_data)\r\n            if not user:\r\n                return {'Error': f'User with id {user_data.user_id} does not exists'}, HTTPStatus.NOT_FOUND \r\n            post: Post = create_post(post_data=post_data, post_image=request.files, session=get_db) \r\n        except (OperationalError, IntegrityError) as e:\r\n            print(e)\r\n            # Send email to\r\n            return {'Error': 'The application is experiencing a tempoary error. Please try again in a few minutes.'}, HTTPStatus.INTERNAL_SERVER_ERROR\r\n        resp = CreatedPost(\r\n            id=post.id,\r\n            location=post.location,\r\n            text=post.text,\r\n            image_url=post.image_url,\r\n            author_id=post.author_id,\r\n            date_published=post.date_published\r\n        )\r\n        return resp.model_dump_json(indent=4), HTTPStatus.CREATED"}
{"image_path": "data\\train\\00061.png", "code": "@post.route(\"/update\", methods=[\"PUT\"])\r\ndef update_one_post():\r\n    \"\"\"Update a post.\"\"\"\r\n    if request.method == 'GET':\r\n        return {'success': 'post creation form'}, HTTPStatus.OK\r\n    elif request.method == 'PUT':\r\n        try:\r\n            post_data = UpdatePost(\r\n                **request.form\r\n            )\r\n        except ValidationError:\r\n            return {'Error': 'The data provided is invalid or incomplete!'}, HTTPStatus.BAD_REQUEST\r\n        try:\r\n            user_data = GetUser(user_id=post_data.author_id)\r\n            user: User = get_user(session=get_db, user_data=user_data)\r\n            if not user:\r\n                return {'Error': f'User with id {user_data.user_id} does not exists'}, HTTPStatus.NOT_FOUND \r\n            post: Post = get_post(session=get_db, post_data=post_data)\r\n            if not post:\r\n                return {'Error': f'post with id {post_data.post_id} does not exists'}, HTTPStatus.NOT_FOUND\r\n            if user.id != post.author_id:\r\n                return {'Error': 'You can only update your own post!'}, HTTPStatus.FORBIDDEN\r\n            post: Post = update_post(post_data=post_data, post_image=request.files, session=get_db) \r\n        except (OperationalError, IntegrityError) as e:\r\n            print(e)\r\n            # Send email to\r\n            return {'Error': 'The application is experiencing a tempoary error. Please try again in a few minutes.'}, HTTPStatus.INTERNAL_SERVER_ERROR\r\n        resp = CreatedPost(\r\n            id=post.id,\r\n            location=post.location,\r\n            text=post.text,\r\n            image_url=post.image_url,\r\n            author_id=post.author_id,\r\n            date_published=post.date_published\r\n        )\r\n        return resp.model_dump_json(indent=4), HTTPStatus.CREATED"}
{"image_path": "data\\train\\00062.png", "code": "@post.route(\"/delete\", methods=[\"DELETE\"])\r\ndef delete_one_post():\r\n    \"\"\"Delete a post.\"\"\"\r\n    try:\r\n        post_data = GetPost(post_id=request.args.get('post_id'))\r\n    except ValidationError:\r\n        return {'error': 'Invalid input: you probably did not include the post id.'}, HTTPStatus.BAD_REQUEST\r\n    try:\r\n        post = get_post(session=get_db, post_data=post_data)\r\n        if not post:\r\n            return {'Error': f'post with id {post_data.post_id} does not exists'}, HTTPStatus.NOT_FOUND\r\n        post = delete_post(get_db, GetPost(post_id=request.args.get('post_id')))\r\n    except (OperationalError, IntegrityError) as e:\r\n        print(e)\r\n        # Send email to\r\n        return {'Error': 'The application is experiencing a tempoary error. Please try again in a few minutes.'}, HTTPStatus.INTERNAL_SERVER_ERROR\r\n    resp = CreatedPost(\r\n            id=post.id,\r\n            location=post.location,\r\n            text=post.text,\r\n            image_url=post.image_url,\r\n            author_id=post.author_id,\r\n            date_published=post.date_published\r\n        )\r\n    return resp.model_dump_json(indent=4), HTTPStatus.OK"}
{"image_path": "data\\train\\00063.png", "code": "@post.route(\"/get\", methods=[\"GET\"])\r\ndef get_one_post():\r\n    \"\"\"Get a single post.\"\"\"\r\n    try:\r\n        post_data = GetPost(post_id=request.args.get('post_id'))\r\n    except ValidationError:\r\n        return {'error': 'Invalid input: you probably did not include the post id.'}, HTTPStatus.BAD_REQUEST\r\n    try:\r\n        post = get_post(session=get_db, post_data=post_data)\r\n    except (OperationalError, IntegrityError) as e:\r\n        print(e)\r\n        # Send email to\r\n        return {'Error': 'The application is experiencing a tempoary error. Please try again in a few minutes.'}, HTTPStatus.INTERNAL_SERVER_ERROR\r\n    if post:\r\n        resp = CreatedPost(\r\n            id=post.id,\r\n            location=post.location,\r\n            text=post.text,\r\n            image_url=post.image_url,\r\n            author_id=post.author_id,\r\n            date_published=post.date_published\r\n        )\r\n        return resp.model_dump_json(indent=4), HTTPStatus.OK\r\n    \r\n    return {'Error':f'No post with id {post_data.post_id}'}, HTTPStatus.NOT_FOUND"}
{"image_path": "data\\train\\00064.png", "code": "@post.route(\"/posts\", methods=[\"GET\"])\r\ndef get_all_posts():\r\n    \"\"\"Get many post post.\"\"\"\r\n    offset: str = request.args.get('offset')\r\n    limit: str = request.args.get('limit')\r\n    try:\r\n        posts = get_posts(get_db, GetPosts(offset=offset, limit=limit))\r\n    except (OperationalError, IntegrityError) as e:\r\n            print(e)\r\n            # Send email to\r\n            return {'Error': 'The application is experiencing a tempoary error. Please try again in a few minutes.'}, HTTPStatus.INTERNAL_SERVER_ERROR\r\n    created_posts = []\r\n    for post in posts:\r\n        post_author: PostAuthor = PostAuthor(\r\n            id=post.author.id,\r\n            profile_picture=url_for('static', filename='img/default.jpeg'),\r\n            name=post.author.first_name\r\n        )\r\n        post_schema: PostSchema = PostSchema(\r\n            id=post.id,\r\n            text=post.text,\r\n            image=url_for('static', filename=f'img/{post.image_url}'),\r\n            location=post.location,\r\n            date_published='10',\r\n            author=post_author\r\n        ).model_dump()\r\n        created_posts.append(post_schema)"}
{"image_path": "data\\train\\00065.png", "code": "# posts = [\r\n    #     CreatedPost(\r\n    #         id=post.id,\r\n    #         location=post.location,\r\n    #         text=post.text,\r\n    #         image_url=post.image_url,\r\n    #         author_id=post.author_id,\r\n    #         date_published=post.date_published\r\n    #     ).model_dump()\r\n    #     for post in posts\r\n    # ]\r\n    return created_posts, HTTPStatus.OK\r\n\r\n@post.route(\"/load_more_posts\", methods=[\"GET\"])\r\ndef load_more_posts():\r\n    \"\"\"Get a single post.\"\"\"\r\n    offset: str = request.args.get('offset', 0)\r\n    limit: str = request.args.get('limit', 10)\r\n    more_posts = load_posts(limit=int(limit), offset=int(offset))\r\n    return more_posts"}
{"image_path": "data\\train\\00066.png", "code": "# posts = [\r\n    #     CreatedPost(\r\n    #         id=post.id,\r\n    #         location=post.location,\r\n    #         text=post.text,\r\n    #         image_url=post.image_url,\r\n    #         author_id=post.author_id,\r\n    #         date_published=post.date_published\r\n    #     ).model_dump()\r\n    #     for post in posts\r\n    # ]\r\n    return created_posts, HTTPStatus.OK\r\n\r\n@post.route(\"/load_more_posts\", methods=[\"GET\"])\r\ndef load_more_posts():\r\n    \"\"\"Get a single post.\"\"\"\r\n    offset: str = request.args.get('offset', 0)\r\n    limit: str = request.args.get('limit', 10)\r\n    more_posts = load_posts(limit=int(limit), offset=int(offset))\r\n    return more_posts"}
{"image_path": "data\\train\\00067.png", "code": "@post.route(\"/load_more_comments\", methods=[\"GET\"])\r\ndef load_more_comments():\r\n    \"\"\"Get a single post.\"\"\"\r\n    offset: str = request.args.get('offset', 0)\r\n    limit: str = request.args.get('limit', 10)\r\n    try:\r\n        post_data = GetPost(post_id=request.args.get('post_id'))\r\n    except ValidationError:\r\n        return {'error': 'Invalid input: you probably did not include the post id.'}, HTTPStatus.BAD_REQUEST\r\n    try:\r\n        post: Post = get_post(session=get_db, post_data=post_data)\r\n        if not post:\r\n            return {'Error': f'post with id {post_data.post_id} does not exists'}, HTTPStatus.NOT_FOUND\r\n        comments: list[Comment] = list_post_comments(session=get_db, post_data=post_data, offset=offset, limit=limit)\r\n    except (OperationalError, IntegrityError) as e:\r\n        print(e)\r\n        # Send email to\r\n        return {'Error': 'The application is experiencing a tempoary error. Please try again in a few minutes.'}, HTTPStatus.INTERNAL_SERVER_ERROR\r\n    post_comments = []\r\n    for comment in comments:\r\n        comment_author: PostAuthor = PostAuthor(\r\n            id=comment.author.id,\r\n            profile_picture=url_for('static', filename=f'img/{comment.author.profile_picture_url}'),\r\n            name=comment.author.first_name\r\n        )\r\n        comment_schema: CommentSchema = CommentSchema(\r\n            author=comment_author,\r\n            text=comment.comment_text\r\n        )\r\n        post_comments.append(comment_schema.model_dump())\r\n    return post_comments"}
{"image_path": "data\\train\\00068.png", "code": "@post.route(\"/load_more_comments\", methods=[\"GET\"])\r\ndef load_more_comments():\r\n    \"\"\"Get a single post.\"\"\"\r\n    offset: str = request.args.get('offset', 0)\r\n    limit: str = request.args.get('limit', 10)\r\n    try:\r\n        post_data = GetPost(post_id=request.args.get('post_id'))\r\n    except ValidationError:\r\n        return {'error': 'Invalid input: you probably did not include the post id.'}, HTTPStatus.BAD_REQUEST\r\n    try:\r\n        post: Post = get_post(session=get_db, post_data=post_data)\r\n        if not post:\r\n            return {'Error': f'post with id {post_data.post_id} does not exists'}, HTTPStatus.NOT_FOUND\r\n        comments: list[Comment] = list_post_comments(session=get_db, post_data=post_data, offset=offset, limit=limit)\r\n    except (OperationalError, IntegrityError) as e:\r\n        print(e)\r\n        # Send email to\r\n        return {'Error': 'The application is experiencing a tempoary error. Please try again in a few minutes.'}, HTTPStatus.INTERNAL_SERVER_ERROR\r\n    post_comments = []\r\n    for comment in comments:\r\n        comment_author: PostAuthor = PostAuthor(\r\n            id=comment.author.id,\r\n            profile_picture=url_for('static', filename=f'img/{comment.author.profile_picture_url}'),\r\n            name=comment.author.first_name\r\n        )\r\n        comment_schema: CommentSchema = CommentSchema(\r\n            author=comment_author,\r\n            text=comment.comment_text\r\n        )\r\n        post_comments.append(comment_schema.model_dump())\r\n    return post_comments"}
{"image_path": "data\\train\\00069.png", "code": "@post.route(\"/likes\", methods=[\"GET\"])\r\ndef get_post_likes():\r\n    \"\"\"Get a posts likes.\"\"\"\r\n    try:\r\n        post_data = GetPost(post_id=request.args.get('post_id'))\r\n    except ValidationError:\r\n        return {'error': 'Invalid input: you probably did not include the post id.'}, HTTPStatus.BAD_REQUEST\r\n    try:\r\n        post: Post = get_post(session=get_db, post_data=post_data)\r\n        if not post:\r\n            return {'Error': f'post with id {post_data.post_id} does not exists'}, HTTPStatus.NOT_FOUND\r\n        likes: list[Bookmark] = list_post_likes(session=get_db, post_data=post_data)\r\n    except (OperationalError, IntegrityError) as e:\r\n        print(e)\r\n        # Send email to\r\n        return {'Error': 'The application is experiencing a tempoary error. Please try again in a few minutes.'}, HTTPStatus.INTERNAL_SERVER_ERROR\r\n    resp = [\r\n        ActivityCreated(\r\n            user_id=like.author_id,\r\n            post_id=like.post_id,\r\n            date_created=like.like_date\r\n        ).model_dump()\r\n        for like in likes\r\n    ]\r\n    return resp, HTTPStatus.OK"}
{"image_path": "data\\train\\00070.png", "code": "@post.route(\"/likes\", methods=[\"GET\"])\r\ndef get_post_likes():\r\n    \"\"\"Get a posts likes.\"\"\"\r\n    try:\r\n        post_data = GetPost(post_id=request.args.get('post_id'))\r\n    except ValidationError:\r\n        return {'error': 'Invalid input: you probably did not include the post id.'}, HTTPStatus.BAD_REQUEST\r\n    try:\r\n        post: Post = get_post(session=get_db, post_data=post_data)\r\n        if not post:\r\n            return {'Error': f'post with id {post_data.post_id} does not exists'}, HTTPStatus.NOT_FOUND\r\n        likes: list[Bookmark] = list_post_likes(session=get_db, post_data=post_data)\r\n    except (OperationalError, IntegrityError) as e:\r\n        print(e)\r\n        # Send email to\r\n        return {'Error': 'The application is experiencing a tempoary error. Please try again in a few minutes.'}, HTTPStatus.INTERNAL_SERVER_ERROR\r\n    resp = [\r\n        ActivityCreated(\r\n            user_id=like.author_id,\r\n            post_id=like.post_id,\r\n            date_created=like.like_date\r\n        ).model_dump()\r\n        for like in likes\r\n    ]\r\n    return resp, HTTPStatus.OK"}
{"image_path": "data\\train\\00071.png", "code": "@post.route(\"/bookmarks\", methods=[\"GET\"])\r\ndef get_post_bookmarks():\r\n    \"\"\"Bookmark a single post.\"\"\"\r\n    try:\r\n        post_data = GetPost(post_id=request.args.get('post_id'))\r\n    except ValidationError:\r\n        return {'error': 'Invalid input: you probably did not include the post id.'}, HTTPStatus.BAD_REQUEST\r\n    try:\r\n        post: Post = get_post(session=get_db, post_data=post_data)\r\n        if not post:\r\n            return {'Error': f'post with id {post_data.post_id} does not exists'}, HTTPStatus.NOT_FOUND\r\n        bookmarks: list[Bookmark] = list_post_bookmarks(session=get_db, post_data=post_data)\r\n    except (OperationalError, IntegrityError) as e:\r\n        print(e)\r\n        # Send email to\r\n        return {'Error': 'The application is experiencing a tempoary error. Please try again in a few minutes.'}, HTTPStatus.INTERNAL_SERVER_ERROR\r\n    resp = [\r\n        ActivityCreated(\r\n            user_id=bookmark.author_id,\r\n            post_id=bookmark.post_id,\r\n            date_created=bookmark.bookmark_date\r\n        ).model_dump()\r\n        for bookmark in bookmarks\r\n    ]\r\n    return resp, HTTPStatus.OK"}
{"image_path": "data\\train\\00072.png", "code": "@post.route(\"/comments\", methods=[\"GET\"])\r\ndef get_post_comments():\r\n    \"\"\"Get a posts comments.\"\"\"\r\n    offset: str = request.args.get('offset', 0)\r\n    limit: str = request.args.get('limit', 10)\r\n    try:\r\n        post_data = GetPost(post_id=request.args.get('post_id'))\r\n    except ValidationError:\r\n        return {'error': 'Invalid input: you probably did not include the post id.'}, HTTPStatus.BAD_REQUEST\r\n    try:\r\n        post: Post = get_post(session=get_db, post_data=post_data)\r\n        if not post:\r\n            return {'Error': f'post with id {post_data.post_id} does not exists'}, HTTPStatus.NOT_FOUND\r\n        comments: list[Comment] = list_post_comments(session=get_db, post_data=post_data, offset=offset, limit=limit)\r\n    except (OperationalError, IntegrityError) as e:\r\n        print(e)\r\n        # Send email to\r\n        return {'Error': 'The application is experiencing a tempoary error. Please try again in a few minutes.'}, HTTPStatus.INTERNAL_SERVER_ERROR\r\n    resp = [\r\n        CommentCreated(\r\n            user_id=comment.author_id,\r\n            post_id=comment.post_id,\r\n            date_created=comment.comment_date,\r\n            comment_id=comment.id,\r\n            comment=comment.comment_text\r\n        ).model_dump()\r\n        for comment in comments\r\n    ]\r\n    return resp, HTTPStatus.OK"}
{"image_path": "data\\train\\00073.png", "code": "@post.route(\"/views\", methods=[\"GET\"])\r\ndef get_post_views():\r\n    \"\"\"Get a posts comments.\"\"\"\r\n    try:\r\n        post_data = GetPost(post_id=request.args.get('post_id'))\r\n    except ValidationError:\r\n        return {'error': 'Invalid input: you probably did not include the post id.'}, HTTPStatus.BAD_REQUEST\r\n    try:\r\n        post: Post = get_post(session=get_db, post_data=post_data)\r\n        if not post:\r\n            return {'Error': f'post with id {post_data.post_id} does not exists'}, HTTPStatus.NOT_FOUND\r\n        views: list[View] = list_post_views(session=get_db, post_data=post_data)\r\n    except (OperationalError, IntegrityError) as e:\r\n        print(e)\r\n        # Send email to\r\n        return {'Error': 'The application is experiencing a tempoary error. Please try again in a few minutes.'}, HTTPStatus.INTERNAL_SERVER_ERROR\r\n    resp = [\r\n        RepeatableActivityCreated(\r\n            user_id=view.author_id,\r\n            post_id=view.post_id,\r\n            date_created=view.view_date,\r\n            id=view.id\r\n        ).model_dump()\r\n        for view in views\r\n    ]\r\n    return resp, HTTPStatus.OK"}
{"image_path": "data\\train\\00074.png", "code": "\"\"\"This module declares the app configuration.\r\n\r\nThe classes include:\r\n\r\nBaseConfig:\r\n    Has all the configurations shared by all the environments.\r\n\r\n\"\"\"\r\nimport os\r\n\r\nfrom dotenv import load_dotenv\r\n\r\nload_dotenv()\r\n\r\n\r\nclass BaseConfig:\r\n    \"\"\"Base configuration.\"\"\"\r\n\r\n    DEBUG = True\r\n    TESTING = False\r\n    SECRET_KEY = os.environ[\"SECRET_KEY\"]\r\n    db_conn_string = 'sqlite:///./butterfly.db'\r\n    SQLALCHEMY_DATABASE_URI = db_conn_string\r\n    SQLALCHEMY_TRACK_MODIFICATIONS = False"}
{"image_path": "data\\train\\00075.png", "code": "\"\"\"This module declares the app configuration.\r\n\r\nThe classes include:\r\n\r\nBaseConfig:\r\n    Has all the configurations shared by all the environments.\r\n\r\n\"\"\"\r\nimport os\r\n\r\nfrom dotenv import load_dotenv\r\n\r\nload_dotenv()\r\n\r\n\r\nclass BaseConfig:\r\n    \"\"\"Base configuration.\"\"\"\r\n\r\n    DEBUG = True\r\n    TESTING = False\r\n    SECRET_KEY = os.environ[\"SECRET_KEY\"]\r\n    db_conn_string = 'sqlite:///./butterfly.db'\r\n    SQLALCHEMY_DATABASE_URI = db_conn_string\r\n    SQLALCHEMY_TRACK_MODIFICATIONS = False"}
{"image_path": "data\\train\\00076.png", "code": "class DevelopmentConfig(BaseConfig):\r\n    \"\"\"Development confuguration.\"\"\"\r\n\r\n    DEBUG = True\r\n    TESTING = False\r\n    \r\n\r\nclass TestingConfig(BaseConfig):\r\n    \"\"\"Testing configuration.\"\"\"\r\n\r\n    TESTING = True\r\n    SECRET_KEY = 'secret-key'\r\n    SQLALCHEMY_DATABASE_URI = 'sqlite:///'\r\n\r\nclass ProductionConfig(BaseConfig):\r\n    \"\"\"Production configuration.\"\"\"\r\n\r\n    TESTING = False\r\n\r\n\r\nConfig = {\r\n    \"development\": DevelopmentConfig,\r\n    \"test\": TestingConfig,\r\n    \"production\": ProductionConfig,\r\n    \"staging\": ProductionConfig,\r\n}"}
{"image_path": "data\\train\\00077.png", "code": "import logging.config\r\nimport logstash\r\n\r\nfrom dotenv import load_dotenv\r\n\r\nload_dotenv()\r\n\r\n\r\ndef create_dev_logger():\r\n    \"\"\"Create the application logger.\"\"\"\r\n    config = {\r\n        \"version\": 1,\r\n        \"disable_existing_loggers\": False,\r\n        \"formatters\": {\r\n            \"standard\": {\r\n                \"format\": \"%(asctime)s %(name)s %(levelname)s %(message)s\",\r\n                \"datefmt\": \"%Y-%m-%dT%H:%M:%S%z\",\r\n            },\r\n            \"json\": {\r\n                \"format\": \"%(asctime)s %(name)s %(levelname)s %(message)s\",\r\n                \"datefmt\": \"%Y-%m-%dT%H:%M:%S%z\",\r\n                \"class\": \"pythonjsonlogger.jsonlogger.JsonFormatter\",\r\n            },\r\n        },\r\n        \"handlers\": {\r\n            \"standard\": {\r\n                \"class\": \"logging.StreamHandler\",\r\n                \"formatter\": \"json\",\r\n            },\r\n        },\r\n        \"loggers\": {\"\": {\"handlers\": [\"standard\"], \"level\": logging.INFO}},\r\n    }\r\n\r\n    logging.config.dictConfig(config)\r\n\r\n    logger = logging.getLogger(__name__)\r\n\r\n    return logger"}
{"image_path": "data\\train\\00078.png", "code": "import logging.config\r\nimport logstash\r\n\r\nfrom dotenv import load_dotenv\r\n\r\nload_dotenv()\r\n\r\n\r\ndef create_dev_logger():\r\n    \"\"\"Create the application logger.\"\"\"\r\n    config = {\r\n        \"version\": 1,\r\n        \"disable_existing_loggers\": False,\r\n        \"formatters\": {\r\n            \"standard\": {\r\n                \"format\": \"%(asctime)s %(name)s %(levelname)s %(message)s\",\r\n                \"datefmt\": \"%Y-%m-%dT%H:%M:%S%z\",\r\n            },\r\n            \"json\": {\r\n                \"format\": \"%(asctime)s %(name)s %(levelname)s %(message)s\",\r\n                \"datefmt\": \"%Y-%m-%dT%H:%M:%S%z\",\r\n                \"class\": \"pythonjsonlogger.jsonlogger.JsonFormatter\",\r\n            },\r\n        },\r\n        \"handlers\": {\r\n            \"standard\": {\r\n                \"class\": \"logging.StreamHandler\",\r\n                \"formatter\": \"json\",\r\n            },\r\n        },\r\n        \"loggers\": {\"\": {\"handlers\": [\"standard\"], \"level\": logging.INFO}},\r\n    }\r\n\r\n    logging.config.dictConfig(config)\r\n\r\n    logger = logging.getLogger(__name__)\r\n\r\n    return logger"}
{"image_path": "data\\train\\00079.png", "code": "import logging.config\r\nimport logstash\r\n\r\nfrom dotenv import load_dotenv\r\n\r\nload_dotenv()\r\n\r\n\r\ndef create_dev_logger():\r\n    \"\"\"Create the application logger.\"\"\"\r\n    config = {\r\n        \"version\": 1,\r\n        \"disable_existing_loggers\": False,\r\n        \"formatters\": {\r\n            \"standard\": {\r\n                \"format\": \"%(asctime)s %(name)s %(levelname)s %(message)s\",\r\n                \"datefmt\": \"%Y-%m-%dT%H:%M:%S%z\",\r\n            },\r\n            \"json\": {\r\n                \"format\": \"%(asctime)s %(name)s %(levelname)s %(message)s\",\r\n                \"datefmt\": \"%Y-%m-%dT%H:%M:%S%z\",\r\n                \"class\": \"pythonjsonlogger.jsonlogger.JsonFormatter\",\r\n            },\r\n        },\r\n        \"handlers\": {\r\n            \"standard\": {\r\n                \"class\": \"logging.StreamHandler\",\r\n                \"formatter\": \"json\",\r\n            },\r\n        },\r\n        \"loggers\": {\"\": {\"handlers\": [\"standard\"], \"level\": logging.INFO}},\r\n    }\r\n\r\n    logging.config.dictConfig(config)\r\n\r\n    logger = logging.getLogger(__name__)\r\n\r\n    return logger"}
{"image_path": "data\\train\\00080.png", "code": "import logging.config\r\nimport logstash\r\n\r\nfrom dotenv import load_dotenv\r\n\r\nload_dotenv()\r\n\r\n\r\ndef create_dev_logger():\r\n    \"\"\"Create the application logger.\"\"\"\r\n    config = {\r\n        \"version\": 1,\r\n        \"disable_existing_loggers\": False,\r\n        \"formatters\": {\r\n            \"standard\": {\r\n                \"format\": \"%(asctime)s %(name)s %(levelname)s %(message)s\",\r\n                \"datefmt\": \"%Y-%m-%dT%H:%M:%S%z\",\r\n            },\r\n            \"json\": {\r\n                \"format\": \"%(asctime)s %(name)s %(levelname)s %(message)s\",\r\n                \"datefmt\": \"%Y-%m-%dT%H:%M:%S%z\",\r\n                \"class\": \"pythonjsonlogger.jsonlogger.JsonFormatter\",\r\n            },\r\n        },\r\n        \"handlers\": {\r\n            \"standard\": {\r\n                \"class\": \"logging.StreamHandler\",\r\n                \"formatter\": \"json\",\r\n            },\r\n        },\r\n        \"loggers\": {\"\": {\"handlers\": [\"standard\"], \"level\": logging.INFO}},\r\n    }\r\n\r\n    logging.config.dictConfig(config)\r\n\r\n    logger = logging.getLogger(__name__)\r\n\r\n    return logger"}
{"image_path": "data\\train\\00081.png", "code": "def create_prod_logger():\r\n    \"\"\"Create the application logger.\"\"\"\r\n    config = {\r\n        \"version\": 1,\r\n        \"disable_existing_loggers\": False,\r\n        \"formatters\": {\r\n            \"standard\": {\r\n                \"format\": \"%(asctime)s %(name)s %(levelname)s %(message)s\",\r\n                \"datefmt\": \"%Y-%m-%dT%H:%M:%S%z\",\r\n            },\r\n            \"json\": {\r\n                \"format\": \"%(asctime)s %(name)s %(levelname)s %(message)s\",\r\n                \"datefmt\": \"%Y-%m-%dT%H:%M:%S%z\",\r\n                \"class\": \"pythonjsonlogger.jsonlogger.JsonFormatter\",\r\n            },\r\n        },\r\n        \"handlers\": {\r\n            \"standard\": {\r\n                \"class\": \"logging.StreamHandler\",\r\n                \"formatter\": \"json\",\r\n            },\r\n        },\r\n        \"loggers\": {\"\": {\"handlers\": [\"standard\"], \"level\": logging.INFO}},\r\n    }\r\n\r\n    logging.config.dictConfig(config)\r\n\r\n    logger = logging.getLogger(__name__)\r\n\r\n    return logger"}
{"image_path": "data\\train\\00082.png", "code": "def create_logger(env=\"development\"):\r\n    app_logger = create_dev_logger()\r\n    if env == \"production\":\r\n        app_logger = create_prod_logger()\r\n    return app_logger\r\n\r\n\r\napp_logger = create_logger()\r\napp_logger.addHandler(logstash.TCPLogstashHandler(host='localhost', port=5959, version=1))"}
{"image_path": "data\\train\\00083.png", "code": "\"\"\"This script contains helper methods for use with the application.\"\"\"\r\nfrom flask import Flask\r\n\r\nfrom .config import Config\r\n\r\n\r\ndef set_configuration(app: Flask, flask_env: str = \"development\") -> None:\r\n    \"\"\"Set the application configuration.\r\n\r\n    The application configuration will depend on the\r\n    environment i.e Test, Development, Staging or Production.\r\n\r\n    Parameters\r\n    ----------\r\n    app: flask.Flask\r\n        A flask app instance.\r\n    \"\"\"\r\n    app.config.from_object(Config[flask_env])"}
{"image_path": "data\\train\\00084.png", "code": "from flask_bcrypt import Bcrypt\r\nfrom flask_cors import CORS\r\n\r\n\r\nbcrypt = Bcrypt()\r\ncors = CORS()"}
{"image_path": "data\\train\\00085.png", "code": "\"\"\"This module resgisters the application extensions.\r\n\r\nExample:\r\n    To register the extensions:\r\n        register_extensions(app)\r\n\r\n@Author: Lyle Okoth\r\n@Date: 28/06/2023\r\n@Portfolio: https://lyleokoth.oryks-sytem.com\r\n\"\"\"\r\nfrom flask import Flask\r\n\r\nfrom .extensions import bcrypt, cors\r\n\r\n\r\ndef register_extensions(app: Flask) -> None:\r\n    \"\"\"Register the application extensions.\r\n\r\n    Parameters\r\n    ----------\r\n    app: flask.Flask\r\n        The Flask app instance.\r\n    \"\"\"\r\n    bcrypt.init_app(app)\r\n    cors.init_app(app)"}
{"image_path": "data\\train\\00086.png", "code": "from ..blueprints.database.schemas.user import UserCreate\r\nfrom ..blueprints.database.schemas.post import CreatePost\r\nfrom ..blueprints.database.models import User, Post, Like, Comment, Bookmark\r\nfrom ..blueprints.database.database import get_db\r\nfrom ..blueprints.database.crud.user import create_user\r\nfrom ..blueprints.database.crud.post import create_post\r\nfrom faker import Faker\r\nfrom datetime import datetime, timedelta\r\nimport random\r\nfrom uuid import uuid4\r\n\r\n\r\nfake = Faker()"}
{"image_path": "data\\train\\00087.png", "code": "def generate_users(count: int = 10) -> list[UserCreate]:\r\n    \"\"\"Generate ten random users.\"\"\"\r\n    first_names = (fake.name() for _ in range(count))\r\n    last_names = (fake.name() for _ in range(count))\r\n    emails = (fake.email() for i in range(count))\r\n    profile_pictures = [f'profile-{i}.jpg' for i in range(21)]\r\n    return [\r\n        User(\r\n            id='User_' + str(uuid4()),\r\n            first_name=first_name,\r\n            last_name=last_name,\r\n            email_address=email,\r\n            password=User.hash_password('password'),\r\n            profile_picture_url=image\r\n        ) \r\n        for first_name, last_name, email, image in zip(first_names, last_names, emails, profile_pictures)\r\n    ]"}
{"image_path": "data\\train\\00088.png", "code": "def generate_posts(authors: list[User], count: int = 100) -> list[Post]:\r\n    \"\"\"Generate posts.\"\"\"\r\n    cities = [fake.city() for _ in range(10)]\r\n    posts_text = [fake.text() for _ in range(count)]\r\n    dates_published = (datetime.now() + timedelta(minutes=random.randint(1,60)) for _ in range(count))\r\n    post_images = [f'feed-{i}.jpg' for i in range(1,8)]\r\n    return [\r\n        Post(\r\n            id='Post_' + str(uuid4()),\r\n            author_id=random.choice(authors).id,\r\n            location=random.choice(cities),\r\n            text=text,\r\n            image_url=random.choice(post_images),\r\n            date_published=d\r\n        )\r\n        for text, d in zip(posts_text, dates_published)\r\n    ]\r\n    \r\ndef generate_likes(users: list[User], posts: list[Post], likes_count: int = 100) -> list[Like]:\r\n    \"\"\"Generate likes.\"\"\"\r\n    likes: list[Like] = []\r\n    ids = set()\r\n    for _ in range(likes_count):\r\n        author_id: str = random.choice(users).id\r\n        post_id: str = random.choice(posts).id\r\n        like: Like = Like(author_id=author_id, post_id=post_id)\r\n        if (author_id, post_id) not in ids:\r\n            likes.append(like)\r\n        ids.add((author_id, post_id))\r\n    return likes"}
{"image_path": "data\\train\\00089.png", "code": "ef generate_bookmarks(users: list[User], posts: list[Post], bookmarks_count: int = 100) -> list[Bookmark]:\r\n    \"\"\"Generate bookmarks.\"\"\"\r\n    bookmarks: list[Bookmark] = []\r\n    ids = set()\r\n    for _ in range(bookmarks_count):\r\n        author_id: str = random.choice(users).id\r\n        post_id: str = random.choice(posts).id\r\n        bookmark: bookmark = Bookmark(author_id=author_id, post_id=post_id)\r\n        if (author_id, post_id) not in ids:\r\n            bookmarks.append(bookmark)\r\n        ids.add((author_id, post_id))\r\n    return bookmarks\r\n\r\ndef generate_comments(users: list[User], posts: list[Post], comments_count: int = 500) -> list[Like]:\r\n    \"\"\"Generate likes.\"\"\"\r\n    comments: list[Comment] = []\r\n    ids = set()\r\n    for _ in range(comments_count):\r\n        author_id: str = random.choice(users).id\r\n        post_id: str = random.choice(posts).id\r\n        comment: comment = Comment(\r\n            id='Comment_' + str(uuid4()),\r\n            author_id=author_id, \r\n            post_id=post_id, \r\n            comment_text=fake.text() )\r\n        if (author_id, post_id) not in ids:\r\n            comments.append(comment)\r\n        ids.add((author_id, post_id))\r\n    return comments"}
{"image_path": "data\\train\\00090.png", "code": "ef generate_bookmarks(users: list[User], posts: list[Post], bookmarks_count: int = 100) -> list[Bookmark]:\r\n    \"\"\"Generate bookmarks.\"\"\"\r\n    bookmarks: list[Bookmark] = []\r\n    ids = set()\r\n    for _ in range(bookmarks_count):\r\n        author_id: str = random.choice(users).id\r\n        post_id: str = random.choice(posts).id\r\n        bookmark: bookmark = Bookmark(author_id=author_id, post_id=post_id)\r\n        if (author_id, post_id) not in ids:\r\n            bookmarks.append(bookmark)\r\n        ids.add((author_id, post_id))\r\n    return bookmarks\r\n\r\ndef generate_comments(users: list[User], posts: list[Post], comments_count: int = 500) -> list[Like]:\r\n    \"\"\"Generate likes.\"\"\"\r\n    comments: list[Comment] = []\r\n    ids = set()\r\n    for _ in range(comments_count):\r\n        author_id: str = random.choice(users).id\r\n        post_id: str = random.choice(posts).id\r\n        comment: comment = Comment(\r\n            id='Comment_' + str(uuid4()),\r\n            author_id=author_id, \r\n            post_id=post_id, \r\n            comment_text=fake.text() )\r\n        if (author_id, post_id) not in ids:\r\n            comments.append(comment)\r\n        ids.add((author_id, post_id))\r\n    return comments"}
{"image_path": "data\\train\\00091.png", "code": "ef generate_bookmarks(users: list[User], posts: list[Post], bookmarks_count: int = 100) -> list[Bookmark]:\r\n    \"\"\"Generate bookmarks.\"\"\"\r\n    bookmarks: list[Bookmark] = []\r\n    ids = set()\r\n    for _ in range(bookmarks_count):\r\n        author_id: str = random.choice(users).id\r\n        post_id: str = random.choice(posts).id\r\n        bookmark: bookmark = Bookmark(author_id=author_id, post_id=post_id)\r\n        if (author_id, post_id) not in ids:\r\n            bookmarks.append(bookmark)\r\n        ids.add((author_id, post_id))\r\n    return bookmarks\r\n\r\ndef generate_comments(users: list[User], posts: list[Post], comments_count: int = 500) -> list[Like]:\r\n    \"\"\"Generate likes.\"\"\"\r\n    comments: list[Comment] = []\r\n    ids = set()\r\n    for _ in range(comments_count):\r\n        author_id: str = random.choice(users).id\r\n        post_id: str = random.choice(posts).id\r\n        comment: comment = Comment(\r\n            id='Comment_' + str(uuid4()),\r\n            author_id=author_id, \r\n            post_id=post_id, \r\n            comment_text=fake.text() )\r\n        if (author_id, post_id) not in ids:\r\n            comments.append(comment)\r\n        ids.add((author_id, post_id))\r\n    return comments"}
{"image_path": "data\\train\\00092.png", "code": "def add_user(user: User) -> User:\r\n    with get_db() as session:\r\n        session.add(user)\r\n        session.commit()\r\n        session.refresh(user)\r\n    return user\r\n\r\ndef add_post(post: Post) -> Post:\r\n    with get_db() as session:\r\n        session.add(post)\r\n        session.commit()\r\n        session.refresh(post)\r\n    return post\r\n\r\ndef add_likes(likes: list[Like]) -> None:\r\n    with get_db() as session:\r\n        for like in likes:\r\n            session.add(like)\r\n        session.commit()\r\n        \r\ndef add_bookmarks(bookmarks: list[Bookmark]) -> None:\r\n    with get_db() as session:\r\n        for bookmark in bookmarks:\r\n            session.add(bookmark)\r\n        session.commit()\r\n    \r\ndef add_comments(comments: list[Comment]) -> None:\r\n    with get_db() as session:\r\n        for comment in comments:\r\n            session.add(comment)\r\n        session.commit()"}
{"image_path": "data\\train\\00093.png", "code": "def add_user(user: User) -> User:\r\n    with get_db() as session:\r\n        session.add(user)\r\n        session.commit()\r\n        session.refresh(user)\r\n    return user\r\n\r\ndef add_post(post: Post) -> Post:\r\n    with get_db() as session:\r\n        session.add(post)\r\n        session.commit()\r\n        session.refresh(post)\r\n    return post\r\n\r\ndef add_likes(likes: list[Like]) -> None:\r\n    with get_db() as session:\r\n        for like in likes:\r\n            session.add(like)\r\n        session.commit()\r\n        \r\ndef add_bookmarks(bookmarks: list[Bookmark]) -> None:\r\n    with get_db() as session:\r\n        for bookmark in bookmarks:\r\n            session.add(bookmark)\r\n        session.commit()\r\n    \r\ndef add_comments(comments: list[Comment]) -> None:\r\n    with get_db() as session:\r\n        for comment in comments:\r\n            session.add(comment)\r\n        session.commit()"}
{"image_path": "data\\train\\00094.png", "code": "def generate_data(\r\n    user_count: int = 200, \r\n    posts_count: int = 500, \r\n    likes_count: int = 2000, \r\n    comments_count: int = 1000,\r\n    bookmarks_count: int = 1500\r\n    ):\r\n    users = generate_users(user_count)\r\n    users = [\r\n        add_user(user) for user in users\r\n    ]\r\n    posts: list[Post] = generate_posts(users, count=posts_count)\r\n    posts: list[Post] = [\r\n        add_post(post) for post in posts\r\n    ]\r\n    likes: list[Like] = generate_likes(users, posts, likes_count=likes_count)\r\n    add_likes(likes)\r\n    \r\n    comments: list[Comment] = generate_comments(users, posts, comments_count=comments_count)\r\n    add_comments(comments)\r\n    \r\n    bookmarks: list[Bookmark] = generate_bookmarks(users, posts, bookmarks_count=bookmarks_count)\r\n    add_bookmarks(bookmarks)"}
{"image_path": "data\\train\\00095.png", "code": "from http import HTTPStatus\r\n\r\nfrom flask import Flask, Response, jsonify, make_response\r\n\r\n\r\ndef handle_resource_not_found(exeption: Exception) -> Response:\r\n    \"\"\"Handle all resource not found errors.\r\n\r\n    Called when an requested resource is not found on the server.\r\n\r\n    Parameters\r\n    ----------\r\n    exception: Exception\r\n        The exception that was raised. This is a subclass of Exception.\r\n\r\n    Returns\r\n    -------\r\n    Response:\r\n        A string consiting of json data and response code.\r\n    \"\"\"\r\n    return make_response(jsonify({\"error\": str(exeption)}), HTTPStatus.NOT_FOUND)"}
{"image_path": "data\\train\\00096.png", "code": "def handle_method_not_allowed(exeption: Exception) -> Response:\r\n    \"\"\"Handle all method not allowed errors.\r\n\r\n    Called when a route tries to handle a request with a methods that is not\r\n    allowed for the given route.\r\n\r\n    Parameters\r\n    ----------\r\n    exception: Exception\r\n        The exception that was raised. This is a subclass of Exception.\r\n\r\n    Returns\r\n    -------\r\n    Response:\r\n        A string consiting of json data and response code.\r\n    \"\"\"\r\n    return make_response(jsonify({\"error\": str(exeption)}), HTTPStatus.METHOD_NOT_ALLOWED)\r\n\r\n\r\ndef handle_internal_server_error(exeption: Exception) -> Response:\r\n    \"\"\"Handle all internal server errors.\r\n\r\n    This method is called when an error occurs within the application server.\r\n\r\n    Parameters\r\n    ----------\r\n    exception: Exception\r\n        The exception that was raised. This is a subclass of Exception.\r\n\r\n    Returns\r\n    -------\r\n    Response:\r\n        A string consiting of json data and response code.\r\n    \"\"\"\r\n    return make_response(jsonify({\"error\": str(exeption)}), HTTPStatus.INTERNAL_SERVER_ERROR)"}
{"image_path": "data\\train\\00097.png", "code": "def handle_unsupported_media_type(exeption: Exception) -> Response:\r\n    \"\"\"Handle all unsupported media type errors.\r\n\r\n    This method is called when a a request does not supply the data or the data supplied is\r\n    invalid.\r\n\r\n    Parameters\r\n    ----------\r\n    exception: Exception\r\n        The exception that was raised. This is a subclass of Exception.\r\n\r\n    Returns\r\n    -------\r\n    Response:\r\n        A string consiting of json data and response code.\r\n    \"\"\"\r\n    return make_response(jsonify({\"error\": str(exeption)}), HTTPStatus.UNSUPPORTED_MEDIA_TYPE)\r\n\r\n\r\ndef register_error_handlers(app: Flask) -> None:\r\n    \"\"\"Register the error handlers.\r\n\r\n    Parameters\r\n    ----------\r\n    app: flask.Flask\r\n        The Flask app instance.\r\n    \"\"\"\r\n    app.register_error_handler(HTTPStatus.NOT_FOUND, handle_resource_not_found)\r\n    app.register_error_handler(HTTPStatus.METHOD_NOT_ALLOWED, handle_method_not_allowed)\r\n    app.register_error_handler(HTTPStatus.INTERNAL_SERVER_ERROR, handle_internal_server_error)\r\n    app.register_error_handler(HTTPStatus.UNSUPPORTED_MEDIA_TYPE, handle_unsupported_media_type)"}
{"image_path": "data\\train\\00098.png", "code": "def handle_unsupported_media_type(exeption: Exception) -> Response:\r\n    \"\"\"Handle all unsupported media type errors.\r\n\r\n    This method is called when a a request does not supply the data or the data supplied is\r\n    invalid.\r\n\r\n    Parameters\r\n    ----------\r\n    exception: Exception\r\n        The exception that was raised. This is a subclass of Exception.\r\n\r\n    Returns\r\n    -------\r\n    Response:\r\n        A string consiting of json data and response code.\r\n    \"\"\"\r\n    return make_response(jsonify({\"error\": str(exeption)}), HTTPStatus.UNSUPPORTED_MEDIA_TYPE)\r\n\r\n\r\ndef register_error_handlers(app: Flask) -> None:\r\n    \"\"\"Register the error handlers.\r\n\r\n    Parameters\r\n    ----------\r\n    app: flask.Flask\r\n        The Flask app instance.\r\n    \"\"\"\r\n    app.register_error_handler(HTTPStatus.NOT_FOUND, handle_resource_not_found)\r\n    app.register_error_handler(HTTPStatus.METHOD_NOT_ALLOWED, handle_method_not_allowed)\r\n    app.register_error_handler(HTTPStatus.INTERNAL_SERVER_ERROR, handle_internal_server_error)\r\n    app.register_error_handler(HTTPStatus.UNSUPPORTED_MEDIA_TYPE, handle_unsupported_media_type)"}
{"image_path": "data\\train\\00099.png", "code": "import json\r\n\r\nfrom flask import request, Flask\r\n\r\nfrom ..config.logger_config import app_logger\r\nfrom .rate_limiter import request_is_rate_limited\r\nfrom redis import Redis\r\nfrom datetime import timedelta\r\nfrom http import HTTPStatus\r\n\r\nr = Redis(host='localhost', port=6379, db=0)\r\n\r\n\r\ndef log_post_request():\r\n    request_data = {\r\n        \"method\": request.method,\r\n        \"url root\": request.url_root,\r\n        \"user agent\": request.user_agent,\r\n        \"scheme\": request.scheme,\r\n        \"remote address\": request.remote_addr,\r\n        \"headers\": request.headers,\r\n    }\r\n    if request.args:\r\n        request_data[\"args\"] = request.args\r\n    if request.form:\r\n        request_data[\"data\"] = request.form\r\n    else:\r\n        request_data[\"data\"] = request.json\r\n    if request.cookies:\r\n        request_data[\"cookies\"] = request.cookies\r\n    if request.files:\r\n        request_data[\"image\"] = {\r\n            \"filename\": request.files[\"Image\"].filename,\r\n            \"content type\": request.files[\"Image\"].content_type,\r\n            \"size\": len(request.files[\"Image\"].read()) // 1000,\r\n        }\r\n    app_logger.info(str(request_data))"}
{"image_path": "data\\train\\00100.png", "code": "def log_get_request():\r\n    request_data = {\r\n        \"method\": request.method,\r\n        \"url root\": request.url_root,\r\n        \"user agent\": request.user_agent,\r\n        \"scheme\": request.scheme,\r\n        \"remote address\": request.remote_addr,\r\n        \"headers\": request.headers,\r\n        \"route\": request.endpoint,\r\n        \"base url\": request.base_url,\r\n        \"url\": request.url,\r\n    }\r\n    if request.args:\r\n        request_data[\"args\"] = request.args\r\n    if request.cookies:\r\n        request_data[\"cookies\"] = request.cookies\r\n    app_logger.info(str(request_data))\r\n\r\n\r\ndef get_response(response):\r\n    response_data = {\r\n        \"status\": response.status,\r\n        \"status code\": response.status_code,\r\n        \"response\": json.loads(response.data),\r\n    }\r\n    app_logger.info(str(response_data))"}
{"image_path": "data\\train\\00101.png", "code": "def get_exception(exc):\r\n    \"\"\"Log exceptions\"\"\"\r\n    if exc:\r\n        app_logger.warning(f\"{exc.__class__.__name__ }: {str(exc)}\")\r\n        \r\n        \r\ndef register_app_hooks(app: Flask):\r\n    @app.before_first_request\r\n    def application_startup():\r\n        \"\"\"Log the beginning of the application.\"\"\"\r\n        app_logger.info('Web app is up!')\r\n\r\n    @app.before_request\r\n    def log_request():\r\n        \"\"\"Log the data held in the request\"\"\"\r\n        if request.method in ['POST', 'PUT']:\r\n            log_post_request()\r\n        elif request.method in ['GET', 'DELETE']:\r\n            log_get_request()\r\n\r\n    @app.after_request\r\n    def log_response(response):\r\n        try:\r\n            get_response(response)\r\n        except Exception:\r\n            pass\r\n        finally:\r\n            return response\r\n\r\n    @app.teardown_request\r\n    def log_exception(exc):\r\n        get_exception(exc)"}
{"image_path": "data\\train\\00102.png", "code": "def get_exception(exc):\r\n    \"\"\"Log exceptions\"\"\"\r\n    if exc:\r\n        app_logger.warning(f\"{exc.__class__.__name__ }: {str(exc)}\")\r\n        \r\n        \r\ndef register_app_hooks(app: Flask):\r\n    @app.before_first_request\r\n    def application_startup():\r\n        \"\"\"Log the beginning of the application.\"\"\"\r\n        app_logger.info('Web app is up!')\r\n\r\n    @app.before_request\r\n    def log_request():\r\n        \"\"\"Log the data held in the request\"\"\"\r\n        if request.method in ['POST', 'PUT']:\r\n            log_post_request()\r\n        elif request.method in ['GET', 'DELETE']:\r\n            log_get_request()\r\n\r\n    @app.after_request\r\n    def log_response(response):\r\n        try:\r\n            get_response(response)\r\n        except Exception:\r\n            pass\r\n        finally:\r\n            return response\r\n\r\n    @app.teardown_request\r\n    def log_exception(exc):\r\n        get_exception(exc)"}
{"image_path": "data\\train\\00103.png", "code": "def get_exception(exc):\r\n    \"\"\"Log exceptions\"\"\"\r\n    if exc:\r\n        app_logger.warning(f\"{exc.__class__.__name__ }: {str(exc)}\")\r\n        \r\n        \r\ndef register_app_hooks(app: Flask):\r\n    @app.before_first_request\r\n    def application_startup():\r\n        \"\"\"Log the beginning of the application.\"\"\"\r\n        app_logger.info('Web app is up!')\r\n\r\n    @app.before_request\r\n    def log_request():\r\n        \"\"\"Log the data held in the request\"\"\"\r\n        if request.method in ['POST', 'PUT']:\r\n            log_post_request()\r\n        elif request.method in ['GET', 'DELETE']:\r\n            log_get_request()\r\n\r\n    @app.after_request\r\n    def log_response(response):\r\n        try:\r\n            get_response(response)\r\n        except Exception:\r\n            pass\r\n        finally:\r\n            return response\r\n\r\n    @app.teardown_request\r\n    def log_exception(exc):\r\n        get_exception(exc)"}
{"image_path": "data\\train\\00104.png", "code": "def get_exception(exc):\r\n    \"\"\"Log exceptions\"\"\"\r\n    if exc:\r\n        app_logger.warning(f\"{exc.__class__.__name__ }: {str(exc)}\")\r\n        \r\n        \r\ndef register_app_hooks(app: Flask):\r\n    @app.before_first_request\r\n    def application_startup():\r\n        \"\"\"Log the beginning of the application.\"\"\"\r\n        app_logger.info('Web app is up!')\r\n\r\n    @app.before_request\r\n    def log_request():\r\n        \"\"\"Log the data held in the request\"\"\"\r\n        if request.method in ['POST', 'PUT']:\r\n            log_post_request()\r\n        elif request.method in ['GET', 'DELETE']:\r\n            log_get_request()\r\n\r\n    @app.after_request\r\n    def log_response(response):\r\n        try:\r\n            get_response(response)\r\n        except Exception:\r\n            pass\r\n        finally:\r\n            return response\r\n\r\n    @app.teardown_request\r\n    def log_exception(exc):\r\n        get_exception(exc)"}
{"image_path": "data\\train\\00105.png", "code": "\r\ndef get_exception(exc):\r\n    \"\"\"Log exceptions\"\"\"\r\n    if exc:\r\n        app_logger.warning(f\"{exc.__class__.__name__ }: {str(exc)}\")\r\n"}
{"image_path": "data\\train\\00106.png", "code": "\r\ndef create_like(session: Session, activity: CreateActivity) -> Like:\r\n    with session() as db:\r\n        like: Like = Like(\r\n            author_id=activity.user_id,\r\n            post_id=activity.post_id\r\n        )\r\n        db.add(like)\r\n        db.commit()\r\n        db.refresh(like)\r\n    return like\r\n"}
{"image_path": "data\\train\\00107.png", "code": "\r\ndef create_like(session: Session, activity: CreateActivity) -> Like:\r\n    with session() as db:\r\n        like: Like = Like(\r\n            author_id=activity.user_id,\r\n            post_id=activity.post_id\r\n        )\r\n        db.add(like)\r\n        db.commit()\r\n        db.refresh(like)\r\n    return like\r\n"}
{"image_path": "data\\train\\00108.png", "code": "\r\n# @app.before_request\r\n    # def rate_limit_request():\r\n    #     if request_is_rate_limited(r, 'admin', 10, timedelta(seconds=60)):\r\n    #         return {'Error': 'You have exceeded the allowed requests'}, HTTPStatus.TOO_MANY_REQUESTS\r\n"}
{"image_path": "data\\train\\00109.png", "code": "\r\nfrom datetime import timedelta\r\nfrom redis import Redis\r\n\r\ndef request_is_rate_limited(r: Redis, key: str, limit: int, period: timedelta):\r\n    if r.setnx(key, limit):\r\n        r.expire(key, int(period.total_seconds()))\r\n    bucket_val = r.get(key)\r\n    if bucket_val and int(bucket_val) > 0:\r\n        r.decrby(key, 1)\r\n        return False\r\n    return True\r\n"}
{"image_path": "data\\train\\00110.png", "code": "\r\nclass DirectoryIterator:\r\n    def __init__(self, config: Config):\r\n        self.config: Config = config\r\n        self.queue: deque[str] = deque(self.config.path)\r\n\r\n    def __iter__(self) -> Iterator:\r\n        return self\r\n\r\n    def __next__(self) -> list[str]:\r\n        files: list[str] = list()\r\n        if self.queue:\r\n            for _ in range(len(self.queue)):\r\n                root_dir: str = self.queue.popleft()\r\n                if root_dir.split('/')[-1] in self.config.directories_ignore:\r\n                    continue\r\n                entries: list[str] = listdir(root_dir)\r\n                for entry in entries:\r\n                    entry_path: str = path.join(root_dir, entry)\r\n                    if path.isfile(entry_path):\r\n                        if (\r\n                            entry_path not in self.config.files_ignore\r\n                            and entry.split('.')[-1] == 'py'\r\n                        ):\r\n                            files.append(entry_path)\r\n                    elif entry not in self.config.directories_ignore:\r\n                        self.queue.append(entry_path)\r\n            return files\r\n        else:\r\n            raise StopIteration()\r\n"}
{"image_path": "data\\train\\00111.png", "code": "\r\nclass Config(BaseModel):\r\n    path: set[str] = Field(description='The path to the source code directory')\r\n    overwrite_function_docstring: Optional[bool] = Field(\r\n        description='Whether or not to overwrite the existing function docstring',\r\n        default=False,\r\n    )\r\n    overwrite_class_docstring: Optional[bool] = Field(\r\n        description='Whether or not to overwrite the existing class docstring',\r\n        default=False,\r\n    )\r\n    overwrite_class_methods_docstring: Optional[bool] = Field(\r\n        description='Whether or not to overwrite the existing class methods docstring',\r\n        default=False,\r\n    )\r\n    documentation_style: Optional[str] = Field(\r\n        description='The format of documentation to use',\r\n        default='Numpy-Style',\r\n        enum=['Numpy-Style', 'Google-Style', 'Sphinx-Style'],\r\n    )\r\n    directories_ignore: set[str] = Field(\r\n        description='Directories to ignore',\r\n        default={'venv', '.venv', '__pycache__', '.git', 'build', 'dist', 'docs'},\r\n    )\r\n    files_ignore: set[str] = Field(\r\n        description='Files to ignore',\r\n        default_factory=set,\r\n    )\r\n"}
{"image_path": "data\\train\\00112.png", "code": "def generate_class_docstring(class_code: str, config: Config) -> str:\r\n    prompt_formatted_str: str = get_class_prompt_template(\r\n        class_code=class_code, config=config\r\n    )\r\n    class_and_docstring = llm.invoke(prompt_formatted_str)\r\n    return class_and_docstring\r\n\r\n\r\ndef get_class_docstring(class_and_docstring: str) -> str:\r\n    \"\"\"Get the class docstring.\"\"\"\r\n    class_tree = ast.parse(class_and_docstring)\r\n    for node in class_tree.body:\r\n        if isinstance(node, ClassDef):\r\n            cls_docstring: str = ast.get_docstring(node)\r\n            return cls_docstring"}
{"image_path": "data\\train\\00113.png", "code": "from dotenv import load_dotenv\r\nload_dotenv()\r\nfrom flask.cli import FlaskGroup\r\nfrom api import create_app\r\n\r\napp = create_app()\r\ncli = FlaskGroup(create_app=create_app)\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    cli()"}
{"image_path": "data\\train\\00114.png", "code": "# utils.py\r\n\r\nfrom playwright.sync_api import sync_playwright\r\nimport uuid\r\nfrom PIL import Image\r\nfrom PIL import Image\r\nimport io\r\nfrom os import path\r\nimport json\r\n\r\nindex: int = 1\r\n\r\ndef take_screenshot_from_url(url, session_data):\r\n    with sync_playwright() as playwright:\r\n        webkit = playwright.webkit\r\n        browser = webkit.launch()\r\n        browser_context = browser.new_context(device_scale_factor=2)\r\n        browser_context.add_cookies([session_data])\r\n        page = browser_context.new_page()\r\n        page.goto(url)\r\n        screenshot_bytes = page.locator(\".code\").screenshot()\r\n        browser.close()\r\n        return screenshot_bytes\r\n    \r\n    \r\ndef save_data(image_bytes: bytes, code: str) -> None:\r\n    file_name: str = str(uuid.uuid4())\r\n    image: Image = Image.open(io.BytesIO(image_bytes))\r\n    file_path: str = \"data\"\r\n    image_path: str = path.join(file_path, f\"{file_name}.png\")\r\n    image.save(image_path)\r\n    code_path: str = path.join(file_path, \"metadata.jsonl\")\r\n    metadata: dict = {\r\n        \"file_name\": f\"{file_name}.png\",\r\n        \"code\": code\r\n    }\r\n    with open(code_path, \"a+\", encoding=\"utf-8\") as f:\r\n        f.write(json.dumps(metadata) + \"\\n\")"}
{"image_path": "data\\train\\00115.png", "code": "import os\r\nfrom .config import Config\r\nfrom flask import Flask\r\n\r\n\r\ndef set_configuration(app: Flask):\r\n    \"\"\"Set the application configuration.\r\n\r\n    The application configuration will depend on the\r\n    environment i.e Test, Development, Staging or Production.\r\n\r\n    Parameters\r\n    ----------\r\n    app: flask.Flask\r\n        A flask app instance\r\n\r\n    Returns\r\n    -------\r\n    bool:\r\n        Whether the config was set up successfully.\r\n    \"\"\"\r\n    config_name = os.environ.get(\"FLASK_ENV\")\r\n    app.config.from_object(Config[config_name])\r\n\r\n    return True"}
{"image_path": "data\\train\\00116.png", "code": "from .set_config import set_configuration"}
{"image_path": "data\\train\\00117.png", "code": "\"\"\"This module declares the app configuration.\r\n\r\nThe classes include:\r\n\r\nBaseConfig:\r\n    Has all the configurations shared by all the environments.\r\n\r\n\"\"\"\r\nimport os\r\n\r\nfrom dotenv import load_dotenv\r\n\r\nload_dotenv()\r\n\r\n\r\nclass BaseConfig:\r\n    \"\"\"Base configuration.\"\"\"\r\n\r\n    DEBUG = True\r\n    TESTING = False\r\n    SECRET_KEY = os.environ.get(\r\n        \"SECRET_KEY\", \"df0331cefc6c2b9a5d0208a726a5d1c0fd37324feba25506\"\r\n    )\r\n\r\n\r\nclass DevelopmentConfig(BaseConfig):\r\n    \"\"\"Development confuguration.\"\"\"\r\n\r\n    DEBUG = True\r\n    TESTING = False\r\n    SECRET_KEY = os.environ.get(\r\n        \"SECRET_KEY\", \"df0331cefc6c2b9a5d0208a726a5d1c0fd37324feba25506\"\r\n    )\r\n\r\n\r\nclass TestingConfig(BaseConfig):\r\n    \"\"\"Testing configuration.\"\"\"\r\n\r\n    TESTING = True\r\n    SECRET_KEY = os.environ.get(\"SECRET_KEY\", \"secret-key\")\r\n"}
{"image_path": "data\\train\\00118.png", "code": "from flask import Flask\r\nfrom .home import code\r\n\r\n\r\ndef register_blueprints(app: Flask) -> bool:\r\n    \"\"\"Register the application blueprints.\r\n\r\n    Parameters\r\n    ----------\r\n    app: flask.Flask\r\n        A flask app instance\r\n\r\n    Returns\r\n    -------\r\n    bool:\r\n        Whether all the blueprints were registered.\r\n    \"\"\"\r\n    app.register_blueprint(code)\r\n    return True"}
{"image_path": "data\\train\\00119.png", "code": "from .register_blueprints import register_blueprints"}
{"image_path": "data\\train\\00120.png", "code": "from .view import code"}
{"image_path": "data\\train\\00121.png", "code": "from scrapy import Item, Field\r\nfrom itemloaders.processors import TakeFirst, MapCompose, Join\r\nimport re\r\n\r\n\r\ndef remove_html_tags(description: str) -> str:\r\n    html_pattern = \"<(?:\\\"[^\\\"]*\\\"['\\\"]*|'[^']*'['\\\"]*|[^'\\\">])+>\" \r\n    return re.sub(html_pattern, '', description)\r\n\r\ndef remove_unicode_chars(text: str) -> str:\r\n    return text.replace(u\"\\xa0\", \"\")\r\n\r\ndef num_of_slides(text: str) -> int:\r\n    vals = [val for val in list(text) if val.isdigit()]\r\n    return \"\".join(vals)\r\n\r\n\r\nclass SlidesModelItem(Item):\r\n    title = Field(output_processor=TakeFirst())\r\n    category = Field(output_processor=TakeFirst())\r\n    description = Field(\r\n        input_processor=MapCompose(remove_html_tags, remove_unicode_chars),\r\n        output_processor=Join()\r\n    )\r\n    tags = Field()\r\n    slides_count = Field(\r\n        input_processor=MapCompose(num_of_slides),\r\n        output_processor=TakeFirst()\r\n    )\r\n    colors = Field()\r\n    image_urls = Field()\r\n    images = Field()\r\n"}
{"image_path": "data\\train\\00122.png", "code": "from itemadapter import ItemAdapter\r\nfrom scrapy.pipelines.images import ImagesPipeline\r\nfrom scrapy.exceptions import DropItem\r\nfrom os import path, mkdir\r\nfrom scrapy.http import Response\r\nfrom scrapy import Request, Spider\r\nfrom scrapy import Item\r\nfrom pathlib import PurePosixPath\r\nfrom urllib.parse import urlparse\r\nfrom slidesmodel.models import db_connect, Tag, Category, Slide, create_table, create_engine\r\nfrom sqlalchemy.orm import sessionmaker\r\nimport uuid\r\nimport logging\r\n\r\n\r\nclass SlidesmodelPipeline:\r\n    def process_item(self, item: Item, spider: Spider):\r\n        return item\r\n    \r\nclass MyImagesPipeline(ImagesPipeline):\r\n    def file_path(self, request: Request, response: Response = None, info=None, *, item=None):\r\n        slide_name: str = request.meta['title']\r\n        return f\"{slide_name}/\" + PurePosixPath(urlparse(request.url).path).name\r\n    \r\n    def get_media_requests(self, item: Item, info):\r\n        for image_url in item[\"image_urls\"]:\r\n            yield Request(image_url, meta={\"title\": item[\"title\"]})\r\n            \r\n\r\nclass SaveSlidesPipeline(object):\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initializes database connection and sessionmaker\r\n        Creates tables\r\n        \"\"\"\r\n        engine = db_connect()\r\n        create_table(engine)\r\n        self.Session = sessionmaker(bind=engine)\r\n\r\n\r\n"}
{"image_path": "data\\train\\00123.png", "code": "from scrapy import Item, Field\r\nfrom itemloaders.processors import TakeFirst, MapCompose, Join\r\nimport re\r\n\r\n\r\ndef remove_html_tags(description: str) -> str:\r\n    html_pattern = \"<(?:\\\"[^\\\"]*\\\"['\\\"]*|'[^']*'['\\\"]*|[^'\\\">])+>\" \r\n    return re.sub(html_pattern, '', description)\r\n\r\ndef remove_unicode_chars(text: str) -> str:\r\n    return text.replace(u\"\\xa0\", \"\")\r\n\r\ndef num_of_slides(text: str) -> int:\r\n    vals = [val for val in list(text) if val.isdigit()]\r\n    return \"\".join(vals)\r\n\r\n\r\nclass SlidesModelItem(Item):\r\n    title = Field(output_processor=TakeFirst())\r\n    category = Field(output_processor=TakeFirst())\r\n    description = Field(\r\n        input_processor=MapCompose(remove_html_tags, remove_unicode_chars),\r\n        output_processor=Join()\r\n    )\r\n    tags = Field()\r\n    slides_count = Field(\r\n        input_processor=MapCompose(num_of_slides),\r\n        output_processor=TakeFirst()\r\n    )\r\n    colors = Field()\r\n    image_urls = Field()\r\n    images = Field()\r\n"}
{"image_path": "data\\train\\00124.png", "code": "from itemadapter import ItemAdapter\r\nfrom scrapy.pipelines.images import ImagesPipeline\r\nfrom scrapy.exceptions import DropItem\r\nfrom os import path, mkdir\r\nfrom scrapy.http import Response\r\nfrom scrapy import Request, Spider\r\nfrom scrapy import Item\r\nfrom pathlib import PurePosixPath\r\nfrom urllib.parse import urlparse\r\nfrom slidesmodel.models import db_connect, Tag, Category, Slide, create_table, create_engine\r\nfrom sqlalchemy.orm import sessionmaker\r\nimport uuid\r\nimport logging\r\n\r\n\r\nclass SlidesmodelPipeline:\r\n    def process_item(self, item: Item, spider: Spider):\r\n        return item\r\n    \r\nclass MyImagesPipeline(ImagesPipeline):\r\n    def file_path(self, request: Request, response: Response = None, info=None, *, item=None):\r\n        slide_name: str = request.meta['title']\r\n        return f\"{slide_name}/\" + PurePosixPath(urlparse(request.url).path).name\r\n    \r\n    def get_media_requests(self, item: Item, info):\r\n        for image_url in item[\"image_urls\"]:\r\n            yield Request(image_url, meta={\"title\": item[\"title\"]})\r\n            \r\n\r\nclass SaveSlidesPipeline(object):\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initializes database connection and sessionmaker\r\n        Creates tables\r\n        \"\"\"\r\n        engine = db_connect()\r\n        create_table(engine)\r\n        self.Session = sessionmaker(bind=engine)\r\n\r\n\r\n"}
{"image_path": "data\\train\\00125.png", "code": "from scrapy import Item, Field\r\nfrom itemloaders.processors import TakeFirst, MapCompose, Join\r\nimport re\r\n\r\n\r\ndef remove_html_tags(description: str) -> str:\r\n    html_pattern = \"<(?:\\\"[^\\\"]*\\\"['\\\"]*|'[^']*'['\\\"]*|[^'\\\">])+>\" \r\n    return re.sub(html_pattern, '', description)\r\n\r\ndef remove_unicode_chars(text: str) -> str:\r\n    return text.replace(u\"\\xa0\", \"\")\r\n\r\ndef num_of_slides(text: str) -> int:\r\n    vals = [val for val in list(text) if val.isdigit()]\r\n    return \"\".join(vals)\r\n\r\n\r\nclass SlidesModelItem(Item):\r\n    title = Field(output_processor=TakeFirst())\r\n    category = Field(output_processor=TakeFirst())\r\n    description = Field(\r\n        input_processor=MapCompose(remove_html_tags, remove_unicode_chars),\r\n        output_processor=Join()\r\n    )\r\n    tags = Field()\r\n    slides_count = Field(\r\n        input_processor=MapCompose(num_of_slides),\r\n        output_processor=TakeFirst()\r\n    )\r\n    colors = Field()\r\n    image_urls = Field()\r\n    images = Field()\r\n"}
{"image_path": "data\\train\\00126.png", "code": "from itemadapter import ItemAdapter\r\nfrom scrapy.pipelines.images import ImagesPipeline\r\nfrom scrapy.exceptions import DropItem\r\nfrom os import path, mkdir\r\nfrom scrapy.http import Response\r\nfrom scrapy import Request, Spider\r\nfrom scrapy import Item\r\nfrom pathlib import PurePosixPath\r\nfrom urllib.parse import urlparse\r\nfrom slidesmodel.models import db_connect, Tag, Category, Slide, create_table, create_engine\r\nfrom sqlalchemy.orm import sessionmaker\r\nimport uuid\r\nimport logging\r\n\r\n\r\nclass SlidesmodelPipeline:\r\n    def process_item(self, item: Item, spider: Spider):\r\n        return item\r\n    \r\nclass MyImagesPipeline(ImagesPipeline):\r\n    def file_path(self, request: Request, response: Response = None, info=None, *, item=None):\r\n        slide_name: str = request.meta['title']\r\n        return f\"{slide_name}/\" + PurePosixPath(urlparse(request.url).path).name\r\n    \r\n    def get_media_requests(self, item: Item, info):\r\n        for image_url in item[\"image_urls\"]:\r\n            yield Request(image_url, meta={\"title\": item[\"title\"]})\r\n            \r\n\r\nclass SaveSlidesPipeline(object):\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initializes database connection and sessionmaker\r\n        Creates tables\r\n        \"\"\"\r\n        engine = db_connect()\r\n        create_table(engine)\r\n        self.Session = sessionmaker(bind=engine)\r\n\r\n\r\n"}
{"image_path": "data\\train\\00127.png", "code": "# Define here the models for your spider middleware\r\n#\r\n# See documentation in:\r\n# https://docs.scrapy.org/en/latest/topics/spider-middleware.html\r\n\r\nfrom scrapy import signals\r\n\r\n# useful for handling different item types with a single interface\r\nfrom itemadapter import is_item, ItemAdapter\r\n\r\n\r\nclass SlidesmodelSpiderMiddleware:\r\n    # Not all methods need to be defined. If a method is not defined,\r\n    # scrapy acts as if the spider middleware does not modify the\r\n    # passed objects.\r\n\r\n    @classmethod\r\n    def from_crawler(cls, crawler):\r\n        # This method is used by Scrapy to create your spiders.\r\n        s = cls()\r\n        crawler.signals.connect(s.spider_opened, signal=signals.spider_opened)\r\n        return s\r\n\r\n    def process_spider_input(self, response, spider):\r\n        # Called for each response that goes through the spider\r\n        # middleware and into the spider.\r\n\r\n        # Should return None or raise an exception.\r\n        return None\r\n\r\n    def process_spider_output(self, response, result, spider):\r\n        # Called with the results returned from the Spider, after\r\n        # it has processed the response.\r\n\r\n        # Must return an iterable of Request, or item objects.\r\n        for i in result:\r\n            yield i\r\n\r\n    def process_spider_exception(self, response, exception, spider):\r\n        # Called when a spider or process_spider_input() method\r\n"}
{"image_path": "data\\train\\00128.png", "code": "\r\nfrom sqlalchemy import create_engine, Column, Table, ForeignKey, MetaData\r\nfrom sqlalchemy.orm import relationship\r\nfrom sqlalchemy.ext.declarative import declarative_base\r\nfrom sqlalchemy import (\r\n    Integer, String, Date, DateTime, Float, Boolean, Text)\r\nfrom scrapy.utils.project import get_project_settings\r\nfrom sqlalchemy_utils import ScalarListType\r\n\r\n\r\nBase = declarative_base()\r\n\r\ndef db_connect():\r\n    \"\"\"\r\n    Performs database connection using database settings from settings.py.\r\n    Returns sqlalchemy engine instance\r\n    \"\"\"\r\n    settings: dict = get_project_settings()\r\n    connection_string: str = settings.get(\"CONNECTION_STRING\")\r\n    return create_engine(connection_string)\r\n\r\ndef create_table(engine):\r\n    Base.metadata.create_all(engine)\r\n    \r\n    \r\nslide_tag = Table('slide_tag', Base.metadata,\r\n    Column('slide_id', Integer, ForeignKey('slide.id')),\r\n    Column('tag_id', Integer, ForeignKey('tag.id'))\r\n)\r\n\r\nclass Slide(Base):\r\n    __tablename__ = \"slide\"\r\n\r\n    id = Column(String(), primary_key=True)\r\n    title = Column('title', String())\r\n    description = Column('description', Text())\r\n    category_id = Column(String(), ForeignKey('category.id'))\r\n    tags = relationship('Tag', secondary='slide_tag',\r\n        lazy='dynamic', backref=\"slide\")  # M-to-M for quote and tag\r\n    colors = Column(ScalarListType())\r\n"}
{"image_path": "data\\train\\00129.png", "code": "# Scrapy settings for slidesmodel project\r\n#\r\n# For simplicity, this file contains only settings considered important or\r\n# commonly used. You can find more settings consulting the documentation:\r\n#\r\n#     https://docs.scrapy.org/en/latest/topics/settings.html\r\n#     https://docs.scrapy.org/en/latest/topics/downloader-middleware.html\r\n#     https://docs.scrapy.org/en/latest/topics/spider-middleware.html\r\n\r\nBOT_NAME = \"slidesmodel\"\r\n\r\nSPIDER_MODULES = [\"slidesmodel.spiders\"]\r\nNEWSPIDER_MODULE = \"slidesmodel.spiders\"\r\n\r\n\r\n# Crawl responsibly by identifying yourself (and your website) on the user-agent\r\n#USER_AGENT = \"slidesmodel (+http://www.yourdomain.com)\"\r\n\r\n# Obey robots.txt rules\r\nROBOTSTXT_OBEY = False\r\n\r\n# Configure maximum concurrent requests performed by Scrapy (default: 16)\r\n#CONCURRENT_REQUESTS = 32\r\n\r\n# Configure a delay for requests for the same website (default: 0)\r\n# See https://docs.scrapy.org/en/latest/topics/settings.html#download-delay\r\n# See also autothrottle settings and docs\r\n#DOWNLOAD_DELAY = 3\r\n# The download delay setting will honor only one of:\r\n#CONCURRENT_REQUESTS_PER_DOMAIN = 16\r\n#CONCURRENT_REQUESTS_PER_IP = 16\r\n\r\n# Disable cookies (enabled by default)\r\n#COOKIES_ENABLED = False\r\n\r\n# Disable Telnet Console (enabled by default)\r\n#TELNETCONSOLE_ENABLED = False\r\n\r\n# Override the default request headers:\r\n#DEFAULT_REQUEST_HEADERS = {\r\n"}
{"image_path": "data\\train\\00130.png", "code": "from typing import Any\r\nfrom scrapy import Spider\r\nfrom scrapy.http import Response\r\nfrom scrapy import Request\r\nfrom slidesmodel.items import SlidesModelItem\r\nfrom scrapy.loader import ItemLoader\r\nfrom scrapy.utils.project import get_project_settings\r\nimport json\r\n\r\n\r\nclass SlidesModelspider(Spider):\r\n    name: str = \"slides\"\r\n    \r\n    def __init__(self, name: str | None = None, **kwargs: Any):\r\n        super().__init__(name, **kwargs)\r\n        self.start_urls: list[str] = self.load_start_urls()\r\n        # self.start_urls: list[str] = [\r\n        #     \"https://slidemodel.com/templates/tag/process-flow/\"\r\n        # ]\r\n    \r\n    @staticmethod\r\n    def load_start_urls() -> list:\r\n        settings: dict = get_project_settings()\r\n        links_path: str = settings.get(\"START_URLS_PATH\")\r\n        with open(links_path, \"r\") as f:\r\n            start_urls_dict: list[dict] = json.load(f)\r\n        return [\r\n            link.get(\"url\") for link in start_urls_dict\r\n        ]\r\n    \r\n    def parse(self, response: Response, **kwargs: Any) -> Any:\r\n        self.logger.info(\"This is my first spider.\")\r\n        slides = response.xpath(\"//div[@class='col-lg-3 col-sm-6 mt-4']\")\r\n        for slide in slides:\r\n            loader: ItemLoader = ItemLoader(item=SlidesModelItem(), selector=slide)\r\n            loader.add_css(\"title\", \".item a::text\")\r\n            loader.add_css(\"category\", \".category::text\")\r\n            slide_item = loader.load_item()\r\n            link = slide.css(\".item a::attr(href)\").get()\r\n            self.logger.info(\"Parsing the slide\")\r\n"}
{"image_path": "data\\train\\00131.png", "code": "# This package will contain the spiders of your Scrapy project\r\n#\r\n# Please refer to the documentation for information on how to create and manage\r\n# your spiders.\r\n"}
{"image_path": "data\\train\\00132.png", "code": "from typing import Any\r\nfrom scrapy import Spider\r\nfrom scrapy.http import Response\r\nfrom scrapy.linkextractors import LinkExtractor \r\n\r\n\r\nclass SlidesLinkExtractor(Spider):\r\n    name: str = \"links-extractor\"\r\n    \r\n    start_urls: list[str] = [\r\n        \"https://slidemodel.com/templates/\"\r\n    ]\r\n    \r\n    def __init__(self, name=None, **kwargs): \r\n        super().__init__(name, **kwargs) \r\n  \r\n        self.link_extractor = LinkExtractor(unique=True) \r\n  \r\n    def parse(self, response: Response, **kwargs: Any) -> Any: \r\n        links = self.link_extractor.extract_links(response) \r\n  \r\n        for link in links: \r\n            if \"tag\" in link.url:\r\n                yield {\r\n                        \"url\": link.url, \r\n                        \"text\": link.text\r\n                    }"}
{"image_path": "data\\train\\00133.png", "code": "from selenium import webdriver\r\nfrom selenium.webdriver.common.keys import Keys\r\nfrom selenium.webdriver.common.by import By\r\nfrom selenium.webdriver.chrome.service import Service as ChromeService\r\nfrom webdriver_manager.chrome import ChromeDriverManager\r\nfrom selenium.webdriver.chrome.options import Options\r\ni\r\n\r\noptions = Options()\r\noptions.add_argument(\"--headless=new\")\r\ndriver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)\r\ndriver.get(\"https://leetcode.com/problems/remove-linked-list-elements\")\r\nparagraphs = driver.find_elements(By.TAG_NAME, \"p\")\r\nprint(paragraphs)\r\ndriver.quit()"}
{"image_path": "data\\train\\00134.png", "code": "from youtube import YouTube\r\nfrom youtube.models import Search\r\nfrom youtube.schemas import (\r\n        YouTubeRequest, YouTubeListResponse, YouTubeResponse,\r\n        SearchFilter, SearchOptionalParameters, SearchPart\r\n)\r\nfrom typing import Iterator\r\n\r\n\r\nclient_secrets_file = \"/home/lyle/oryks/backend/api/libraries/youtube.json\"\r\ndef get_youtube_client(client_secrets_file: str = client_secrets_file) -> YouTube:\r\n    youtube: YouTube = YouTube(client_secret_file=client_secrets_file)\r\n    client = youtube.authenticate()\r\n    youtube.youtube_client = client\r\n    return youtube\r\n\r\nyoutube: YouTube = get_youtube_client(client_secrets_file=\"/home/lyle/Downloads/test.json\")\r\n\r\n\r\n# query: str = ''\r\n# part: SearchPart = SearchPart()\r\n# optional_parameters: SearchOptionalParameters = SearchOptionalParameters(\r\n#     q=query,\r\n#     type=['video'],\r\n#     channelId=\"UCtAcpQcYerN8xxZJYTfWBMw\"\r\n# )\r\n# search_request: YouTubeRequest = YouTubeRequest(\r\n#     part=part, \r\n#     optional_parameters=optional_parameters\r\n# )\r\n# search_results: YouTubeResponse = youtube.search(search_request)\r\n# search_iterator: Iterator = youtube.get_search_iterator(search_request)\r\n# # res: YouTubeResponse = youtube.find_channel_by_name(display_name=\"Umar Jamil\")\r\n# # print(res.items[0])\r\n# res = next(search_iterator)\r\n# final = []\r\n# for x in search_iterator:\r\n#         for search in x:\r\n#                 final.append(\r\n#                         dict(\r\n"}
{"image_path": "data\\train\\00135.png", "code": "from langchain_community.document_loaders.generic import GenericLoader\r\nfrom langchain_community.document_loaders.parsers import OpenAIWhisperParser\r\nfrom langchain_community.document_loaders.blob_loaders.youtube_audio import (\r\n    YoutubeAudioLoader,\r\n)\r\nfrom langchain_core.documents import Document\r\nfrom os import path\r\n\r\n# Two Karpathy lecture videos\r\nurls = [\"https://www.youtube.com/watch?v=altvPR7x9IA\"]\r\n\r\n# Directory to save audio files\r\ndata_dir = \"data\"\r\nvideo_data_dir = \"video\"\r\ntranscribed_data = \"transcriptions\"\r\nvideo_title = \"sample\"\r\nsave_video_dir = path.join(data_dir, video_data_dir, video_title)\r\nsave_transcript_dir = path.join(data_dir, transcribed_data, video_title + \".txt\")\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\n\r\nloader = GenericLoader(\r\n    YoutubeAudioLoader(urls, save_video_dir), OpenAIWhisperParser(api_key=api_key)\r\n)\r\ndocs = loader.load()\r\n\r\nfull_transcript = \"\"\r\nfor doc in docs:\r\n    full_transcript += doc.page_content\r\n\r\nwith open(save_transcript_dir, \"w\", encoding=\"utf-8\") as f:\r\n    f.write(full_transcript)\r\n\r\nprint(full_transcript)\r\n\r\n\r\ndef transcribe_video(video_id: str, save_video_dir: str, api_key: str) -> str:\r\n    url: str = f\"https://www.youtube.com/watch?v={video_id}\"\r\n    loader: GenericLoader = GenericLoader(\r\n        YoutubeAudioLoader([url], save_video_dir), OpenAIWhisperParser(api_key=api_key)\r\n"}
{"image_path": "data\\train\\00136.png", "code": "from dotenv import load_dotenv\r\nload_dotenv()\r\nfrom flask.cli import FlaskGroup\r\nfrom api import create_app\r\n\r\napp = create_app()\r\ncli = FlaskGroup(create_app=create_app)\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    cli()"}
{"image_path": "data\\train\\00137.png", "code": "from dotenv import load_dotenv\r\nload_dotenv()\r\nfrom flask.cli import FlaskGroup\r\nfrom api import create_app\r\n\r\napp = create_app()\r\ncli = FlaskGroup(create_app=create_app)\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    cli()"}
{"image_path": "data\\train\\00138.png", "code": "import whisper\r\n\r\nmodel = whisper.load_model(\"medium.en\")\r\nresult = model.transcribe(\"code.wav\")\r\nprint(result[\"text\"])"}
{"image_path": "data\\train\\00139.png", "code": "from zipfile import ZipFile\r\nfrom os import path, mkdir\r\nimport os\r\n\r\n\r\ndef download_data():\r\n    pass\r\n\r\n\r\ndef extract_archive(archive_path: str, archive_name: str, extract_path: str = None) -> None:\r\n    if not extract_path:\r\n        extract_path: str = \"raw-data\"\r\n        if not path.exists(extract_path):\r\n            mkdir(extract_path)\r\n    archive_path: str = path.join(archive_path, archive_name)\r\n    with ZipFile(file=archive_path, mode=\"r\") as z_object:\r\n        z_object.extractall(path=extract_path)\r\n        \r\n "}
{"image_path": "data\\train\\00140.png", "code": "from data_utils import extract_archive\r\nfrom dotenv import load_dotenv\r\nimport os\r\n\r\n\r\nload_dotenv()\r\n\r\nDOWNLOAD_PATH: str = os.environ[\"DOWNLOAD_PATH\"]\r\nEXTRACT_PATH: str = os.environ[\"EXTRACT_PATH\"]\r\nARCHIVE_NAME: str = \"archive (2).zip\"\r\n\r\nextract_archive(\r\n    archive_path=DOWNLOAD_PATH, \r\n    archive_name=ARCHIVE_NAME, \r\n    extract_path=EXTRACT_PATH\r\n)\r\n\r\n"}
{"image_path": "data\\train\\00141.png", "code": "import torch\r\nimport torchvision.transforms as transforms\r\nfrom PIL import Image\r\n\r\n\r\ndef print_examples(model, device, dataset):\r\n    transform = transforms.Compose(\r\n        [\r\n            transforms.Resize((299, 299)),\r\n            transforms.ToTensor(),\r\n            transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)),\r\n        ]\r\n    )\r\n\r\n    model.eval()\r\n    test_img1 = transform(Image.open(\"test_examples/dog.jpg\").convert(\"RGB\")).unsqueeze(\r\n        0\r\n    )\r\n    print(\"Example 1 CORRECT: Dog on a beach by the ocean\")\r\n    print(\r\n        \"Example 1 OUTPUT: \"\r\n        + \" \".join(model.caption_image(test_img1.to(device), dataset.vocabulary))\r\n    )\r\n    test_img2 = transform(\r\n        Image.open(\"test_examples/child.jpg\").convert(\"RGB\")\r\n    ).unsqueeze(0)\r\n    print(\"Example 2 CORRECT: Child holding red frisbee outdoors\")\r\n    print(\r\n        \"Example 2 OUTPUT: \"\r\n        + \" \".join(model.caption_image(test_img2.to(device), dataset.vocabulary))\r\n    )\r\n    test_img3 = transform(Image.open(\"test_examples/bus.png\").convert(\"RGB\")).unsqueeze(\r\n        0\r\n    )\r\n    print(\"Example 3 CORRECT: Bus driving by parked cars\")\r\n    print(\r\n        \"Example 3 OUTPUT: \"\r\n        + \" \".join(model.caption_image(test_img3.to(device), dataset.vocabulary))\r\n    )\r\n    test_img4 = transform(\r\n"}
{"image_path": "data\\train\\00142.png", "code": "import torch\r\nfrom tqdm import tqdm\r\nfrom torch.nn import CrossEntropyLoss\r\nfrom torch import optim\r\nfrom torchvision.transforms import Compose, Resize, RandomCrop, ToTensor, Normalize\r\nfrom torch.utils.tensorboard import SummaryWriter\r\nfrom utils import save_checkpoint, load_checkpoint, print_examples\r\nfrom create_dataset import get_loader\r\nfrom model import CNNToRNN\r\n\r\n\r\ndef train():\r\n    transforms = Compose(\r\n        [\r\n            Resize((356, 356)),\r\n            RandomCrop((299, 299)),\r\n            ToTensor(),\r\n            Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)),\r\n        ]\r\n    )\r\n\r\n    train_loader, dataset = get_loader(\r\n        images_dir=\"raw-data/Images\",\r\n        captions_file=\"raw-data/captions.txt\",\r\n        transforms=transforms,\r\n        num_workers=2,\r\n    )\r\n\r\n    torch.backends.cudnn.benchmark = True\r\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\r\n    load_model = False\r\n    save_model = False\r\n    train_CNN = False\r\n\r\n    # Hyperparameters\r\n    embed_size = 256\r\n    hidden_size = 256\r\n    vocab_size = len(dataset.vocabulary)\r\n    num_layers = 1\r\n    learning_rate = 3e-4\r\n"}
{"image_path": "data\\train\\00143.png", "code": "from selenium import webdriver\r\nfrom selenium.webdriver.common.keys import Keys\r\nfrom selenium.webdriver.common.by import By\r\nfrom selenium.webdriver.chrome.service import Service as ChromeService\r\nfrom webdriver_manager.chrome import ChromeDriverManager\r\nfrom selenium.webdriver.chrome.options import Options\r\ni\r\n\r\noptions = Options()\r\noptions.add_argument(\"--headless=new\")\r\ndriver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)\r\ndriver.get(\"https://leetcode.com/problems/remove-linked-list-elements\")\r\nparagraphs = driver.find_elements(By.TAG_NAME, \"p\")\r\nprint(paragraphs)\r\ndriver.quit()"}
{"image_path": "data\\train\\00144.png", "code": "from youtube import YouTube\r\nfrom youtube.models import Search\r\nfrom youtube.schemas import (\r\n        YouTubeRequest, YouTubeListResponse, YouTubeResponse,\r\n        SearchFilter, SearchOptionalParameters, SearchPart\r\n)\r\nfrom typing import Iterator\r\n\r\n\r\nclient_secrets_file = \"/home/lyle/oryks/backend/api/libraries/youtube.json\"\r\ndef get_youtube_client(client_secrets_file: str = client_secrets_file) -> YouTube:\r\n    youtube: YouTube = YouTube(client_secret_file=client_secrets_file)\r\n    client = youtube.authenticate()\r\n    youtube.youtube_client = client\r\n    return youtube\r\n\r\nyoutube: YouTube = get_youtube_client(client_secrets_file=\"/home/lyle/Downloads/test.json\")\r\n\r\n\r\n# query: str = ''\r\n# part: SearchPart = SearchPart()\r\n# optional_parameters: SearchOptionalParameters = SearchOptionalParameters(\r\n#     q=query,\r\n#     type=['video'],\r\n#     channelId=\"UCtAcpQcYerN8xxZJYTfWBMw\"\r\n# )\r\n# search_request: YouTubeRequest = YouTubeRequest(\r\n#     part=part, \r\n#     optional_parameters=optional_parameters\r\n# )\r\n# search_results: YouTubeResponse = youtube.search(search_request)\r\n# search_iterator: Iterator = youtube.get_search_iterator(search_request)\r\n# # res: YouTubeResponse = youtube.find_channel_by_name(display_name=\"Umar Jamil\")\r\n# # print(res.items[0])\r\n# res = next(search_iterator)\r\n# final = []\r\n# for x in search_iterator:\r\n#         for search in x:\r\n#                 final.append(\r\n#                         dict(\r\n"}
{"image_path": "data\\train\\00145.png", "code": "#                                 id=search.resource_id,\r\n#                                 title=search.title\r\n#                         )\r\n#                 )\r\n# print(final)       "}
{"image_path": "data\\train\\00146.png", "code": "from langchain_community.document_loaders.generic import GenericLoader\r\nfrom langchain_community.document_loaders.parsers import OpenAIWhisperParser\r\nfrom langchain_community.document_loaders.blob_loaders.youtube_audio import (\r\n    YoutubeAudioLoader,\r\n)\r\nfrom langchain_core.documents import Document\r\nfrom os import path\r\n\r\n# Two Karpathy lecture videos\r\nurls = [\"https://www.youtube.com/watch?v=altvPR7x9IA\"]\r\n\r\n# Directory to save audio files\r\ndata_dir = \"data\"\r\nvideo_data_dir = \"video\"\r\ntranscribed_data = \"transcriptions\"\r\nvideo_title = \"sample\"\r\nsave_video_dir = path.join(data_dir, video_data_dir, video_title)\r\nsave_transcript_dir = path.join(data_dir, transcribed_data, video_title + \".txt\")\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\n\r\nloader = GenericLoader(\r\n    YoutubeAudioLoader(urls, save_video_dir), OpenAIWhisperParser(api_key=api_key)\r\n)\r\ndocs = loader.load()\r\n\r\nfull_transcript = \"\"\r\nfor doc in docs:\r\n    full_transcript += doc.page_content\r\n\r\nwith open(save_transcript_dir, \"w\", encoding=\"utf-8\") as f:\r\n    f.write(full_transcript)\r\n\r\nprint(full_transcript)\r\n\r\n\r\ndef transcribe_video(video_id: str, save_video_dir: str, api_key: str) -> str:\r\n    url: str = f\"https://www.youtube.com/watch?v={video_id}\"\r\n    loader: GenericLoader = GenericLoader(\r\n        YoutubeAudioLoader([url], save_video_dir), OpenAIWhisperParser(api_key=api_key)\r\n"}
{"image_path": "data\\train\\00147.png", "code": "    )\r\n    documents: list[Document] = loader.load()\r\n    full_transcript: str = \"\"\r\n    for document in documents:\r\n        full_transcript += document.page_content\r\n    return full_transcript\r\n\r\ndef analayze_video(video_transcript: str):\r\n    \"\"\"Break a video into the slide components.\r\n    \r\n    The video is to be broken down into:\r\n    1. The Cover - summary details about this video\r\n    2. Index - a shortcut to other slides\r\n    3. The slides\r\n    \r\n    The cover\r\n    ---------\r\n    Contains the video name and channel presenting the video\r\n    \r\n    Index\r\n    -----\r\n    Contains links to the other slides and their titles\r\n    \r\n    The slides\r\n    -----------\r\n    Consist of the slide title and a bullet of points\r\n    \"\"\"\r\n    pass\r\n"}
{"image_path": "data\\train\\00148.png", "code": "from dotenv import load_dotenv\r\nload_dotenv()\r\nfrom flask.cli import FlaskGroup\r\nfrom api import create_app\r\n\r\napp = create_app()\r\ncli = FlaskGroup(create_app=create_app)\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    cli()"}
{"image_path": "data\\train\\00149.png", "code": "from dotenv import load_dotenv\r\nload_dotenv()\r\nfrom flask.cli import FlaskGroup\r\nfrom api import create_app\r\n\r\napp = create_app()\r\ncli = FlaskGroup(create_app=create_app)\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    cli()"}
{"image_path": "data\\train\\00150.png", "code": "import whisper\r\n\r\nmodel = whisper.load_model(\"medium.en\")\r\nresult = model.transcribe(\"code.wav\")\r\nprint(result[\"text\"])"}
{"image_path": "data\\train\\00151.png", "code": "from zipfile import ZipFile\r\nfrom os import path, mkdir\r\nimport os\r\n\r\n\r\ndef download_data():\r\n    pass\r\n\r\n\r\ndef extract_archive(archive_path: str, archive_name: str, extract_path: str = None) -> None:\r\n    if not extract_path:\r\n        extract_path: str = \"raw-data\"\r\n        if not path.exists(extract_path):\r\n            mkdir(extract_path)\r\n    archive_path: str = path.join(archive_path, archive_name)\r\n    with ZipFile(file=archive_path, mode=\"r\") as z_object:\r\n        z_object.extractall(path=extract_path)\r\n        \r\n "}
{"image_path": "data\\train\\00152.png", "code": "from data_utils import extract_archive\r\nfrom dotenv import load_dotenv\r\nimport os\r\n\r\n\r\nload_dotenv()\r\n\r\nDOWNLOAD_PATH: str = os.environ[\"DOWNLOAD_PATH\"]\r\nEXTRACT_PATH: str = os.environ[\"EXTRACT_PATH\"]\r\nARCHIVE_NAME: str = \"archive (2).zip\"\r\n\r\nextract_archive(\r\n    archive_path=DOWNLOAD_PATH, \r\n    archive_name=ARCHIVE_NAME, \r\n    extract_path=EXTRACT_PATH\r\n)\r\n\r\n"}
{"image_path": "data\\train\\00153.png", "code": "import torch\r\nimport torchvision.transforms as transforms\r\nfrom PIL import Image\r\n\r\n\r\ndef print_examples(model, device, dataset):\r\n    transform = transforms.Compose(\r\n        [\r\n            transforms.Resize((299, 299)),\r\n            transforms.ToTensor(),\r\n            transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)),\r\n        ]\r\n    )\r\n\r\n    model.eval()\r\n    test_img1 = transform(Image.open(\"test_examples/dog.jpg\").convert(\"RGB\")).unsqueeze(\r\n        0\r\n    )\r\n    print(\"Example 1 CORRECT: Dog on a beach by the ocean\")\r\n    print(\r\n        \"Example 1 OUTPUT: \"\r\n        + \" \".join(model.caption_image(test_img1.to(device), dataset.vocabulary))\r\n    )\r\n    test_img2 = transform(\r\n        Image.open(\"test_examples/child.jpg\").convert(\"RGB\")\r\n    ).unsqueeze(0)\r\n    print(\"Example 2 CORRECT: Child holding red frisbee outdoors\")\r\n    print(\r\n        \"Example 2 OUTPUT: \"\r\n        + \" \".join(model.caption_image(test_img2.to(device), dataset.vocabulary))\r\n    )\r\n    test_img3 = transform(Image.open(\"test_examples/bus.png\").convert(\"RGB\")).unsqueeze(\r\n        0\r\n    )\r\n    print(\"Example 3 CORRECT: Bus driving by parked cars\")\r\n    print(\r\n        \"Example 3 OUTPUT: \"\r\n        + \" \".join(model.caption_image(test_img3.to(device), dataset.vocabulary))\r\n    )\r\n    test_img4 = transform(\r\n"}
{"image_path": "data\\train\\00154.png", "code": "        Image.open(\"test_examples/boat.png\").convert(\"RGB\")\r\n    ).unsqueeze(0)\r\n    print(\"Example 4 CORRECT: A small boat in the ocean\")\r\n    print(\r\n        \"Example 4 OUTPUT: \"\r\n        + \" \".join(model.caption_image(test_img4.to(device), dataset.vocabulary))\r\n    )\r\n    test_img5 = transform(\r\n        Image.open(\"test_examples/horse.png\").convert(\"RGB\")\r\n    ).unsqueeze(0)\r\n    print(\"Example 5 CORRECT: A cowboy riding a horse in the desert\")\r\n    print(\r\n        \"Example 5 OUTPUT: \"\r\n        + \" \".join(model.caption_image(test_img5.to(device), dataset.vocabulary))\r\n    )\r\n    model.train()\r\n\r\n\r\ndef save_checkpoint(state, filename=\"my_checkpoint.pth.tar\"):\r\n    print(\"=> Saving checkpoint\")\r\n    torch.save(state, filename)\r\n\r\n\r\ndef load_checkpoint(checkpoint, model, optimizer):\r\n    print(\"=> Loading checkpoint\")\r\n    model.load_state_dict(checkpoint[\"state_dict\"])\r\n    optimizer.load_state_dict(checkpoint[\"optimizer\"])\r\n    step = checkpoint[\"step\"]\r\n    return step"}
{"image_path": "data\\train\\00155.png", "code": "import torch\r\nfrom tqdm import tqdm\r\nfrom torch.nn import CrossEntropyLoss\r\nfrom torch import optim\r\nfrom torchvision.transforms import Compose, Resize, RandomCrop, ToTensor, Normalize\r\nfrom torch.utils.tensorboard import SummaryWriter\r\nfrom utils import save_checkpoint, load_checkpoint, print_examples\r\nfrom create_dataset import get_loader\r\nfrom model import CNNToRNN\r\n\r\n\r\ndef train():\r\n    transforms = Compose(\r\n        [\r\n            Resize((356, 356)),\r\n            RandomCrop((299, 299)),\r\n            ToTensor(),\r\n            Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)),\r\n        ]\r\n    )\r\n\r\n    train_loader, dataset = get_loader(\r\n        images_dir=\"raw-data/Images\",\r\n        captions_file=\"raw-data/captions.txt\",\r\n        transforms=transforms,\r\n        num_workers=2,\r\n    )\r\n\r\n    torch.backends.cudnn.benchmark = True\r\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\r\n    load_model = False\r\n    save_model = False\r\n    train_CNN = False\r\n\r\n    # Hyperparameters\r\n    embed_size = 256\r\n    hidden_size = 256\r\n    vocab_size = len(dataset.vocabulary)\r\n    num_layers = 1\r\n    learning_rate = 3e-4\r\n"}
{"image_path": "data\\train\\00156.png", "code": "    num_epochs = 100\r\n\r\n    # for tensorboard\r\n    writer = SummaryWriter(\"runs/flickr\")\r\n    step = 0\r\n\r\n    # initialize model, loss etc\r\n    model = CNNToRNN(embed_size, hidden_size, vocab_size, num_layers).to(device)\r\n    criterion = CrossEntropyLoss(ignore_index=dataset.vocabulary.stoi[\"<PAD>\"])\r\n    optimizer = optim.Adam(model.parameters(), lr=learning_rate)\r\n\r\n    # Only finetune the CNN\r\n    for name, param in model.encoder_cnn.inception.named_parameters():\r\n        if \"fc.weight\" in name or \"fc.bias\" in name:\r\n            param.requires_grad = True\r\n        else:\r\n            param.requires_grad = False\r\n\r\n    if load_model:\r\n        step = load_checkpoint(torch.load(\"my_checkpoint.pth.tar\"), model, optimizer)\r\n\r\n    model.train()\r\n\r\n    for epoch in range(num_epochs):\r\n        # Uncomment the line below to see a couple of test cases\r\n        print_examples(model, device, dataset)\r\n\r\n        if save_model:\r\n            checkpoint = {\r\n                \"state_dict\": model.state_dict(),\r\n                \"optimizer\": optimizer.state_dict(),\r\n                \"step\": step,\r\n            }\r\n            save_checkpoint(checkpoint)\r\n\r\n        for idx, (imgs, captions) in tqdm(\r\n            enumerate(train_loader), total=len(train_loader), leave=False\r\n        ):\r\n            imgs = imgs.to(device)\r\n            captions = captions.to(device)\r\n"}
{"image_path": "data\\train\\00157.png", "code": "\r\n            outputs = model(imgs, captions[:-1])\r\n            loss = criterion(\r\n                outputs.reshape(-1, outputs.shape[2]), captions.reshape(-1)\r\n            )\r\n\r\n            writer.add_scalar(\"Training loss\", loss.item(), global_step=step)\r\n            step += 1\r\n\r\n            optimizer.zero_grad()\r\n            loss.backward(loss)\r\n            optimizer.step()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    train()"}
{"image_path": "data\\train\\00158.png", "code": "from create_dataset import dataloader, FlickrDataset, Dataset\r\nfrom torchvision.transforms import Compose, ToTensor, Resize\r\nfrom model import EncoderCNN, DecoderRNN, CNNToRNN\r\nfrom torch.nn import Module\r\nimport torch\r\nfrom PIL import Image\r\n\r\nembed_size: int = 256\r\nhidden_size: int = 256\r\nnum_layers: int = 3\r\nvocab_size: int = 2994\r\n\r\nencoder: Module = EncoderCNN(embed_size=embed_size)\r\ndecoder: Module = DecoderRNN(embed_size=embed_size, hidden_size=hidden_size, vocab_size=vocab_size, \r\n                             num_layers=num_layers)\r\nmodel: Module = CNNToRNN(embed_size=embed_size, hidden_size=hidden_size, vocab_size=vocab_size, \r\n                         num_layers=num_layers)\r\n\r\n\r\nfor i, (images, captions) in enumerate(dataloader):\r\n    print(images.shape)\r\n    print(captions.shape)\r\n    break\r\n# print(captions)\r\n\r\ndataset: Dataset = FlickrDataset(\r\n    images_dir=\"raw-data/Images\", \r\n    captions_file=\"raw-data/captions.txt\", \r\n    transforms=Compose([\r\n        Resize((299, 299)),\r\n        ToTensor()\r\n    ]))\r\n    \r\n# features = encoder(images)\r\n# print(features.shape)\r\n# print(features.unsqueeze(0).shape)\r\n# embedings = decoder.embed(captions)\r\n# print(embedings.size())\r\n# x = torch.cat((features.unsqueeze(0), embedings), dim=0)\r\n# print(x.shape)\r\n"}
{"image_path": "data\\train\\00159.png", "code": "# hiddens, _ = decoder.lstm(x)\r\n# print(hiddens.shape)\r\n# output = decoder.linear(hiddens)\r\n# print(output.shape)\r\n# outputs = model(images, captions)\r\n# print(outputs.shape)\r\n\r\n# transforms=Compose([\r\n#     Resize((299, 299)),\r\n#     ToTensor()\r\n# ])\r\n# img_path = \"/home/lyle/oryks/finetune-image-captioning-model/raw-data/Images/667626_18933d713e.jpg\"\r\n# img = Image.open(img_path)\r\n# trans = transforms(img)\r\n# print(trans.unsqueeze(0).shape)\r\n# res = model.caption_image(image=trans.unsqueeze(0), vocabulary=dataset.vocabulary)\r\n"}
{"image_path": "data\\train\\00160.png", "code": "import os\r\nimport pandas as pd\r\nfrom spacy.lang.en import English\r\nimport torch\r\nfrom torch.nn.utils.rnn import pad_sequence\r\nfrom torch.utils.data import Dataset, DataLoader\r\nfrom PIL import Image\r\nfrom collections import defaultdict\r\nfrom torchvision.transforms import Compose, ToTensor, Resize\r\n\r\n\r\nnlp = English()\r\n# Create a Tokenizer with the default settings for English\r\n# including punctuation rules and exceptions\r\ntokenizer = nlp.tokenizer\r\n\r\ntransforms = Compose([\r\n    ToTensor()\r\n])\r\n\r\nclass Vocabulary:\r\n    def __init__(self, freq_threshold: int) -> None:\r\n        self.freq_threshold: int = freq_threshold\r\n        self.itos: dict[int, str] = {\r\n            0: \"<PAD>\",\r\n            1: \"<SOS>\",\r\n            2: \"<EOS>\",\r\n            3: \"<UNK>\"\r\n        }\r\n        self.stoi: dict[str, int] = self.invert_dict(self.itos)\r\n        \r\n    def __len__(self) -> int:\r\n        return len(self.itos)\r\n    \r\n    @staticmethod\r\n    def tokenize(text: str) -> list[str]:\r\n        return [token.text.lower() for token in tokenizer(text)]\r\n        \r\n    @staticmethod\r\n    def invert_dict(dct: dict) -> dict:\r\n"}
{"image_path": "data\\train\\00161.png", "code": "        inverted_dict: dict = {value: key for key, value in dct.items()}\r\n        return inverted_dict\r\n    \r\n    def build_vocab(self, sentence_list: list[list[str]]) -> None:\r\n        idx: int = max(self.itos.keys())\r\n        word_frequencies: dict[str, int] = defaultdict(int)\r\n\r\n        for sentence in sentence_list:\r\n            for word in self.tokenize(sentence):\r\n                word_frequencies[word] += 1\r\n                if word not in self.stoi and word_frequencies[word] == self.freq_threshold:\r\n                    idx += 1\r\n                    self.stoi[word] = idx\r\n                    self.itos[idx] = word\r\n    \r\n    def numericalize(self, text: str) -> list[int]:\r\n        tokenized_txt: list[str] = self.tokenize(text)\r\n        \r\n        return [\r\n            self.stoi[token] if token in self.stoi else self.stoi[\"<UNK>\"]\r\n            for token in tokenized_txt\r\n        ]\r\n        \r\n    def textualize(self, vector: list[int]) -> list[str]:\r\n        return [\r\n            self.itos[i.item()] if i.item() in self.itos else self.itos[3]\r\n            for i in vector\r\n        ]\r\n    \r\n\r\n\r\nclass FlickrDataset(Dataset):\r\n    def __init__(self, images_dir: str, captions_file: str, freq_threshold: int = 5, transforms = None) -> None:\r\n        super().__init__()\r\n        self.images_dir: str = images_dir\r\n        self.df: pd.DataFrame = pd.read_csv(captions_file)\r\n        self.transforms = transforms\r\n        \r\n        # Get the image, captions\r\n        self.images: pd.Series = self.df[\"image\"]\r\n"}
{"image_path": "data\\train\\00162.png", "code": "        self.captions: pd.Series = self.df[\"caption\"]\r\n        \r\n        # Build vocabulary\r\n        self.vocabulary: Vocabulary = Vocabulary(freq_threshold=freq_threshold)\r\n        self.vocabulary.build_vocab(self.captions.tolist())\r\n        \r\n    def __len__(self) -> int:\r\n        return len(self.df)\r\n    \r\n    def __getitem__(self, index: int) -> tuple[torch.Tensor, torch.Tensor]:\r\n        caption: str = self.captions[index]\r\n        img_id: str = self.images[index]\r\n        \r\n        image: Image = Image.open(os.path.join(self.images_dir, img_id)).convert(\"RGB\")\r\n        if self.transforms:\r\n            image = self.transforms(image)\r\n            \r\n        numericalized_caption: list[int] = [self.vocabulary.stoi[\"<SOS>\"]]\r\n        numericalized_caption += self.vocabulary.numericalize(caption)\r\n        numericalized_caption.append(self.vocabulary.stoi[\"<EOS>\"])\r\n        \r\n        return image, torch.tensor(numericalized_caption)\r\n            \r\n\r\nclass MyCollate:\r\n    def __init__(self, pad_idx: int) -> None:\r\n        self.pad_idx: int = pad_idx\r\n        \r\n    def __call__(self, batch: tuple[torch.Tensor, torch.Tensor]) -> tuple[torch.Tensor, torch.Tensor]:\r\n        imgs = [item[0].unsqueeze(dim=0) for item in batch]\r\n        imgs = torch.cat(tensors=imgs, dim=0)\r\n        targets = [item[1] for item in batch]\r\n        targets = pad_sequence(sequences=targets, batch_first=False, padding_value=self.pad_idx)\r\n        \r\n        return imgs, targets\r\n    \r\n    \r\ndef get_loader(\r\n    images_dir: str,\r\n    captions_file: str,\r\n"}
{"image_path": "data\\train\\00163.png", "code": "    transforms,\r\n    batch_size: int = 8,\r\n    num_workers: int = 2,\r\n    shuffle: bool = True,\r\n    pin_memory: bool = True,\r\n    ) -> DataLoader:\r\n    dataset: Dataset = FlickrDataset(images_dir=images_dir, captions_file=captions_file, transforms=transforms)\r\n    pad_idx: int = dataset.vocabulary.stoi[\"<PAD>\"]\r\n    loader: DataLoader = DataLoader(\r\n        dataset=dataset, \r\n        batch_size=batch_size, \r\n        shuffle=shuffle, \r\n        num_workers=num_workers, \r\n        pin_memory=pin_memory, \r\n        collate_fn=MyCollate(pad_idx=pad_idx)\r\n    )\r\n    return loader, dataset\r\n\r\n\r\ndataloader: DataLoader = get_loader(\r\n    images_dir=\"raw-data/Images\",\r\n    captions_file=\"raw-data/captions.txt\",\r\n    transforms=Compose([\r\n        Resize((299, 299)),\r\n        ToTensor()\r\n    ])\r\n)\r\n\r\n# for i, (images, captions) in enumerate(dataloader):\r\n#     print(images.shape)\r\n#     print(captions.shape)\r\n#     break\r\n# print(captions[0])\r\n# dataset: Dataset = FlickrDataset(\r\n#     images_dir=\"raw-data/Images\", \r\n#     captions_file=\"raw-data/captions.txt\", \r\n#     transforms=Compose([\r\n#         Resize((224, 224)),\r\n#         ToTensor()\r\n#     ]))\r\n"}
{"image_path": "data\\train\\00164.png", "code": "# for caption in captions[:5]:\r\n#     res = dataset.vocabulary.textualize(caption)\r\n#     print(res)"}
{"image_path": "data\\train\\00165.png", "code": "from torch.nn import Module, Linear, ReLU, Embedding, LSTM, Dropout\r\nfrom torchvision.models import inception_v3, Inception_V3_Weights\r\nfrom torch import Tensor\r\nimport torch\r\n\r\n\r\nclass EncoderCNN(Module):\r\n    def __init__(self, embed_size: int, train_cnn: bool = False, dropout: float = 0.5) -> None:\r\n        super().__init__()\r\n        self.train_cnn: bool = train_cnn\r\n        self.inception = inception_v3(weights=Inception_V3_Weights.DEFAULT, aux_logits=True)\r\n        self.inception.fc = Linear(in_features=self.inception.fc.in_features, out_features=embed_size)\r\n        self.relu = ReLU()\r\n        self.dropout = Dropout(p=dropout)\r\n        \r\n    def forward(self, images: Tensor) -> Tensor:\r\n        features = self.inception(images)\r\n        for name, param in self.inception.named_parameters():\r\n            if \"fc.name\" in name or \"fc.bias\" in name:\r\n                param.requires_grad = True\r\n            else:\r\n                param.requires_grad = self.train_cnn\r\n                \r\n        return self.dropout(self.relu(features.logits))\r\n                \r\n\r\nclass DecoderRNN(Module):\r\n    def __init__(self, embed_size: int, hidden_size: int, vocab_size: int, num_layers: int, dropout: float = 0.5) -> None:\r\n        super().__init__()\r\n        self.embed = Embedding(num_embeddings=vocab_size, embedding_dim=embed_size)\r\n        self.lstm = LSTM(input_size=embed_size, hidden_size=hidden_size, num_layers=num_layers)\r\n        self.linear = Linear(in_features=embed_size, out_features=vocab_size)\r\n        self.dropout = Dropout(p=dropout)\r\n        \r\n    def forward(self, features, captions):\r\n        embeddings = self.dropout(self.embed(captions))\r\n        embeddings = torch.cat((features.unsqueeze(0), embeddings), dim=0)\r\n        hiddens, _ = self.lstm(embeddings)\r\n        outputs = self.linear(hiddens)\r\n        return outputs\r\n"}
{"image_path": "data\\train\\00166.png", "code": "    \r\nclass CNNToRNN(Module):\r\n    def __init__(self, embed_size, hidden_size, vocab_size, num_layers) -> None:\r\n        super().__init__()\r\n        self.encoder_cnn = EncoderCNN(embed_size=embed_size)\r\n        self.decoder_rnn = DecoderRNN(embed_size=embed_size, hidden_size=hidden_size, vocab_size=vocab_size, num_layers=num_layers)\r\n        \r\n    def forward(self, images, captions):\r\n        features = self.encoder_cnn(images)\r\n        outputs = self.decoder_rnn(features, captions)\r\n        return outputs\r\n    \r\n    def caption_image(self, image, vocabulary, max_length=50):\r\n        result_caption = []\r\n\r\n        with torch.no_grad():\r\n            x = self.encoder_cnn(image).unsqueeze(0)\r\n            # x = self.encoder_cnn(image)\r\n            states = None\r\n\r\n            for _ in range(max_length):\r\n                hiddens, states = self.decoder_rnn.lstm(x, states)\r\n                output = self.decoder_rnn.linear(hiddens.squeeze(0))\r\n                predicted = output.argmax(1)\r\n                result_caption.append(predicted.item())\r\n                x = self.decoder_rnn.embed(predicted).unsqueeze(0)\r\n\r\n                if vocabulary.itos[predicted.item()] == \"<EOS>\":\r\n                    break\r\n\r\n        return [vocabulary.itos[idx] for idx in result_caption]"}
{"image_path": "data\\train\\00167.png", "code": "import torch\r\nimport torch.nn as nn\r\nimport torch.optim as optim\r\nfrom torchtext.datasets import Multi30k\r\nfrom torchtext.data import Field, BucketIterator\r\nimport numpy as np\r\nimport spacy\r\nimport random\r\nfrom torch.utils.tensorboard import SummaryWriter  # to print to tensorboard\r\nfrom utils import translate_sentence, bleu, save_checkpoint, load_checkpoint\r\n\r\nspacy_ger = spacy.load(\"de\")\r\nspacy_eng = spacy.load(\"en\")\r\n\r\n\r\ndef tokenize_ger(text):\r\n    return [tok.text for tok in spacy_ger.tokenizer(text)]\r\n\r\n\r\ndef tokenize_eng(text):\r\n    return [tok.text for tok in spacy_eng.tokenizer(text)]\r\n\r\n\r\ngerman = Field(tokenize=tokenize_ger, lower=True, init_token=\"<sos>\", eos_token=\"<eos>\")\r\n\r\nenglish = Field(\r\n    tokenize=tokenize_eng, lower=True, init_token=\"<sos>\", eos_token=\"<eos>\"\r\n)\r\n\r\ntrain_data, valid_data, test_data = Multi30k.splits(\r\n    exts=(\".de\", \".en\"), fields=(german, english)\r\n)\r\n\r\ngerman.build_vocab(train_data, max_size=10000, min_freq=2)\r\nenglish.build_vocab(train_data, max_size=10000, min_freq=2)\r\n\r\n\r\n# class Encoder(nn.Module):\r\n#     def __init__(self, input_size, embedding_size, hidden_size, num_layers, p):\r\n#         super(Encoder, self).__init__()\r\n"}
{"image_path": "data\\train\\00168.png", "code": "#         self.dropout = nn.Dropout(p)\r\n#         self.hidden_size = hidden_size\r\n#         self.num_layers = num_layers\r\n\r\n#         self.embedding = nn.Embedding(input_size, embedding_size)\r\n#         self.rnn = nn.LSTM(embedding_size, hidden_size, num_layers, dropout=p)\r\n\r\n#     def forward(self, x):\r\n#         # x shape: (seq_length, N) where N is batch size\r\n\r\n#         embedding = self.dropout(self.embedding(x))\r\n#         # embedding shape: (seq_length, N, embedding_size)\r\n\r\n#         outputs, (hidden, cell) = self.rnn(embedding)\r\n#         # outputs shape: (seq_length, N, hidden_size)\r\n\r\n#         return hidden, cell\r\n\r\n\r\n# class Decoder(nn.Module):\r\n#     def __init__(\r\n#         self, input_size, embedding_size, hidden_size, output_size, num_layers, p\r\n#     ):\r\n#         super(Decoder, self).__init__()\r\n#         self.dropout = nn.Dropout(p)\r\n#         self.hidden_size = hidden_size\r\n#         self.num_layers = num_layers\r\n\r\n#         self.embedding = nn.Embedding(input_size, embedding_size)\r\n#         self.rnn = nn.LSTM(embedding_size, hidden_size, num_layers, dropout=p)\r\n#         self.fc = nn.Linear(hidden_size, output_size)\r\n\r\n#     def forward(self, x, hidden, cell):\r\n#         # x shape: (N) where N is for batch size, we want it to be (1, N), seq_length\r\n#         # is 1 here because we are sending in a single word and not a sentence\r\n#         x = x.unsqueeze(0)\r\n\r\n#         embedding = self.dropout(self.embedding(x))\r\n#         # embedding shape: (1, N, embedding_size)\r\n\r\n"}
{"image_path": "data\\train\\00169.png", "code": "#         outputs, (hidden, cell) = self.rnn(embedding, (hidden, cell))\r\n#         # outputs shape: (1, N, hidden_size)\r\n\r\n#         predictions = self.fc(outputs)\r\n\r\n#         # predictions shape: (1, N, length_target_vocabulary) to send it to\r\n#         # loss function we want it to be (N, length_target_vocabulary) so we're\r\n#         # just gonna remove the first dim\r\n#         predictions = predictions.squeeze(0)\r\n\r\n#         return predictions, hidden, cell\r\n\r\n\r\n# class Seq2Seq(nn.Module):\r\n#     def __init__(self, encoder, decoder):\r\n#         super(Seq2Seq, self).__init__()\r\n#         self.encoder = encoder\r\n#         self.decoder = decoder\r\n\r\n#     def forward(self, source, target, teacher_force_ratio=0.5):\r\n#         batch_size = source.shape[1]\r\n#         target_len = target.shape[0]\r\n#         target_vocab_size = len(english.vocab)\r\n\r\n#         outputs = torch.zeros(target_len, batch_size, target_vocab_size).to(device)\r\n\r\n#         hidden, cell = self.encoder(source)\r\n\r\n#         # Grab the first input to the Decoder which will be <SOS> token\r\n#         x = target[0]\r\n\r\n#         for t in range(1, target_len):\r\n#             # Use previous hidden, cell as context from encoder at start\r\n#             output, hidden, cell = self.decoder(x, hidden, cell)\r\n\r\n#             # Store next output prediction\r\n#             outputs[t] = output\r\n\r\n#             # Get the best word the Decoder predicted (index in the vocabulary)\r\n#             best_guess = output.argmax(1)\r\n"}
{"image_path": "data\\train\\00170.png", "code": "\r\n#             # With probability of teacher_force_ratio we take the actual next word\r\n#             # otherwise we take the word that the Decoder predicted it to be.\r\n#             # Teacher Forcing is used so that the model gets used to seeing\r\n#             # similar inputs at training and testing time, if teacher forcing is 1\r\n#             # then inputs at test time might be completely different than what the\r\n#             # network is used to. This was a long comment.\r\n#             x = target[t] if random.random() < teacher_force_ratio else best_guess\r\n\r\n#         return outputs\r\n\r\n\r\n# ### We're ready to define everything we need for training our Seq2Seq model ###\r\n\r\n# # Training hyperparameters\r\n# num_epochs = 100\r\n# learning_rate = 0.001\r\n# batch_size = 64\r\n\r\n# # Model hyperparameters\r\n# load_model = False\r\n# device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\r\n# input_size_encoder = len(german.vocab)\r\n# input_size_decoder = len(english.vocab)\r\n# output_size = len(english.vocab)\r\n# encoder_embedding_size = 300\r\n# decoder_embedding_size = 300\r\n# hidden_size = 1024  # Needs to be the same for both RNN's\r\n# num_layers = 2\r\n# enc_dropout = 0.5\r\n# dec_dropout = 0.5\r\n\r\n# # Tensorboard to get nice loss plot\r\n# writer = SummaryWriter(f\"runs/loss_plot\")\r\n# step = 0\r\n\r\n# train_iterator, valid_iterator, test_iterator = BucketIterator.splits(\r\n#     (train_data, valid_data, test_data),\r\n#     batch_size=batch_size,\r\n#     sort_within_batch=True,\r\n"}
{"image_path": "data\\train\\00171.png", "code": "#     sort_key=lambda x: len(x.src),\r\n#     device=device,\r\n# )\r\n\r\n# encoder_net = Encoder(\r\n#     input_size_encoder, encoder_embedding_size, hidden_size, num_layers, enc_dropout\r\n# ).to(device)\r\n\r\n# decoder_net = Decoder(\r\n#     input_size_decoder,\r\n#     decoder_embedding_size,\r\n#     hidden_size,\r\n#     output_size,\r\n#     num_layers,\r\n#     dec_dropout,\r\n# ).to(device)\r\n\r\n# model = Seq2Seq(encoder_net, decoder_net).to(device)\r\n# optimizer = optim.Adam(model.parameters(), lr=learning_rate)\r\n\r\n# pad_idx = english.vocab.stoi[\"<pad>\"]\r\n# criterion = nn.CrossEntropyLoss(ignore_index=pad_idx)\r\n\r\n# if load_model:\r\n#     load_checkpoint(torch.load(\"my_checkpoint.pth.tar\"), model, optimizer)\r\n\r\n\r\n# sentence = \"ein boot mit mehreren m\u00e4nnern darauf wird von einem gro\u00dfen pferdegespann ans ufer gezogen.\"\r\n\r\n# for epoch in range(num_epochs):\r\n#     print(f\"[Epoch {epoch} / {num_epochs}]\")\r\n\r\n#     checkpoint = {\"state_dict\": model.state_dict(), \"optimizer\": optimizer.state_dict()}\r\n#     save_checkpoint(checkpoint)\r\n\r\n#     model.eval()\r\n\r\n#     translated_sentence = translate_sentence(\r\n#         model, sentence, german, english, device, max_length=50\r\n#     )\r\n"}
{"image_path": "data\\train\\00172.png", "code": "\r\n#     print(f\"Translated example sentence: \\n {translated_sentence}\")\r\n\r\n#     model.train()\r\n\r\n#     for batch_idx, batch in enumerate(train_iterator):\r\n#         # Get input and targets and get to cuda\r\n#         inp_data = batch.src.to(device)\r\n#         target = batch.trg.to(device)\r\n\r\n#         # Forward prop\r\n#         output = model(inp_data, target)\r\n\r\n#         # Output is of shape (trg_len, batch_size, output_dim) but Cross Entropy Loss\r\n#         # doesn't take input in that form. For example if we have MNIST we want to have\r\n#         # output to be: (N, 10) and targets just (N). Here we can view it in a similar\r\n#         # way that we have output_words * batch_size that we want to send in into\r\n#         # our cost function, so we need to do some reshapin. While we're at it\r\n#         # Let's also remove the start token while we're at it\r\n#         output = output[1:].reshape(-1, output.shape[2])\r\n#         target = target[1:].reshape(-1)\r\n\r\n#         optimizer.zero_grad()\r\n#         loss = criterion(output, target)\r\n\r\n#         # Back prop\r\n#         loss.backward()\r\n\r\n#         # Clip to avoid exploding gradient issues, makes sure grads are\r\n#         # within a healthy range\r\n#         torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=1)\r\n\r\n#         # Gradient descent step\r\n#         optimizer.step()\r\n\r\n#         # Plot to tensorboard\r\n#         writer.add_scalar(\"Training loss\", loss, global_step=step)\r\n#         step += 1\r\n\r\n\r\n"}
{"image_path": "data\\train\\00173.png", "code": "# score = bleu(test_data[1:100], model, german, english, device)\r\n# print(f\"Bleu score {score*100:.2f}\")"}
{"image_path": "data\\train\\00174.png", "code": "from api import create_app\r\n\r\n\r\napp = create_app()"}
{"image_path": "data\\train\\00175.png", "code": "# Define here the models for your scraped items\r\n#\r\n# See documentation in:\r\n# https://docs.scrapy.org/en/latest/topics/items.html\r\n\r\nimport scrapy\r\n\r\n\r\nclass SlidesgoItem(scrapy.Item):\r\n    # define the fields for your item here like:\r\n    # name = scrapy.Field()\r\n    pass\r\n"}
{"image_path": "data\\train\\00176.png", "code": "# Define your item pipelines here\r\n#\r\n# Don't forget to add your pipeline to the ITEM_PIPELINES setting\r\n# See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html\r\n\r\n\r\n# useful for handling different item types with a single interface\r\nfrom itemadapter import ItemAdapter\r\n\r\n\r\nclass SlidesgoPipeline:\r\n    def process_item(self, item, spider):\r\n        return item\r\n"}
{"image_path": "data\\train\\00177.png", "code": "# Define here the models for your spider middleware\r\n#\r\n# See documentation in:\r\n# https://docs.scrapy.org/en/latest/topics/spider-middleware.html\r\n\r\nfrom scrapy import signals\r\n\r\n# useful for handling different item types with a single interface\r\nfrom itemadapter import is_item, ItemAdapter\r\n\r\n\r\nclass SlidesgoSpiderMiddleware:\r\n    # Not all methods need to be defined. If a method is not defined,\r\n    # scrapy acts as if the spider middleware does not modify the\r\n    # passed objects.\r\n\r\n    @classmethod\r\n    def from_crawler(cls, crawler):\r\n        # This method is used by Scrapy to create your spiders.\r\n        s = cls()\r\n        crawler.signals.connect(s.spider_opened, signal=signals.spider_opened)\r\n        return s\r\n\r\n    def process_spider_input(self, response, spider):\r\n        # Called for each response that goes through the spider\r\n        # middleware and into the spider.\r\n\r\n        # Should return None or raise an exception.\r\n        return None\r\n\r\n    def process_spider_output(self, response, result, spider):\r\n        # Called with the results returned from the Spider, after\r\n        # it has processed the response.\r\n\r\n        # Must return an iterable of Request, or item objects.\r\n        for i in result:\r\n            yield i\r\n\r\n    def process_spider_exception(self, response, exception, spider):\r\n        # Called when a spider or process_spider_input() method\r\n"}
{"image_path": "data\\train\\00178.png", "code": "        # (from other spider middleware) raises an exception.\r\n\r\n        # Should return either None or an iterable of Request or item objects.\r\n        pass\r\n\r\n    def process_start_requests(self, start_requests, spider):\r\n        # Called with the start requests of the spider, and works\r\n        # similarly to the process_spider_output() method, except\r\n        # that it doesn\u2019t have a response associated.\r\n\r\n        # Must return only requests (not items).\r\n        for r in start_requests:\r\n            yield r\r\n\r\n    def spider_opened(self, spider):\r\n        spider.logger.info(\"Spider opened: %s\" % spider.name)\r\n\r\n\r\nclass SlidesgoDownloaderMiddleware:\r\n    # Not all methods need to be defined. If a method is not defined,\r\n    # scrapy acts as if the downloader middleware does not modify the\r\n    # passed objects.\r\n\r\n    @classmethod\r\n    def from_crawler(cls, crawler):\r\n        # This method is used by Scrapy to create your spiders.\r\n        s = cls()\r\n        crawler.signals.connect(s.spider_opened, signal=signals.spider_opened)\r\n        return s\r\n\r\n    def process_request(self, request, spider):\r\n        # Called for each request that goes through the downloader\r\n        # middleware.\r\n\r\n        # Must either:\r\n        # - return None: continue processing this request\r\n        # - or return a Response object\r\n        # - or return a Request object\r\n        # - or raise IgnoreRequest: process_exception() methods of\r\n        #   installed downloader middleware will be called\r\n"}
{"image_path": "data\\train\\00179.png", "code": "        return None\r\n\r\n    def process_response(self, request, response, spider):\r\n        # Called with the response returned from the downloader.\r\n\r\n        # Must either;\r\n        # - return a Response object\r\n        # - return a Request object\r\n        # - or raise IgnoreRequest\r\n        return response\r\n\r\n    def process_exception(self, request, exception, spider):\r\n        # Called when a download handler or a process_request()\r\n        # (from other downloader middleware) raises an exception.\r\n\r\n        # Must either:\r\n        # - return None: continue processing this exception\r\n        # - return a Response object: stops process_exception() chain\r\n        # - return a Request object: stops process_exception() chain\r\n        pass\r\n\r\n    def spider_opened(self, spider):\r\n        spider.logger.info(\"Spider opened: %s\" % spider.name)\r\n"}
{"image_path": "data\\train\\00180.png", "code": "# Scrapy settings for slidesgo project\r\n#\r\n# For simplicity, this file contains only settings considered important or\r\n# commonly used. You can find more settings consulting the documentation:\r\n#\r\n#     https://docs.scrapy.org/en/latest/topics/settings.html\r\n#     https://docs.scrapy.org/en/latest/topics/downloader-middleware.html\r\n#     https://docs.scrapy.org/en/latest/topics/spider-middleware.html\r\n\r\nBOT_NAME = \"slidesgo\"\r\n\r\nSPIDER_MODULES = [\"slidesgo.spiders\"]\r\nNEWSPIDER_MODULE = \"slidesgo.spiders\"\r\n\r\n\r\n# Crawl responsibly by identifying yourself (and your website) on the user-agent\r\n#USER_AGENT = \"slidesgo (+http://www.yourdomain.com)\"\r\n\r\n# Obey robots.txt rules\r\nROBOTSTXT_OBEY = True\r\n\r\n# Configure maximum concurrent requests performed by Scrapy (default: 16)\r\n#CONCURRENT_REQUESTS = 32\r\n\r\n# Configure a delay for requests for the same website (default: 0)\r\n# See https://docs.scrapy.org/en/latest/topics/settings.html#download-delay\r\n# See also autothrottle settings and docs\r\n#DOWNLOAD_DELAY = 3\r\n# The download delay setting will honor only one of:\r\n#CONCURRENT_REQUESTS_PER_DOMAIN = 16\r\n#CONCURRENT_REQUESTS_PER_IP = 16\r\n\r\n# Disable cookies (enabled by default)\r\n#COOKIES_ENABLED = False\r\n\r\n# Disable Telnet Console (enabled by default)\r\n#TELNETCONSOLE_ENABLED = False\r\n\r\n# Override the default request headers:\r\n#DEFAULT_REQUEST_HEADERS = {\r\n"}
{"image_path": "data\\train\\00181.png", "code": "#    \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\r\n#    \"Accept-Language\": \"en\",\r\n#}\r\n\r\n# Enable or disable spider middlewares\r\n# See https://docs.scrapy.org/en/latest/topics/spider-middleware.html\r\n#SPIDER_MIDDLEWARES = {\r\n#    \"slidesgo.middlewares.SlidesgoSpiderMiddleware\": 543,\r\n#}\r\n\r\n# Enable or disable downloader middlewares\r\n# See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html\r\n#DOWNLOADER_MIDDLEWARES = {\r\n#    \"slidesgo.middlewares.SlidesgoDownloaderMiddleware\": 543,\r\n#}\r\n\r\n# Enable or disable extensions\r\n# See https://docs.scrapy.org/en/latest/topics/extensions.html\r\n#EXTENSIONS = {\r\n#    \"scrapy.extensions.telnet.TelnetConsole\": None,\r\n#}\r\n\r\n# Configure item pipelines\r\n# See https://docs.scrapy.org/en/latest/topics/item-pipeline.html\r\n#ITEM_PIPELINES = {\r\n#    \"slidesgo.pipelines.SlidesgoPipeline\": 300,\r\n#}\r\n\r\n# Enable and configure the AutoThrottle extension (disabled by default)\r\n# See https://docs.scrapy.org/en/latest/topics/autothrottle.html\r\n#AUTOTHROTTLE_ENABLED = True\r\n# The initial download delay\r\n#AUTOTHROTTLE_START_DELAY = 5\r\n# The maximum download delay to be set in case of high latencies\r\n#AUTOTHROTTLE_MAX_DELAY = 60\r\n# The average number of requests Scrapy should be sending in parallel to\r\n# each remote server\r\n#AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0\r\n# Enable showing throttling stats for every response received:\r\n#AUTOTHROTTLE_DEBUG = False\r\n"}
{"image_path": "data\\train\\00182.png", "code": "\r\n# Enable and configure HTTP caching (disabled by default)\r\n# See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settings\r\n#HTTPCACHE_ENABLED = True\r\n#HTTPCACHE_EXPIRATION_SECS = 0\r\n#HTTPCACHE_DIR = \"httpcache\"\r\n#HTTPCACHE_IGNORE_HTTP_CODES = []\r\n#HTTPCACHE_STORAGE = \"scrapy.extensions.httpcache.FilesystemCacheStorage\"\r\n\r\n# Set settings whose default value is deprecated to a future-proof value\r\nREQUEST_FINGERPRINTER_IMPLEMENTATION = \"2.7\"\r\nTWISTED_REACTOR = \"twisted.internet.asyncioreactor.AsyncioSelectorReactor\"\r\nFEED_EXPORT_ENCODING = \"utf-8\"\r\n"}
{"image_path": "data\\train\\00183.png", "code": "# Define here the models for your scraped items\r\n#\r\n# See documentation in:\r\n# https://docs.scrapy.org/en/latest/topics/items.html\r\n\r\nimport scrapy\r\n\r\n\r\nclass LeetcodeItem(scrapy.Item):\r\n    # define the fields for your item here like:\r\n    # name = scrapy.Field()\r\n    pass\r\n"}
{"image_path": "data\\train\\00184.png", "code": "# Define your item pipelines here\r\n#\r\n# Don't forget to add your pipeline to the ITEM_PIPELINES setting\r\n# See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html\r\n\r\n\r\n# useful for handling different item types with a single interface\r\nfrom itemadapter import ItemAdapter\r\n\r\n\r\nclass LeetcodePipeline:\r\n    def process_item(self, item, spider):\r\n        return item\r\n"}
{"image_path": "data\\train\\00185.png", "code": "# Define here the models for your spider middleware\r\n#\r\n# See documentation in:\r\n# https://docs.scrapy.org/en/latest/topics/spider-middleware.html\r\n\r\nfrom scrapy import signals\r\n\r\n# useful for handling different item types with a single interface\r\nfrom itemadapter import is_item, ItemAdapter\r\n\r\n\r\nclass LeetcodeSpiderMiddleware:\r\n    # Not all methods need to be defined. If a method is not defined,\r\n    # scrapy acts as if the spider middleware does not modify the\r\n    # passed objects.\r\n\r\n    @classmethod\r\n    def from_crawler(cls, crawler):\r\n        # This method is used by Scrapy to create your spiders.\r\n        s = cls()\r\n        crawler.signals.connect(s.spider_opened, signal=signals.spider_opened)\r\n        return s\r\n\r\n    def process_spider_input(self, response, spider):\r\n        # Called for each response that goes through the spider\r\n        # middleware and into the spider.\r\n\r\n        # Should return None or raise an exception.\r\n        return None\r\n\r\n    def process_spider_output(self, response, result, spider):\r\n        # Called with the results returned from the Spider, after\r\n        # it has processed the response.\r\n\r\n        # Must return an iterable of Request, or item objects.\r\n        for i in result:\r\n            yield i\r\n\r\n    def process_spider_exception(self, response, exception, spider):\r\n        # Called when a spider or process_spider_input() method\r\n"}
{"image_path": "data\\train\\00186.png", "code": "        # (from other spider middleware) raises an exception.\r\n\r\n        # Should return either None or an iterable of Request or item objects.\r\n        pass\r\n\r\n    def process_start_requests(self, start_requests, spider):\r\n        # Called with the start requests of the spider, and works\r\n        # similarly to the process_spider_output() method, except\r\n        # that it doesn\u2019t have a response associated.\r\n\r\n        # Must return only requests (not items).\r\n        for r in start_requests:\r\n            yield r\r\n\r\n    def spider_opened(self, spider):\r\n        spider.logger.info(\"Spider opened: %s\" % spider.name)\r\n\r\n\r\nclass LeetcodeDownloaderMiddleware:\r\n    # Not all methods need to be defined. If a method is not defined,\r\n    # scrapy acts as if the downloader middleware does not modify the\r\n    # passed objects.\r\n\r\n    @classmethod\r\n    def from_crawler(cls, crawler):\r\n        # This method is used by Scrapy to create your spiders.\r\n        s = cls()\r\n        crawler.signals.connect(s.spider_opened, signal=signals.spider_opened)\r\n        return s\r\n\r\n    def process_request(self, request, spider):\r\n        # Called for each request that goes through the downloader\r\n        # middleware.\r\n\r\n        # Must either:\r\n        # - return None: continue processing this request\r\n        # - or return a Response object\r\n        # - or return a Request object\r\n        # - or raise IgnoreRequest: process_exception() methods of\r\n        #   installed downloader middleware will be called\r\n"}
{"image_path": "data\\train\\00187.png", "code": "        return None\r\n\r\n    def process_response(self, request, response, spider):\r\n        # Called with the response returned from the downloader.\r\n\r\n        # Must either;\r\n        # - return a Response object\r\n        # - return a Request object\r\n        # - or raise IgnoreRequest\r\n        return response\r\n\r\n    def process_exception(self, request, exception, spider):\r\n        # Called when a download handler or a process_request()\r\n        # (from other downloader middleware) raises an exception.\r\n\r\n        # Must either:\r\n        # - return None: continue processing this exception\r\n        # - return a Response object: stops process_exception() chain\r\n        # - return a Request object: stops process_exception() chain\r\n        pass\r\n\r\n    def spider_opened(self, spider):\r\n        spider.logger.info(\"Spider opened: %s\" % spider.name)\r\n"}
{"image_path": "data\\train\\00188.png", "code": "# Scrapy settings for leetcode project\r\n#\r\n# For simplicity, this file contains only settings considered important or\r\n# commonly used. You can find more settings consulting the documentation:\r\n#\r\n#     https://docs.scrapy.org/en/latest/topics/settings.html\r\n#     https://docs.scrapy.org/en/latest/topics/downloader-middleware.html\r\n#     https://docs.scrapy.org/en/latest/topics/spider-middleware.html\r\n\r\nBOT_NAME = \"leetcode\"\r\n\r\nSPIDER_MODULES = [\"leetcode.spiders\"]\r\nNEWSPIDER_MODULE = \"leetcode.spiders\"\r\n\r\n\r\n# Crawl responsibly by identifying yourself (and your website) on the user-agent\r\nUSER_AGENT = 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148'\r\n\r\n# Obey robots.txt rules\r\nROBOTSTXT_OBEY = False\r\n\r\n# Configure maximum concurrent requests performed by Scrapy (default: 16)\r\n#CONCURRENT_REQUESTS = 32\r\n\r\n# Configure a delay for requests for the same website (default: 0)\r\n# See https://docs.scrapy.org/en/latest/topics/settings.html#download-delay\r\n# See also autothrottle settings and docs\r\n#DOWNLOAD_DELAY = 3\r\n# The download delay setting will honor only one of:\r\n#CONCURRENT_REQUESTS_PER_DOMAIN = 16\r\n#CONCURRENT_REQUESTS_PER_IP = 16\r\n\r\n# Disable cookies (enabled by default)\r\n#COOKIES_ENABLED = False\r\n\r\n# Disable Telnet Console (enabled by default)\r\n#TELNETCONSOLE_ENABLED = False\r\n\r\n# Override the default request headers:\r\n#DEFAULT_REQUEST_HEADERS = {\r\n"}
{"image_path": "data\\train\\00189.png", "code": "#    \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\r\n#    \"Accept-Language\": \"en\",\r\n#}\r\n\r\n# Enable or disable spider middlewares\r\n# See https://docs.scrapy.org/en/latest/topics/spider-middleware.html\r\n#SPIDER_MIDDLEWARES = {\r\n#    \"leetcode.middlewares.LeetcodeSpiderMiddleware\": 543,\r\n#}\r\n\r\n# Enable or disable downloader middlewares\r\n# See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html\r\nDOWNLOADER_MIDDLEWARES = {\r\n    'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware': None,\r\n    'scrapy.downloadermiddlewares.retry.RetryMiddleware': None,\r\n    'scrapy_fake_useragent.middleware.RandomUserAgentMiddleware': 400,\r\n    'scrapy_fake_useragent.middleware.RetryUserAgentMiddleware': 401,\r\n}\r\nFAKEUSERAGENT_PROVIDERS = [\r\n    'scrapy_fake_useragent.providers.FakeUserAgentProvider',  # This is the first provider we'll try\r\n    'scrapy_fake_useragent.providers.FakerProvider',  # If FakeUserAgentProvider fails, we'll use faker to generate a user-agent string for us\r\n    'scrapy_fake_useragent.providers.FixedUserAgentProvider',  # Fall back to USER_AGENT value\r\n]\r\n\r\n# Enable or disable extensions\r\n# See https://docs.scrapy.org/en/latest/topics/extensions.html\r\n#EXTENSIONS = {\r\n#    \"scrapy.extensions.telnet.TelnetConsole\": None,\r\n#}\r\n\r\n# Configure item pipelines\r\n# See https://docs.scrapy.org/en/latest/topics/item-pipeline.html\r\n#ITEM_PIPELINES = {\r\n#    \"leetcode.pipelines.LeetcodePipeline\": 300,\r\n#}\r\n\r\n# Enable and configure the AutoThrottle extension (disabled by default)\r\n# See https://docs.scrapy.org/en/latest/topics/autothrottle.html\r\n#AUTOTHROTTLE_ENABLED = True\r\n# The initial download delay\r\n"}
{"image_path": "data\\train\\00190.png", "code": "#AUTOTHROTTLE_START_DELAY = 5\r\n# The maximum download delay to be set in case of high latencies\r\n#AUTOTHROTTLE_MAX_DELAY = 60\r\n# The average number of requests Scrapy should be sending in parallel to\r\n# each remote server\r\n#AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0\r\n# Enable showing throttling stats for every response received:\r\n#AUTOTHROTTLE_DEBUG = False\r\n\r\n# Enable and configure HTTP caching (disabled by default)\r\n# See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settings\r\n#HTTPCACHE_ENABLED = True\r\n#HTTPCACHE_EXPIRATION_SECS = 0\r\n#HTTPCACHE_DIR = \"httpcache\"\r\n#HTTPCACHE_IGNORE_HTTP_CODES = []\r\n#HTTPCACHE_STORAGE = \"scrapy.extensions.httpcache.FilesystemCacheStorage\"\r\n\r\n# Set settings whose default value is deprecated to a future-proof value\r\nREQUEST_FINGERPRINTER_IMPLEMENTATION = \"2.7\"\r\nTWISTED_REACTOR = \"twisted.internet.asyncioreactor.AsyncioSelectorReactor\"\r\nFEED_EXPORT_ENCODING = \"utf-8\"\r\n"}
{"image_path": "data\\train\\00191.png", "code": "from flask import Flask, jsonify, redirect, url_for\r\nfrom http import HTTPStatus\r\nfrom .blueprints import register_blueprints\r\nfrom .config import set_configuration\r\nfrom oauthlib.oauth2.rfc6749.errors import InvalidGrantError, TokenExpiredError\r\nfrom flask_dance.contrib.google import google\r\n\r\n\r\ndef create_app() -> Flask:\r\n    \"\"\"Create the Flask App instance.\"\"\"\r\n    app = Flask(__name__)\r\n    set_configuration(app=app)\r\n    register_blueprints(app=app)\r\n    \r\n    \r\n    @app.route(\"/login\")\r\n    def login():\r\n        try:\r\n            if not google.authorized:\r\n                return redirect(url_for(\"google.login\"))\r\n            resp = google.get(\"/oauth2/v1/userinfo\")\r\n            if resp.ok:\r\n                return redirect(url_for(\"home.home_page\"))\r\n            return redirect(url_for(\"login\"))\r\n        except (TokenExpiredError, InvalidGrantError):\r\n            return redirect(url_for(\"google.login\"))\r\n    \r\n    @app.route(\"/health\")\r\n    def health():\r\n        return jsonify({\"Up\": True}), HTTPStatus.OK\r\n\r\n    app.shell_context_processor({\"app\": app})\r\n\r\n    return app"}
{"image_path": "data\\train\\00192.png", "code": "# utils.py\r\n\r\nfrom playwright.sync_api import sync_playwright\r\nimport uuid\r\nfrom PIL import Image\r\nfrom PIL import Image\r\nimport io\r\nfrom os import path\r\nimport json\r\n\r\nindex: int = 1\r\n\r\ndef take_screenshot_from_url(url, session_data):\r\n    with sync_playwright() as playwright:\r\n        webkit = playwright.webkit\r\n        browser = webkit.launch()\r\n        browser_context = browser.new_context(device_scale_factor=2)\r\n        browser_context.add_cookies([session_data])\r\n        page = browser_context.new_page()\r\n        page.goto(url)\r\n        screenshot_bytes = page.locator(\".code\").screenshot()\r\n        browser.close()\r\n        return screenshot_bytes\r\n    \r\n    \r\ndef save_data(image_bytes: bytes, code: str) -> None:\r\n    file_name: str = str(uuid.uuid4())\r\n    image: Image = Image.open(io.BytesIO(image_bytes))\r\n    file_path: str = \"data\"\r\n    image_path: str = path.join(file_path, f\"{file_name}.png\")\r\n    image.save(image_path)\r\n    code_path: str = path.join(file_path, \"metadata.jsonl\")\r\n    metadata: dict = {\r\n        \"file_name\": f\"{file_name}.png\",\r\n        \"code\": code\r\n    }\r\n    with open(code_path, \"a+\", encoding=\"utf-8\") as f:\r\n        f.write(json.dumps(metadata) + \"\\n\")"}
{"image_path": "data\\train\\00193.png", "code": "\r\n    return app"}
{"image_path": "data\\train\\00194.png", "code": "from scrapy import Item, Field\r\nfrom itemloaders.processors import TakeFirst, MapCompose, Join\r\nimport re\r\n\r\n\r\ndef remove_html_tags(description: str) -> str:\r\n    html_pattern = \"<(?:\\\"[^\\\"]*\\\"['\\\"]*|'[^']*'['\\\"]*|[^'\\\">])+>\" \r\n    return re.sub(html_pattern, '', description)\r\n\r\ndef remove_unicode_chars(text: str) -> str:\r\n    return text.replace(u\"\\xa0\", \"\")\r\n\r\ndef num_of_slides(text: str) -> int:\r\n    vals = [val for val in list(text) if val.isdigit()]\r\n    return \"\".join(vals)\r\n\r\n\r\nclass SlidesModelItem(Item):\r\n    title = Field(output_processor=TakeFirst())\r\n    category = Field(output_processor=TakeFirst())\r\n    description = Field(\r\n        input_processor=MapCompose(remove_html_tags, remove_unicode_chars),\r\n        output_processor=Join()\r\n    )\r\n    tags = Field()\r\n    slides_count = Field(\r\n        input_processor=MapCompose(num_of_slides),\r\n        output_processor=TakeFirst()\r\n    )\r\n    colors = Field()\r\n    image_urls = Field()\r\n    images = Field()\r\n"}
{"image_path": "data\\train\\00195.png", "code": "from itemadapter import ItemAdapter\r\nfrom scrapy.pipelines.images import ImagesPipeline\r\nfrom scrapy.exceptions import DropItem\r\nfrom os import path, mkdir\r\nfrom scrapy.http import Response\r\nfrom scrapy import Request, Spider\r\nfrom scrapy import Item\r\nfrom pathlib import PurePosixPath\r\nfrom urllib.parse import urlparse\r\nfrom slidesmodel.models import db_connect, Tag, Category, Slide, create_table, create_engine\r\nfrom sqlalchemy.orm import sessionmaker\r\nimport uuid\r\nimport logging\r\n\r\n\r\nclass SlidesmodelPipeline:\r\n    def process_item(self, item: Item, spider: Spider):\r\n        return item\r\n    \r\nclass MyImagesPipeline(ImagesPipeline):\r\n    def file_path(self, request: Request, response: Response = None, info=None, *, item=None):\r\n        slide_name: str = request.meta['title']\r\n        return f\"{slide_name}/\" + PurePosixPath(urlparse(request.url).path).name\r\n    \r\n    def get_media_requests(self, item: Item, info):\r\n        for image_url in item[\"image_urls\"]:\r\n            yield Request(image_url, meta={\"title\": item[\"title\"]})\r\n            \r\n\r\nclass SaveSlidesPipeline(object):\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initializes database connection and sessionmaker\r\n        Creates tables\r\n        \"\"\"\r\n        engine = db_connect()\r\n        create_table(engine)\r\n        self.Session = sessionmaker(bind=engine)\r\n\r\n\r\n"}
{"image_path": "data\\train\\00196.png", "code": "    def process_item(self, item: Item, spider: Spider):\r\n        \"\"\"Save quotes in the database\r\n        This method is called for every item pipeline component\r\n        \"\"\"\r\n        session = self.Session()\r\n        \r\n        category = Category()\r\n        slide = Slide()\r\n        tag = Tag()\r\n        \r\n        slide.id = str(uuid.uuid4())\r\n        slide.description = item[\"description\"]\r\n        slide.title = item[\"title\"]\r\n        slide.image_urls = item[\"image_urls\"]\r\n        slide.image_paths = [image[\"path\"] for image in item[\"images\"]]\r\n        slide.colors = item[\"colors\"]\r\n        \r\n        category.id = str(uuid.uuid4())\r\n        if item.get(\"category\"):\r\n            category.name = item[\"category\"]\r\n        else:\r\n            category.name = \"\"\r\n\r\n        # check whether the category exists\r\n        exist_category = session.query(Category).filter_by(name=category.name).first()\r\n        if exist_category is not None:  # the current category exists\r\n            slide.category = exist_category\r\n        else:\r\n            slide.category = category\r\n\r\n        # check whether the current quote has tags or not\r\n        for tag_name in item[\"tags\"]:\r\n            tag = Tag(name=tag_name, id=str(uuid.uuid4()))\r\n            # check whether the current tag already exists in the database\r\n            exist_tag = session.query(Tag).filter_by(name=tag.name).first()\r\n            if exist_tag is not None:  # the current tag exists\r\n                tag = exist_tag\r\n            slide.tags.append(tag)\r\n\r\n        try:\r\n"}
{"image_path": "data\\train\\00197.png", "code": "            session.add(slide)\r\n            session.commit()\r\n\r\n        except:\r\n            session.rollback()\r\n            raise\r\n\r\n        finally:\r\n            session.close()\r\n\r\n        return item\r\n\r\n\r\nclass DuplicatesPipeline(object):\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initializes database connection and sessionmaker.\r\n        Creates tables.\r\n        \"\"\"\r\n        engine = db_connect()\r\n        create_table(engine)\r\n        self.Session = sessionmaker(bind=engine)\r\n        logging.info(\"****DuplicatesPipeline: database connected****\")\r\n\r\n    def process_item(self, item: Item, spider: Spider):\r\n        session = self.Session()\r\n        exist_slide = session.query(Slide).filter_by(title=item[\"title\"]).first()\r\n        session.close()\r\n        if exist_slide is not None:  # the current slide exists\r\n            raise DropItem(\"Duplicate item found: %s\" % item[\"title\"])\r\n        else:\r\n            return item"}
{"image_path": "data\\train\\00198.png", "code": "# Define here the models for your spider middleware\r\n#\r\n# See documentation in:\r\n# https://docs.scrapy.org/en/latest/topics/spider-middleware.html\r\n\r\nfrom scrapy import signals\r\n\r\n# useful for handling different item types with a single interface\r\nfrom itemadapter import is_item, ItemAdapter\r\n\r\n\r\nclass SlidesmodelSpiderMiddleware:\r\n    # Not all methods need to be defined. If a method is not defined,\r\n    # scrapy acts as if the spider middleware does not modify the\r\n    # passed objects.\r\n\r\n    @classmethod\r\n    def from_crawler(cls, crawler):\r\n        # This method is used by Scrapy to create your spiders.\r\n        s = cls()\r\n        crawler.signals.connect(s.spider_opened, signal=signals.spider_opened)\r\n        return s\r\n\r\n    def process_spider_input(self, response, spider):\r\n        # Called for each response that goes through the spider\r\n        # middleware and into the spider.\r\n\r\n        # Should return None or raise an exception.\r\n        return None\r\n\r\n    def process_spider_output(self, response, result, spider):\r\n        # Called with the results returned from the Spider, after\r\n        # it has processed the response.\r\n\r\n        # Must return an iterable of Request, or item objects.\r\n        for i in result:\r\n            yield i\r\n\r\n    def process_spider_exception(self, response, exception, spider):\r\n        # Called when a spider or process_spider_input() method\r\n"}
{"image_path": "data\\train\\00199.png", "code": "        # (from other spider middleware) raises an exception.\r\n\r\n        # Should return either None or an iterable of Request or item objects.\r\n        pass\r\n\r\n    def process_start_requests(self, start_requests, spider):\r\n        # Called with the start requests of the spider, and works\r\n        # similarly to the process_spider_output() method, except\r\n        # that it doesn\u2019t have a response associated.\r\n\r\n        # Must return only requests (not items).\r\n        for r in start_requests:\r\n            yield r\r\n\r\n    def spider_opened(self, spider):\r\n        spider.logger.info(\"Spider opened: %s\" % spider.name)\r\n\r\n\r\nclass SlidesmodelDownloaderMiddleware:\r\n    # Not all methods need to be defined. If a method is not defined,\r\n    # scrapy acts as if the downloader middleware does not modify the\r\n    # passed objects.\r\n\r\n    @classmethod\r\n    def from_crawler(cls, crawler):\r\n        # This method is used by Scrapy to create your spiders.\r\n        s = cls()\r\n        crawler.signals.connect(s.spider_opened, signal=signals.spider_opened)\r\n        return s\r\n\r\n    def process_request(self, request, spider):\r\n        # Called for each request that goes through the downloader\r\n        # middleware.\r\n\r\n        # Must either:\r\n        # - return None: continue processing this request\r\n        # - or return a Response object\r\n        # - or return a Request object\r\n        # - or raise IgnoreRequest: process_exception() methods of\r\n        #   installed downloader middleware will be called\r\n"}
{"image_path": "data\\train\\00200.png", "code": "        return None\r\n\r\n    def process_response(self, request, response, spider):\r\n        # Called with the response returned from the downloader.\r\n\r\n        # Must either;\r\n        # - return a Response object\r\n        # - return a Request object\r\n        # - or raise IgnoreRequest\r\n        return response\r\n\r\n    def process_exception(self, request, exception, spider):\r\n        # Called when a download handler or a process_request()\r\n        # (from other downloader middleware) raises an exception.\r\n\r\n        # Must either:\r\n        # - return None: continue processing this exception\r\n        # - return a Response object: stops process_exception() chain\r\n        # - return a Request object: stops process_exception() chain\r\n        pass\r\n\r\n    def spider_opened(self, spider):\r\n        spider.logger.info(\"Spider opened: %s\" % spider.name)\r\n"}
{"image_path": "data\\train\\00201.png", "code": "\r\nfrom sqlalchemy import create_engine, Column, Table, ForeignKey, MetaData\r\nfrom sqlalchemy.orm import relationship\r\nfrom sqlalchemy.ext.declarative import declarative_base\r\nfrom sqlalchemy import (\r\n    Integer, String, Date, DateTime, Float, Boolean, Text)\r\nfrom scrapy.utils.project import get_project_settings\r\nfrom sqlalchemy_utils import ScalarListType\r\n\r\n\r\nBase = declarative_base()\r\n\r\ndef db_connect():\r\n    \"\"\"\r\n    Performs database connection using database settings from settings.py.\r\n    Returns sqlalchemy engine instance\r\n    \"\"\"\r\n    settings: dict = get_project_settings()\r\n    connection_string: str = settings.get(\"CONNECTION_STRING\")\r\n    return create_engine(connection_string)\r\n\r\ndef create_table(engine):\r\n    Base.metadata.create_all(engine)\r\n    \r\n    \r\nslide_tag = Table('slide_tag', Base.metadata,\r\n    Column('slide_id', Integer, ForeignKey('slide.id')),\r\n    Column('tag_id', Integer, ForeignKey('tag.id'))\r\n)\r\n\r\nclass Slide(Base):\r\n    __tablename__ = \"slide\"\r\n\r\n    id = Column(String(), primary_key=True)\r\n    title = Column('title', String())\r\n    description = Column('description', Text())\r\n    category_id = Column(String(), ForeignKey('category.id'))\r\n    tags = relationship('Tag', secondary='slide_tag',\r\n        lazy='dynamic', backref=\"slide\")  # M-to-M for quote and tag\r\n    colors = Column(ScalarListType())\r\n"}
{"image_path": "data\\train\\00202.png", "code": "    image_paths = Column(ScalarListType())\r\n    image_urls = Column(ScalarListType())\r\n    \r\n\r\nclass Tag(Base):\r\n    __tablename__ = \"tag\"\r\n\r\n    id = Column(String(), primary_key=True)\r\n    name = Column('name', String(30), unique=True)\r\n    slides = relationship('Slide', secondary='slide_tag',\r\n        lazy='dynamic', backref=\"tag\")  # M-to-M for quote and tag\r\n    \r\n    \r\nclass Category(Base):\r\n    __tablename__ = \"category\"\r\n\r\n    id = Column(String(), primary_key=True)\r\n    name = Column('name', String(50), unique=True)\r\n    slides = relationship('Slide', backref='category')"}
{"image_path": "data\\train\\00203.png", "code": "# Scrapy settings for slidesmodel project\r\n#\r\n# For simplicity, this file contains only settings considered important or\r\n# commonly used. You can find more settings consulting the documentation:\r\n#\r\n#     https://docs.scrapy.org/en/latest/topics/settings.html\r\n#     https://docs.scrapy.org/en/latest/topics/downloader-middleware.html\r\n#     https://docs.scrapy.org/en/latest/topics/spider-middleware.html\r\n\r\nBOT_NAME = \"slidesmodel\"\r\n\r\nSPIDER_MODULES = [\"slidesmodel.spiders\"]\r\nNEWSPIDER_MODULE = \"slidesmodel.spiders\"\r\n\r\n\r\n# Crawl responsibly by identifying yourself (and your website) on the user-agent\r\n#USER_AGENT = \"slidesmodel (+http://www.yourdomain.com)\"\r\n\r\n# Obey robots.txt rules\r\nROBOTSTXT_OBEY = False\r\n\r\n# Configure maximum concurrent requests performed by Scrapy (default: 16)\r\n#CONCURRENT_REQUESTS = 32\r\n\r\n# Configure a delay for requests for the same website (default: 0)\r\n# See https://docs.scrapy.org/en/latest/topics/settings.html#download-delay\r\n# See also autothrottle settings and docs\r\n#DOWNLOAD_DELAY = 3\r\n# The download delay setting will honor only one of:\r\n#CONCURRENT_REQUESTS_PER_DOMAIN = 16\r\n#CONCURRENT_REQUESTS_PER_IP = 16\r\n\r\n# Disable cookies (enabled by default)\r\n#COOKIES_ENABLED = False\r\n\r\n# Disable Telnet Console (enabled by default)\r\n#TELNETCONSOLE_ENABLED = False\r\n\r\n# Override the default request headers:\r\n#DEFAULT_REQUEST_HEADERS = {\r\n"}
{"image_path": "data\\train\\00204.png", "code": "#    \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\r\n#    \"Accept-Language\": \"en\",\r\n#}\r\n\r\n# Enable or disable spider middlewares\r\n# See https://docs.scrapy.org/en/latest/topics/spider-middleware.html\r\n#SPIDER_MIDDLEWARES = {\r\n#    \"slidesmodel.middlewares.SlidesmodelSpiderMiddleware\": 543,\r\n#}\r\n\r\n# Enable or disable downloader middlewares\r\n# See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html\r\n#DOWNLOADER_MIDDLEWARES = {\r\n#    \"slidesmodel.middlewares.SlidesmodelDownloaderMiddleware\": 543,\r\n#}\r\n\r\n# Enable or disable extensions\r\n# See https://docs.scrapy.org/en/latest/topics/extensions.html\r\n#EXTENSIONS = {\r\n#    \"scrapy.extensions.telnet.TelnetConsole\": None,\r\n#}\r\n\r\n# Configure item pipelines\r\n# See https://docs.scrapy.org/en/latest/topics/item-pipeline.html\r\nITEM_PIPELINES = {\r\n   \"slidesmodel.pipelines.SlidesmodelPipeline\": 300,\r\n   \"slidesmodel.pipelines.MyImagesPipeline\": 1,\r\n   \"slidesmodel.pipelines.SaveSlidesPipeline\": 200,\r\n   \"slidesmodel.pipelines.DuplicatesPipeline\": 100,\r\n}\r\n\r\n# Enable and configure the AutoThrottle extension (disabled by default)\r\n# See https://docs.scrapy.org/en/latest/topics/autothrottle.html\r\n#AUTOTHROTTLE_ENABLED = True\r\n# The initial download delay\r\n#AUTOTHROTTLE_START_DELAY = 5\r\n# The maximum download delay to be set in case of high latencies\r\n#AUTOTHROTTLE_MAX_DELAY = 60\r\n# The average number of requests Scrapy should be sending in parallel to\r\n# each remote server\r\n"}
{"image_path": "data\\train\\00205.png", "code": "#AUTOTHROTTLE_TARGET_CONCURRENCY = 1.0\r\n# Enable showing throttling stats for every response received:\r\n#AUTOTHROTTLE_DEBUG = False\r\n\r\n# Enable and configure HTTP caching (disabled by default)\r\n# See https://docs.scrapy.org/en/latest/topics/downloader-middleware.html#httpcache-middleware-settings\r\n#HTTPCACHE_ENABLED = True\r\n#HTTPCACHE_EXPIRATION_SECS = 0\r\n#HTTPCACHE_DIR = \"httpcache\"\r\n#HTTPCACHE_IGNORE_HTTP_CODES = []\r\n#HTTPCACHE_STORAGE = \"scrapy.extensions.httpcache.FilesystemCacheStorage\"\r\n\r\n# Set settings whose default value is deprecated to a future-proof value\r\nREQUEST_FINGERPRINTER_IMPLEMENTATION = \"2.7\"\r\nTWISTED_REACTOR = \"twisted.internet.asyncioreactor.AsyncioSelectorReactor\"\r\nFEED_EXPORT_ENCODING = \"utf-8\"\r\n\r\nIMAGES_URLS_FIELD = \"image_urls\"\r\nIMAGES_RESULT_FIELD = \"images\"\r\nIMAGES_STORE = \"/home/lyle/oryks/scrapy-tutorial/slidesmodel/images\"\r\nCONNECTION_STRING = \"sqlite:////home/lyle/oryks/scrapy-tutorial/data/slides.db\"\r\nSTART_URLS_PATH = \"/home/lyle/oryks/scrapy-tutorial/links.json\"\r\n"}
{"image_path": "data\\train\\00206.png", "code": "from fastapi import FastAPI\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\nfrom .routers import register_routers\r\n\r\n\r\norigins = [\r\n    \"http://localhost\",\r\n    \"http://localhost:8080\",\r\n]\r\n\r\ndef create_app():\r\n    app = FastAPI()\r\n    app.add_middleware(\r\n        CORSMiddleware,\r\n        allow_origins=[\"*\"],\r\n        allow_credentials=True,\r\n        allow_methods=[\"*\"],\r\n        allow_headers=[\"*\"],\r\n    )\r\n    register_routers(app=app)\r\n    \r\n    @app.get('/health', tags=['Health'])\r\n    async def get():\r\n        return {'Success': 'Up!'}\r\n    \r\n    return app"}
{"image_path": "data\\train\\00207.png", "code": "from typing import Any\r\nfrom scrapy import Spider\r\nfrom scrapy.http import Response\r\nfrom scrapy.linkextractors import LinkExtractor \r\n\r\n\r\nclass SlidesLinkExtractor(Spider):\r\n    name: str = \"links-extractor\"\r\n    \r\n    start_urls: list[str] = [\r\n        \"https://slidesgo.com/\"\r\n    ]\r\n    \r\n    def __init__(self, name=None, **kwargs): \r\n        super().__init__(name, **kwargs) \r\n  \r\n        self.link_extractor = LinkExtractor(unique=True) \r\n  \r\n    def parse(self, response: Response, **kwargs: Any) -> Any: \r\n        self.logger.info(\"Links spider\")\r\n        links = response.css('li.w-1\\/2 a::attr(href)') \r\n  \r\n        for link in links: \r\n            yield {\r\n                    \"url\": link.get(), \r\n                }"}
{"image_path": "data\\train\\00208.png", "code": "# This package will contain the spiders of your Scrapy project\r\n#\r\n# Please refer to the documentation for information on how to create and manage\r\n# your spiders.\r\n"}
{"image_path": "data\\train\\00209.png", "code": "from typing import Any\r\nfrom scrapy import Spider\r\nfrom scrapy.http import Response\r\nfrom scrapy import Request\r\n# from slidesmodel.items import SlidesModelItem\r\nfrom scrapy.loader import ItemLoader\r\nfrom scrapy.utils.project import get_project_settings\r\nimport json\r\n\r\n\r\nclass SlidesGospider(Spider):\r\n    name: str = \"slides\"\r\n    \r\n    def __init__(self, name: str | None = None, **kwargs: Any):\r\n        super().__init__(name, **kwargs)\r\n        # self.start_urls: list[str] = self.load_start_urls()\r\n        self.start_urls: list[str] = [\r\n            \"https://slidesgo.com/food#rs=home\"\r\n        ]\r\n    \r\n    \r\n    def parse(self, response: Response, **kwargs: Any) -> Any:\r\n        self.logger.info(\"This is my first spider.\")\r\n        slide_links = response.css('div.theme_post a::attr(href)')\r\n        for slide_link in slide_links:\r\n            # title = problem_link.css('a::text')[0].get()\r\n            link = slide_link.get()\r\n            yield{\r\n                \"link\": link,\r\n            }\r\n            # yield Request(link, callback=self.parse_problem)\r\n        # for slide in slides:\r\n        #     loader: ItemLoader = ItemLoader(item=SlidesModelItem(), selector=slide)\r\n        #     loader.add_css(\"title\", \".item a::text\")\r\n        #     loader.add_css(\"category\", \".category::text\")\r\n        #     slide_item = loader.load_item()\r\n        #     link = slide.css(\".item a::attr(href)\").get()\r\n        #     self.logger.info(\"Parsing the slide\")\r\n        #     yield Request(link, callback=self.parse_slide, meta={\"slide_item\": slide_item})\r\n        \r\n"}
{"image_path": "data\\train\\00210.png", "code": "            \r\n    def parse_link(self, response: Response, **kwargs: Any) -> Any:\r\n        # slide_item = response.meta[\"slide_item\"]\r\n        # loader = ItemLoader(item=slide_item, response=response)\r\n        # loader.add_css(field_name=\"tags\", css=\".Sm-tags a.mr-2::text\")\r\n        # loader.add_css(field_name=\"description\", css=\".product-text p\")\r\n        # loader.add_css(field_name=\"slides_count\", css='h4 small::text')\r\n        # loader.add_css(field_name=\"colors\", css='li.color a::text')\r\n        # loader.add_css(field_name=\"image_urls\", css='a.preview-link img::attr(src)')\r\n        # add slide link\r\n        # yield loader.load_item()\r\n        categories: list[dict] = []\r\n        cats = response.css('span.cat-links a')\r\n        for cat in cats:\r\n            category = cat.css('::text').get()\r\n            category_link = cat.css('::attr(href)').get()\r\n            categories.append({\r\n                \"category\": category,\r\n                \"link\": category_link\r\n            })\r\n        \r\n        yield {\r\n            \"categories\": categories,\r\n            \"title\": response.css('h1::text').get(),\r\n            \"problem\": response.css('.post-content p').getall(),\r\n            \"io\": response.css('.io').get(),\r\n            \"solutions\": response.css('h2::text').getall(), \r\n            \"link\": response.url,\r\n            \"code\": response.css('.c-line').getall()\r\n        }"}
{"image_path": "data\\train\\00211.png", "code": "# This package will contain the spiders of your Scrapy project\r\n#\r\n# Please refer to the documentation for information on how to create and manage\r\n# your spiders.\r\n"}
{"image_path": "data\\train\\00212.png", "code": "from typing import Any\r\nfrom scrapy import Spider\r\nfrom scrapy.http import Response\r\nfrom scrapy.linkextractors import LinkExtractor \r\n\r\n\r\nclass SlidesLinkExtractor(Spider):\r\n    name: str = \"leetcode\"\r\n    \r\n    start_urls: list[str] = [\r\n        \"https://www.techiedelight.com/data-structures-and-algorithms-problems/\"\r\n    ]\r\n    \r\n    def __init__(self, name=None, **kwargs): \r\n        super().__init__(name, **kwargs) \r\n  \r\n        self.link_extractor = LinkExtractor(unique=True) \r\n  \r\n    def parse(self, response: Response, **kwargs: Any) -> Any: \r\n        links = self.link_extractor.extract_links(response) \r\n  \r\n        for link in links: \r\n            yield {\r\n                    \"url\": link.url, \r\n                    \"text\": link.text\r\n                }"}
{"image_path": "data\\train\\00213.png", "code": "from typing import Any\r\nfrom scrapy import Spider\r\nfrom scrapy.http import Response\r\nfrom scrapy import Request\r\n# from slidesmodel.items import SlidesModelItem\r\nfrom scrapy.loader import ItemLoader\r\nfrom scrapy.utils.project import get_project_settings\r\nimport json\r\n\r\n\r\nclass SlidesModelspider(Spider):\r\n    name: str = \"problems\"\r\n    \r\n    def __init__(self, name: str | None = None, **kwargs: Any):\r\n        super().__init__(name, **kwargs)\r\n        # self.start_urls: list[str] = self.load_start_urls()\r\n        self.start_urls: list[str] = [\r\n            \"https://www.techiedelight.com/data-structures-and-algorithms-problems/\"\r\n        ]\r\n    \r\n    \r\n    def parse(self, response: Response, **kwargs: Any) -> Any:\r\n        self.logger.info(\"This is my first spider.\")\r\n        problem_links = response.css('.post-problems li')\r\n        # from random import choices\r\n        # problem_links = choices(population=problem_links, k=100)\r\n        # for problem_link in problem_links:\r\n        #     # title = problem_link.css('a::text')[0].get()\r\n        #     link = problem_link.css('a::attr(href)')[0].get()\r\n        #     # yield{\r\n        #     #     \"link\": link,\r\n        #     #     \"problem\": problem\r\n        #     # }\r\n            # yield Request(link, callback=self.parse_problem)\r\n        link = \"https://www.techiedelight.com/single-source-shortest-paths-bellman-ford-algorithm/\"\r\n        yield Request(link, callback=self.parse_problem)\r\n        # for slide in slides:\r\n        #     loader: ItemLoader = ItemLoader(item=SlidesModelItem(), selector=slide)\r\n        #     loader.add_css(\"title\", \".item a::text\")\r\n        #     loader.add_css(\"category\", \".category::text\")\r\n"}
{"image_path": "data\\train\\00214.png", "code": "        #     slide_item = loader.load_item()\r\n        #     link = slide.css(\".item a::attr(href)\").get()\r\n        #     self.logger.info(\"Parsing the slide\")\r\n        #     yield Request(link, callback=self.parse_slide, meta={\"slide_item\": slide_item})\r\n        \r\n            \r\n    def parse_problem(self, response: Response, **kwargs: Any) -> Any:\r\n        # slide_item = response.meta[\"slide_item\"]\r\n        # loader = ItemLoader(item=slide_item, response=response)\r\n        # loader.add_css(field_name=\"tags\", css=\".Sm-tags a.mr-2::text\")\r\n        # loader.add_css(field_name=\"description\", css=\".product-text p\")\r\n        # loader.add_css(field_name=\"slides_count\", css='h4 small::text')\r\n        # loader.add_css(field_name=\"colors\", css='li.color a::text')\r\n        # loader.add_css(field_name=\"image_urls\", css='a.preview-link img::attr(src)')\r\n        # add slide link\r\n        # yield loader.load_item()\r\n        categories: list[dict] = []\r\n        cats = response.css('span.cat-links a')\r\n        for cat in cats:\r\n            category = cat.css('::text').get()\r\n            category_link = cat.css('::attr(href)').get()\r\n            categories.append({\r\n                \"category\": category,\r\n                \"link\": category_link\r\n            })\r\n        \r\n        yield {\r\n            \"categories\": categories,\r\n            \"title\": response.css('h1::text').get(),\r\n            # \"problem\": response.css('.post-content p').getall(),\r\n            \"conditions\": response.css('.post-content ol').get(),\r\n            # \"io\": response.css('.io').get(),\r\n            # \"solutions\": response.css('h2::text').getall(), \r\n            # \"link\": response.url,\r\n            # \"code\": response.css('.c-line').getall(),\r\n            \"image\": response.css('.post-content p img::attr(src)').get()\r\n        }"}
{"image_path": "data\\train\\00215.png", "code": "\"\"\"This module declares the extensions used by the application.\"\"\"\r\nfrom flask_bcrypt import Bcrypt\r\nfrom flask_cors import CORS\r\nfrom flask_login import LoginManager\r\nfrom flask_mail import Mail\r\nfrom flask_marshmallow import Marshmallow\r\nfrom flask_migrate import Migrate\r\nfrom flask_sqlalchemy import SQLAlchemy\r\n\r\ncors = CORS()\r\ndb = SQLAlchemy()\r\nmigrate = Migrate()\r\nma = Marshmallow()\r\nbcrypt = Bcrypt()\r\nlogin_manager = LoginManager()\r\nmail = Mail()\r\n"}
{"image_path": "data\\train\\00216.png", "code": "import os\r\nfrom .config import Config\r\nfrom flask import Flask\r\n\r\n\r\ndef set_configuration(app: Flask):\r\n    \"\"\"Set the application configuration.\r\n\r\n    The application configuration will depend on the\r\n    environment i.e Test, Development, Staging or Production.\r\n\r\n    Parameters\r\n    ----------\r\n    app: flask.Flask\r\n        A flask app instance\r\n\r\n    Returns\r\n    -------\r\n    bool:\r\n        Whether the config was set up successfully.\r\n    \"\"\"\r\n    config_name = os.environ.get(\"FLASK_ENV\")\r\n    app.config.from_object(Config[config_name])\r\n\r\n    return True"}
{"image_path": "data\\train\\00217.png", "code": "from .set_config import set_configuration"}
{"image_path": "data\\train\\00218.png", "code": "\"\"\"This module declares the app configuration.\r\n\r\nThe classes include:\r\n\r\nBaseConfig:\r\n    Has all the configurations shared by all the environments.\r\n\r\n\"\"\"\r\nimport os\r\n\r\nfrom dotenv import load_dotenv\r\n\r\nload_dotenv()\r\n\r\n\r\nclass BaseConfig:\r\n    \"\"\"Base configuration.\"\"\"\r\n\r\n    DEBUG = True\r\n    TESTING = False\r\n    SECRET_KEY = os.environ.get(\r\n        \"SECRET_KEY\", \"df0331cefc6c2b9a5d0208a726a5d1c0fd37324feba25506\"\r\n    )\r\n    POSTGRES_HOST = os.environ[\"POSTGRES_HOST\"]\r\n    POSTGRES_DB = os.environ[\"POSTGRES_DB\"]\r\n    POSTGRES_PORT = os.environ[\"POSTGRES_PORT\"]\r\n    POSTGRES_USER = os.environ[\"POSTGRES_USER\"]\r\n    POSTGRES_PASSWORD = os.environ[\"POSTGRES_PASSWORD\"]\r\n    # db_conn_string = f\"postgresql://{POSTGRES_USER}:{POSTGRES_PASSWORD}@{POSTGRES_HOST}:{POSTGRES_PORT}/{POSTGRES_DB}\"\r\n    db_conn_string = os.environ.get(\"SQLALCHEMY_DATABASE_URI\", 'sqlite:///./oryks.db')\r\n    SQLALCHEMY_DATABASE_URI = db_conn_string\r\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\r\n    MAIL_USERNAME = os.environ[\"MAIL_USERNAME\"]\r\n    MAIL_PASSWORD = os.environ[\"MAIL_PASSWORD\"]\r\n    MAIL_SERVER = os.environ[\"MAIL_SERVER\"]\r\n    MAIL_PORT = os.environ[\"MAIL_PORT\"]\r\n    MAIL_USE_SSL = os.environ[\"MAIL_USE_SSL\"]\r\n    MAIL_DEFAULT_SENDER = os.environ[\"MAIL_DEFAULT_SENDER\"]\r\n    PASSWORD_RESET_SALT = os.environ.get(\"PASSWORD_RESET_SALT\", \"salt\")\r\n    GOOGLE_OAUTH_CLIENT_ID = os.environ.get(\"GOOGLE_OAUTH_CLIENT_ID\")\r\n"}
{"image_path": "data\\train\\00219.png", "code": "    GOOGLE_OAUTH_CLIENT_SECRET = os.environ.get(\"GOOGLE_OAUTH_CLIENT_SECRET\")\r\n    OAUTHLIB_INSECURE_TRANSPORT = os.environ.get(\"OAUTHLIB_INSECURE_TRANSPORT\")\r\n    OAUTHLIB_RELAX_TOKEN_SCOPE = os.environ.get(\"OAUTHLIB_RELAX_TOKEN_SCOPE \" )\r\n\r\n\r\nclass DevelopmentConfig(BaseConfig):\r\n    \"\"\"Development confuguration.\"\"\"\r\n\r\n    DEBUG = True\r\n    TESTING = False\r\n    SECRET_KEY = os.environ.get(\r\n        \"SECRET_KEY\", \"df0331cefc6c2b9a5d0208a726a5d1c0fd37324feba25506\"\r\n    )\r\n\r\n\r\nclass TestingConfig(BaseConfig):\r\n    \"\"\"Testing configuration.\"\"\"\r\n\r\n    TESTING = True\r\n    SECRET_KEY = os.environ.get(\"SECRET_KEY\", \"secret-key\")\r\n\r\n\r\nclass ProductionConfig(BaseConfig):\r\n    \"\"\"Production configuration.\"\"\"\r\n\r\n    TESTING = False\r\n    SECRET_KEY = os.environ.get(\"SECRET_KEY\", \"secret-key\")\r\n\r\n\r\nConfig = {\r\n    \"development\": DevelopmentConfig,\r\n    \"test\": TestingConfig,\r\n    \"production\": ProductionConfig,\r\n    \"staging\": ProductionConfig,\r\n}\r\n"}
{"image_path": "data\\train\\00220.png", "code": "from flask import Flask\r\nfrom .home import home\r\nfrom .oauth import auth, google_blueprint\r\n\r\n\r\ndef register_blueprints(app: Flask) -> bool:\r\n    \"\"\"Register the application blueprints.\r\n\r\n    Parameters\r\n    ----------\r\n    app: flask.Flask\r\n        A flask app instance\r\n\r\n    Returns\r\n    -------\r\n    bool:\r\n        Whether all the blueprints were registered.\r\n    \"\"\"\r\n    app.register_blueprint(home)\r\n    app.register_blueprint(auth, url_prefix=\"/auth\")\r\n    app.register_blueprint(google_blueprint, url_prefix=\"/login\")\r\n    return True"}
{"image_path": "data\\train\\00221.png", "code": "from .register_blueprints import register_blueprints"}
{"image_path": "data\\train\\00222.png", "code": "\"\"\"This module declares application exceptions.\"\"\"\r\n\r\n\r\nclass DatabaseNotConnectedException(Exception):\r\n    \"\"\"Raised when the database is not connected.\"\"\"\r\n"}
{"image_path": "data\\train\\00223.png", "code": "import os\r\nfrom .config import Config\r\nfrom flask import Flask\r\n\r\n\r\ndef set_configuration(app: Flask):\r\n    \"\"\"Set the application configuration.\r\n\r\n    The application configuration will depend on the\r\n    environment i.e Test, Development, Staging or Production.\r\n\r\n    Parameters\r\n    ----------\r\n    app: flask.Flask\r\n        A flask app instance\r\n\r\n    Returns\r\n    -------\r\n    bool:\r\n        Whether the config was set up successfully.\r\n    \"\"\"\r\n    config_name = os.environ.get(\"FLASK_ENV\")\r\n    app.config.from_object(Config[config_name])\r\n\r\n    return True"}
{"image_path": "data\\train\\00224.png", "code": "from .set_config import set_configuration"}
{"image_path": "data\\train\\00225.png", "code": "\"\"\"This module declares the app configuration.\r\n\r\nThe classes include:\r\n\r\nBaseConfig:\r\n    Has all the configurations shared by all the environments.\r\n\r\n\"\"\"\r\nimport os\r\n\r\nfrom dotenv import load_dotenv\r\n\r\nload_dotenv()\r\n\r\n\r\nclass BaseConfig:\r\n    \"\"\"Base configuration.\"\"\"\r\n\r\n    DEBUG = True\r\n    TESTING = False\r\n    SECRET_KEY = os.environ.get(\r\n        \"SECRET_KEY\", \"df0331cefc6c2b9a5d0208a726a5d1c0fd37324feba25506\"\r\n    )\r\n\r\n\r\nclass DevelopmentConfig(BaseConfig):\r\n    \"\"\"Development confuguration.\"\"\"\r\n\r\n    DEBUG = True\r\n    TESTING = False\r\n    SECRET_KEY = os.environ.get(\r\n        \"SECRET_KEY\", \"df0331cefc6c2b9a5d0208a726a5d1c0fd37324feba25506\"\r\n    )\r\n\r\n\r\nclass TestingConfig(BaseConfig):\r\n    \"\"\"Testing configuration.\"\"\"\r\n\r\n    TESTING = True\r\n    SECRET_KEY = os.environ.get(\"SECRET_KEY\", \"secret-key\")\r\n"}
{"image_path": "data\\train\\00226.png", "code": "\r\n\r\nclass ProductionConfig(BaseConfig):\r\n    \"\"\"Production configuration.\"\"\"\r\n\r\n    TESTING = False\r\n    SECRET_KEY = os.environ.get(\"SECRET_KEY\", \"secret-key\")\r\n\r\n\r\nConfig = {\r\n    \"development\": DevelopmentConfig,\r\n    \"test\": TestingConfig,\r\n    \"production\": ProductionConfig,\r\n    \"staging\": ProductionConfig,\r\n}\r\n"}
{"image_path": "data\\train\\00227.png", "code": "from flask import Flask\r\nfrom .home import code\r\n\r\n\r\ndef register_blueprints(app: Flask) -> bool:\r\n    \"\"\"Register the application blueprints.\r\n\r\n    Parameters\r\n    ----------\r\n    app: flask.Flask\r\n        A flask app instance\r\n\r\n    Returns\r\n    -------\r\n    bool:\r\n        Whether all the blueprints were registered.\r\n    \"\"\"\r\n    app.register_blueprint(code)\r\n    return True"}
{"image_path": "data\\train\\00228.png", "code": "from .register_blueprints import register_blueprints"}
{"image_path": "data\\train\\00229.png", "code": "from typing import Any\r\nfrom scrapy import Spider\r\nfrom scrapy.http import Response\r\nfrom scrapy import Request\r\nfrom slidesmodel.items import SlidesModelItem\r\nfrom scrapy.loader import ItemLoader\r\nfrom scrapy.utils.project import get_project_settings\r\nimport json\r\n\r\n\r\nclass SlidesModelspider(Spider):\r\n    name: str = \"slides\"\r\n    \r\n    def __init__(self, name: str | None = None, **kwargs: Any):\r\n        super().__init__(name, **kwargs)\r\n        self.start_urls: list[str] = self.load_start_urls()\r\n        # self.start_urls: list[str] = [\r\n        #     \"https://slidemodel.com/templates/tag/process-flow/\"\r\n        # ]\r\n    \r\n    @staticmethod\r\n    def load_start_urls() -> list:\r\n        settings: dict = get_project_settings()\r\n        links_path: str = settings.get(\"START_URLS_PATH\")\r\n        with open(links_path, \"r\") as f:\r\n            start_urls_dict: list[dict] = json.load(f)\r\n        return [\r\n            link.get(\"url\") for link in start_urls_dict\r\n        ]\r\n    \r\n    def parse(self, response: Response, **kwargs: Any) -> Any:\r\n        self.logger.info(\"This is my first spider.\")\r\n        slides = response.xpath(\"//div[@class='col-lg-3 col-sm-6 mt-4']\")\r\n        for slide in slides:\r\n            loader: ItemLoader = ItemLoader(item=SlidesModelItem(), selector=slide)\r\n            loader.add_css(\"title\", \".item a::text\")\r\n            loader.add_css(\"category\", \".category::text\")\r\n            slide_item = loader.load_item()\r\n            link = slide.css(\".item a::attr(href)\").get()\r\n            self.logger.info(\"Parsing the slide\")\r\n"}
{"image_path": "data\\train\\00230.png", "code": "            yield Request(link, callback=self.parse_slide, meta={\"slide_item\": slide_item})\r\n        \r\n        # next_page = response.css('a.next.page-numbers::attr(href)').get()\r\n        # if next_page and int(next_page.split('/')[-2]) < 2:\r\n        #     self.logger.warning(f\"Crawling page number %d\", int(next_page.split('/')[-2]))\r\n        #     yield Request(next_page, callback=self.parse)\r\n        next_page = response.css('a.next.page-numbers::attr(href)').get()\r\n        if next_page:\r\n            self.logger.warning(f\"Crawling page number %d\", int(next_page.split('/')[-2]))\r\n            yield Request(next_page, callback=self.parse)\r\n            \r\n    def parse_slide(self, response: Response, **kwargs: Any) -> Any:\r\n        slide_item = response.meta[\"slide_item\"]\r\n        loader = ItemLoader(item=slide_item, response=response)\r\n        loader.add_css(field_name=\"tags\", css=\".Sm-tags a.mr-2::text\")\r\n        loader.add_css(field_name=\"description\", css=\".product-text p\")\r\n        loader.add_css(field_name=\"slides_count\", css='h4 small::text')\r\n        loader.add_css(field_name=\"colors\", css='li.color a::text')\r\n        loader.add_css(field_name=\"image_urls\", css='a.preview-link img::attr(src)')\r\n        # add slide link\r\n        yield loader.load_item()"}
{"image_path": "data\\train\\00231.png", "code": "# This package will contain the spiders of your Scrapy project\r\n#\r\n# Please refer to the documentation for information on how to create and manage\r\n# your spiders.\r\n"}
{"image_path": "data\\train\\00232.png", "code": "from typing import Any\r\nfrom scrapy import Spider\r\nfrom scrapy.http import Response\r\nfrom scrapy.linkextractors import LinkExtractor \r\n\r\n\r\nclass SlidesLinkExtractor(Spider):\r\n    name: str = \"links-extractor\"\r\n    \r\n    start_urls: list[str] = [\r\n        \"https://slidemodel.com/templates/\"\r\n    ]\r\n    \r\n    def __init__(self, name=None, **kwargs): \r\n        super().__init__(name, **kwargs) \r\n  \r\n        self.link_extractor = LinkExtractor(unique=True) \r\n  \r\n    def parse(self, response: Response, **kwargs: Any) -> Any: \r\n        links = self.link_extractor.extract_links(response) \r\n  \r\n        for link in links: \r\n            if \"tag\" in link.url:\r\n                yield {\r\n                        \"url\": link.url, \r\n                        \"text\": link.text\r\n                    }"}
{"image_path": "data\\train\\00233.png", "code": "from .extensions import drive_client, gslide_client, youtube_client"}
{"image_path": "data\\train\\00234.png", "code": "from .helpers import create_gslide_client, create_drive_client\r\nfrom typing import Any\r\nfrom .helpers import get_youtube_client\r\nfrom ..libraries.youtube import YouTube\r\n\r\n\r\ngslide_client: Any = create_gslide_client()\r\ndrive_client: Any = create_drive_client()\r\nyoutube_client: YouTube = get_youtube_client()\r\n\r\n\r\n\r\n"}
{"image_path": "data\\train\\00235.png", "code": "from ..libraries.oryks_google_oauth import (\r\n    GoogleSlidesScope, GoogleOAuth, GoogleDirectories, GoogleDriveScopes\r\n)\r\nfrom ..libraries.youtube import YouTube\r\nfrom typing import Optional, Any\r\n\r\n\r\ndef create_gslide_client() -> Any:\r\n    secrets_file: str = \"/home/lyle/oryks/backend/api/libraries/slide.json\"\r\n    scopes: list[str] = [\r\n        GoogleSlidesScope.slides.value,\r\n        GoogleSlidesScope.drive.value\r\n    ]\r\n    api_service_name: str = \"slides\"\r\n    api_version: str = \"v1\"\r\n    credentials_dir: str = GoogleDirectories.slides.value\r\n    credentials_file_name: Optional[str] = 'credentials.json'\r\n\r\n    auth: GoogleOAuth = GoogleOAuth(\r\n        secrets_file=secrets_file,\r\n        scopes=scopes,\r\n        api_service_name=api_service_name,\r\n        api_version=api_version,\r\n        credentials_dir=credentials_dir,\r\n        credentials_file_name=credentials_file_name\r\n    )\r\n\r\n    gslides_client = auth.authenticate_google_server()\r\n    return gslides_client\r\n\r\n\r\ndef create_drive_client() -> Any:\r\n    secrets_file: str = \"/home/lyle/oryks/backend/api/libraries/drive.json\"\r\n    scopes: list[str] = [\r\n        GoogleDriveScopes.metadata.value,\r\n        GoogleDriveScopes.drive.value,\r\n        GoogleDriveScopes.files.value\r\n    ]\r\n    api_service_name: str = \"drive\"\r\n    api_version: str = \"v3\"\r\n"}
{"image_path": "data\\train\\00236.png", "code": "    credentials_dir: str = GoogleDirectories.drive.value\r\n    credentials_file_name: Optional[str] = 'credentials.json'\r\n\r\n    auth: GoogleOAuth = GoogleOAuth(\r\n        secrets_file=secrets_file,\r\n        scopes=scopes,\r\n        api_service_name=api_service_name,\r\n        api_version=api_version,\r\n        credentials_dir=credentials_dir,\r\n        credentials_file_name=credentials_file_name\r\n    )\r\n\r\n    drive_client = auth.authenticate_google_server()\r\n    return drive_client\r\n\r\n\r\ndef get_youtube_client() -> YouTube:\r\n    client_secrets_file: str = \"/home/lyle/oryks/backend/api/libraries/youtube.json\"\r\n    youtube: YouTube = YouTube(client_secret_file=client_secrets_file)\r\n    return youtube"}
{"image_path": "data\\train\\00237.png", "code": "from .oryks_google_oauth import GoogleSlidesScope, GoogleOAuth, GoogleDirectories\r\nfrom typing import Optional\r\nfrom .ml import AnalyzedVideo, analayze_video, create_presentation\r\nfrom .ml.slide_requests import create_slide\r\n\r\nsecrets_file: str = \"/home/lyle/oryks/backend/api/libraries/slide.json\"\r\nscopes: list[str] = [\r\n    GoogleSlidesScope.slides.value,\r\n    GoogleSlidesScope.drive.value\r\n]\r\napi_service_name: str = \"slides\"\r\napi_version: str = \"v1\"\r\ncredentials_dir: str = GoogleDirectories.slides.value\r\ncredentials_file_name: Optional[str] = 'credentials.json'\r\n\r\nauth: GoogleOAuth = GoogleOAuth(\r\n    secrets_file=secrets_file,\r\n    scopes=scopes,\r\n    api_service_name=api_service_name,\r\n    api_version=api_version,\r\n    credentials_dir=credentials_dir\r\n)\r\n\r\n# slide_client = auth.authenticate_google_server()\r\n\r\n# video_transcript: str = \"\"\r\n# analyzed_video: AnalyzedVideo = analayze_video(video_transcript=video_transcript)\r\n# presentation_name: str = \"YouTube Video\"\r\n# response: dict = create_presentation(presentation_name=presentation_name, \r\n#                                      slide_client=slide_client, analyzed_video=analyzed_video)\r\n# presentation_id: str = \"1UutpJTI9VOp7u_5iBGCHnKV-YwljkV61HYrrvJMyVAg\"\r\n# response: dict = create_slide(presentation_id=presentation_id, slide_client=slide_client)\r\n\r\nfrom .youtube_helper import main\r\n\r\nmain()\r\n"}
{"image_path": "data\\train\\00238.png", "code": "from typing import Any\r\nimport json\r\nfrom googleapiclient.errors import HttpError\r\n\r\n\r\ndef get_presentation(presentation_id: str, slide_client: Any) -> Any:\r\n    presentation = (\r\n        slide_client.presentations().get(presentationId=presentation_id).execute()\r\n    )\r\n    return presentation\r\n\r\n\r\ndef get_slides(presentation: Any) -> Any:\r\n    slides = presentation.get(\"slides\")\r\n    return slides\r\n\r\n\r\ndef create_blank_presentation(title: str, slide_client: Any) -> dict:\r\n    body: dict = {\"title\": title}\r\n    presentation = slide_client.presentations().create(body=body).execute()\r\n    print(f\"Created blank presentation with the id: {presentation.get('presentationId')}\")\r\n    presentation_name: str = f\"{title.casefold().strip().replace(' ', '_')}.json\"\r\n    with open(presentation_name, \"w\") as f:\r\n        json.dump(presentation, f)\r\n    return presentation\r\n    \r\n\r\ndef create_slide(presentation_id: str, page_id: str, slide_client: Any) -> dict:\r\n    create_slides_request = [\r\n        {\r\n            \"createSlide\": {\r\n                \"objectId\": page_id,\r\n                \"insertionIndex\": \"1\",\r\n                \"slideLayoutReference\": {\r\n                    \"predefinedLayout\": \"TITLE_AND_TWO_COLUMNS\"\r\n                }\r\n            }\r\n        }\r\n    ]\r\n    request_body = {\r\n"}
{"image_path": "data\\train\\00239.png", "code": "        \"requests\": create_slides_request\r\n    }\r\n    response = (\r\n        slide_client.presentations()\r\n        .batchUpdate(presentationId=presentation_id, body=request_body)\r\n        .execute()\r\n    )\r\n    create_slide_response = response.get(\"replies\")[0].get(\"createSlide\")\r\n    print(f\"Created slide with ID:{(create_slide_response.get('objectId'))}\")\r\n    slide_name: str = f\"{page_id.casefold().strip().replace(' ', '_')}.json\"\r\n    with open(slide_name, \"w\") as f:\r\n        json.dump(response, f)\r\n    return response\r\n\r\n\r\ndef create_textbox_with_text(presentation_id: str, page_id: str, slide_client: Any) -> dict:\r\n  try:\r\n    # Create a new square textbox, using the supplied element ID.\r\n    element_id = \"MyTextBox_10\"\r\n    pt350 = {\"magnitude\": 350, \"unit\": \"PT\"}\r\n    requests = [\r\n        {\r\n            \"createShape\": {\r\n                \"objectId\": element_id,\r\n                \"shapeType\": \"TEXT_BOX\",\r\n                \"elementProperties\": {\r\n                    \"pageObjectId\": page_id,\r\n                    \"size\": {\"height\": pt350, \"width\": pt350},\r\n                    \"transform\": {\r\n                        \"scaleX\": 1,\r\n                        \"scaleY\": 1,\r\n                        \"translateX\": 350,\r\n                        \"translateY\": 100,\r\n                        \"unit\": \"PT\",\r\n                    },\r\n                },\r\n            }\r\n        },\r\n        # Insert text into the box, using the supplied element ID.\r\n        {\r\n"}
{"image_path": "data\\train\\00240.png", "code": "            \"insertText\": {\r\n                \"objectId\": element_id,\r\n                \"insertionIndex\": 0,\r\n                \"text\": \"New Box Text Inserted!\",\r\n            }\r\n        },\r\n    ]\r\n\r\n    # Execute the request.\r\n    body = {\"requests\": requests}\r\n    response = (\r\n        slide_client.presentations()\r\n        .batchUpdate(presentationId=presentation_id, body=body)\r\n        .execute()\r\n    )\r\n    create_shape_response = response.get(\"replies\")[0].get(\"createShape\")\r\n    print(f\"Created textbox with ID:{(create_shape_response.get('objectId'))}\")\r\n  except HttpError as error:\r\n    print(f\"An error occurred: {error}\")\r\n\r\n    return error\r\n\r\n  return response\r\n\r\n\r\ndef create_image(presentation_id: str, page_id: str, slide_client: Any):\r\n  try:\r\n    IMAGE_URL = (\r\n        \"https://www.google.com/images/branding/\"\r\n        \"googlelogo/2x/googlelogo_color_272x92dp.png\"\r\n    )\r\n    # pylint: disable=invalid-name\r\n    requests = []\r\n    image_id = \"MyImage_11\"\r\n    emu4M = {\"magnitude\": 4000000, \"unit\": \"EMU\"}\r\n    requests.append(\r\n        {\r\n            \"createImage\": {\r\n                \"objectId\": image_id,\r\n                \"url\": IMAGE_URL,\r\n"}
{"image_path": "data\\train\\00241.png", "code": "                \"elementProperties\": {\r\n                    \"pageObjectId\": page_id,\r\n                    \"size\": {\"height\": emu4M, \"width\": emu4M},\r\n                    \"transform\": {\r\n                        \"scaleX\": 1,\r\n                        \"scaleY\": 1,\r\n                        \"translateX\": 100000,\r\n                        \"translateY\": 100000,\r\n                        \"unit\": \"EMU\",\r\n                    },\r\n                },\r\n            }\r\n        }\r\n    )\r\n\r\n    # Execute the request.\r\n    body = {\"requests\": requests}\r\n    response = (\r\n        slide_client.presentations()\r\n        .batchUpdate(presentationId=presentation_id, body=body)\r\n        .execute()\r\n    )\r\n    create_image_response = response.get(\"replies\")[0].get(\"createImage\")\r\n    print(f\"Created image with ID: {(create_image_response.get('objectId'))}\")\r\n\r\n    return response\r\n  except HttpError as error:\r\n    print(f\"An error occurred: {error}\")\r\n    print(\"Images not created\")\r\n    return error"}
{"image_path": "data\\train\\00242.png", "code": "from .youtube import YouTube\r\nfrom .youtube.schemas import YouTubeListResponse, YouTubeResponse\r\nfrom .youtube.models import Video, Search, Playlist\r\nfrom os import path\r\nfrom langchain_core.language_models.base import BaseLanguageModel\r\nfrom langchain_openai import OpenAI\r\nfrom langchain_community.llms import Ollama\r\nfrom langchain_core.prompts import PromptTemplate\r\nfrom langchain_core.pydantic_v1 import BaseModel, Field\r\n# from pydantic import BaseModel, Field\r\nfrom langchain.output_parsers import PydanticOutputParser\r\n\r\nfrom .oryks_google_oauth import (\r\n    GoogleSlidesScope, GoogleOAuth, GoogleDirectories, GoogleDriveScopes\r\n)\r\nfrom typing import Optional, Any\r\nimport json\r\n\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\nopen_ai: BaseLanguageModel = OpenAI(temperature=0, api_key=api_key)\r\n\r\ngemma_2b: BaseLanguageModel = Ollama(model=\"gemma:2b\")\r\nllama_2b: BaseLanguageModel = Ollama(model=\"llama2\")\r\n\r\ndef create_gslide_client() -> Any:\r\n    secrets_file: str = \"/home/lyle/oryks/backend/api/libraries/slide.json\"\r\n    scopes: list[str] = [\r\n        GoogleSlidesScope.slides.value,\r\n        GoogleSlidesScope.drive.value\r\n    ]\r\n    api_service_name: str = \"slides\"\r\n    api_version: str = \"v1\"\r\n    credentials_dir: str = GoogleDirectories.slides.value\r\n    credentials_file_name: Optional[str] = 'credentials.json'\r\n\r\n    auth: GoogleOAuth = GoogleOAuth(\r\n        secrets_file=secrets_file,\r\n        scopes=scopes,\r\n        api_service_name=api_service_name,\r\n"}
{"image_path": "data\\train\\00243.png", "code": "        api_version=api_version,\r\n        credentials_dir=credentials_dir,\r\n        credentials_file_name=credentials_file_name\r\n    )\r\n\r\n    gslides_client = auth.authenticate_google_server()\r\n    return gslides_client\r\n\r\n\r\ndef create_drive_client() -> Any:\r\n    secrets_file: str = \"/home/lyle/oryks/backend/api/libraries/drive.json\"\r\n    scopes: list[str] = [\r\n        GoogleDriveScopes.metadata.value,\r\n        GoogleDriveScopes.drive.value,\r\n        GoogleDriveScopes.files.value\r\n    ]\r\n    api_service_name: str = \"drive\"\r\n    api_version: str = \"v3\"\r\n    credentials_dir: str = GoogleDirectories.drive.value\r\n    credentials_file_name: Optional[str] = 'credentials.json'\r\n\r\n    auth: GoogleOAuth = GoogleOAuth(\r\n        secrets_file=secrets_file,\r\n        scopes=scopes,\r\n        api_service_name=api_service_name,\r\n        api_version=api_version,\r\n        credentials_dir=credentials_dir,\r\n        credentials_file_name=credentials_file_name\r\n    )\r\n\r\n    drive_client = auth.authenticate_google_server()\r\n    return drive_client\r\n\r\n\r\ndef get_youtube_client() -> YouTube:\r\n    client_secrets_file: str = \"/home/lyle/oryks/backend/api/libraries/youtube.json\"\r\n    youtube: YouTube = YouTube(client_secret_file=client_secrets_file)\r\n    return youtube\r\n\r\nyoutube_client: YouTube = get_youtube_client()\r\n"}
{"image_path": "data\\train\\00244.png", "code": "\r\ndata_dir: str = \"/home/lyle/oryks/backend/api/libraries/data\"\r\ndescriptions_dir: str = path.join(data_dir, \"descriptions\")\r\nsegments_dir: str = path.join(data_dir, \"segments\")\r\n\r\nclass TimeStamp(BaseModel):\r\n    start_time: Optional[str] = Field(description=\"Start time\")\r\n    end_time: Optional[str] = Field(description=\"End time\")\r\n    title: Optional[str] = Field(description=\"The time stamp title\")\r\n    \r\nclass TimeStamps(BaseModel):\r\n    time_stamps: list[TimeStamp]\r\n\r\ndef save_description(description: str, video_id: str) -> None:\r\n    video_path: str = path.join(descriptions_dir, f\"{video_id}.txt\")\r\n    with open(video_path, \"w\", encoding=\"utf-8\") as f:\r\n        f.write(description)\r\n        \r\n        \r\ndef save_timestamps(timestamps: TimeStamps, video_id: str) -> None:\r\n    video_path: str = path.join(segments_dir, f\"{video_id}.json\")\r\n    with open(video_path, \"w\", encoding=\"utf-8\") as f:\r\n        json.dump(timestamps.dict(), f, indent=4)\r\n        \r\n        \r\ndef load_timestamps(video_id: str) -> TimeStamps:\r\n    video_path: str = path.join(segments_dir, f\"{video_id}.json\")\r\n    with open(video_path, \"r\", encoding=\"utf-8\") as f:\r\n        timestamps: TimeStamps = TimeStamps(**json.load(f))\r\n    return timestamps\r\n\r\n\r\ndef get_timestamps(video_id: str) -> TimeStamps:\r\n    video_path: str = path.join(segments_dir, f\"{video_id}.json\")\r\n    if not path.exists(video_path):\r\n        description: str = get_description(video_id=video_id)\r\n        timestamps: TimeStamps = get_video_segments(video_description=description)\r\n        save_timestamps(timestamps=timestamps, video_id=video_id)\r\n    else:\r\n        timestamps: TimeStamps = load_timestamps(video_id=video_id)\r\n"}
{"image_path": "data\\train\\00245.png", "code": "    return timestamps\r\n\r\ndef partition_video_segments(video_id: str) -> TimeStamps:\r\n    video_segments: TimeStamps = get_timestamps(video_id=video_id)\r\n    return video_segments\r\n        \r\ndef get_description(video_id: str) -> str:\r\n    video_path: str = path.join(descriptions_dir, f\"{video_id}.txt\")\r\n    if not path.exists(video_path):\r\n        description: str = download_description(video_id=video_id)\r\n        save_description(description=description, video_id=video_id)\r\n    else:\r\n        with open(video_path, \"r\", encoding=\"utf-8\") as f:\r\n            description: str = f.read()\r\n    return description\r\n\r\n\r\ndef download_description(video_id: str) -> None:\r\n    response: YouTubeListResponse = youtube_client.find_video_by_id(video_id=video_id)\r\n    video: Video = response.items[0]\r\n    description: str = video.snippet.description\r\n    return description\r\n    \r\n    \r\nparser = PydanticOutputParser(pydantic_object=TimeStamps)\r\n\r\nsegment_str: str = (\"\"\"Extract the time stamps and their titles from the following text. Only\"\"\" \r\n                    \"\"\" include valid time stamps.\\n{format_instructions}\\ntext: ```{text}```\"\"\"\r\n)\r\n\r\ndef get_video_segments(video_description: str, segment_str: str = segment_str, \r\n                       llm: BaseLanguageModel = gemma_2b):\r\n    template: PromptTemplate = PromptTemplate(template=segment_str, \r\n                    input_variables=[\"text\"],\r\n                    partial_variables={\"format_instructions\": parser.get_format_instructions()}\r\n                                              )\r\n    chain = template | llm | parser\r\n    inputs: dict[str, str] = {\r\n        \"text\": video_description\r\n    }\r\n"}
{"image_path": "data\\train\\00246.png", "code": "    res: TimeStamps = chain.invoke(inputs)\r\n    # res.time_stamps.sort(key=lambda x: x.start_time)\r\n    return res\r\n\r\n\r\nids: dict[str, str] = {\r\n    \"set_mismatch\": \"d-ulaeRBA64\",\r\n    \"leaf_similar_tree\": \"Nr8dbnL0_cM\",\r\n    \"mk_vld_par\": \"mgQ4O9iUEbg\",\r\n    \"pams\": \"kWhy4ZUBdOY\",\r\n    \"sapltk\": \"Cg6_nF7YIks\",\r\n    \"smallest_str_leaf\": \"UvdWfxQ_ZDs\",\r\n    \"sub_arr_k_diff_ints\": \"etI6HqWVa8U\",\r\n    \"remv_nodes_lnkd_lst\": \"y783sRTezDg\",\r\n    \"rvl_card_inc_order\": \"i2QrUdwWlak\",\r\n    \"rmv_dup_srt_arr_2\": \"ycAq8iqh0TI\",\r\n    \"town_jdg\": \"QiGaxdUINJ8\",\r\n    \"rang_sm_bst\": \"uLVG45n4Sbg\",\r\n    \"artmtc_slcs_2\": \"YIMwwT9JdIE\",\r\n    \"lst_unq_ints_k_rmvl\": \"Nsp_ta7SlEk\",\r\n    \"all_ppl_scrt\": \"1XujGRSU1bQ\",\r\n    \"stdnts_mss_lnch\": \"d_cvtFwnOZg\",\r\n}\r\nvideo_id: str = ids[\"stdnts_mss_lnch\"]\r\n\r\nclass Segment(BaseModel):\r\n    time_stamp: str = Field(description=\"The time stamp\")\r\n    title: str = Field(description=\"The time stamp title\")\r\n    \r\ngemma_parser = PydanticOutputParser(pydantic_object=Segment)\r\n\r\nsegment_str_gemma: str = (\"\"\"Extract all the time stamps and their titles from the following text. Only\"\"\" \r\n                    \"\"\" include valid time stamps.Return a json string only with the keys \"\"\"\r\n                    \"\"\"```time_stamp``` and ```title```.\\ntext: ```{text}```\"\"\"\r\n)\r\n\r\nsegment_str_gemma_v1: str = (\"\"\"Extract all the start time stamps, end time stamps and their titles from the following text. Only\"\"\" \r\n                    \"\"\" include valid time stamps.Return a json string only with the keys \"\"\"\r\n                    \"\"\"```start_time```, ```end_time``` and ```title```.\\ntext: ```{text}```\"\"\"\r\n)\r\n"}
{"image_path": "data\\train\\00247.png", "code": "def gemma_extraction(video_id: str):\r\n    description: str = get_description(video_id=video_id)\r\n    template: PromptTemplate = PromptTemplate(template=segment_str_gemma, \r\n                    input_variables=[\"text\"]\r\n                                              )\r\n    chain = template | llama_2b \r\n    inputs: dict[str, str] = {\r\n        \"text\": description\r\n    }\r\n    res = chain.invoke(inputs)\r\n    print(res)\r\n    \r\n    \r\ndef get_channel_id(channel_name: str, youtube: YouTube = get_youtube_client()) -> str:\r\n    response: YouTubeResponse = youtube.find_channel_by_name(display_name=channel_name)\r\n    search_result: Search = response.items[0]\r\n    channel_id: str = search_result.channel_id\r\n    return channel_id\r\n\r\ndef get_channel_playlists(channel_name: str, youtube: YouTube = get_youtube_client()) -> list[str]:\r\n    # channel_id: str = get_channel_id(channel_name=channel_name, youtube=youtube)\r\n    channel_id: str = \"UC_mYaQAE6-71rjSN6CeCA-g\"\r\n    response: YouTubeListResponse = youtube.find_channel_playlists(channel_id=channel_id)\r\n    playlists: list[Playlist] = response.items\r\n    playlist_ids: list[str] = [playlist.id for playlist in playlists]\r\n    return playlist_ids\r\n    \r\n\r\ndef main(video_id: str = video_id):\r\n    # output: TimeStamps = partition_video_segments(video_id=video_id)\r\n    # print(output)    \r\n    # gemma_extraction(video_id=video_id)\r\n    channel_name: str = \"neetcode\"\r\n    playlist_ids: list[str] = get_channel_playlists(channel_name=channel_name)\r\n    print(playlist_ids)\r\n    \r\n    "}
{"image_path": "data\\train\\00248.png", "code": "import distutils.spawn\r\nimport os\r\nimport re\r\nimport shlex\r\nimport subprocess\r\nimport sys\r\n\r\nfrom setuptools import find_packages\r\nfrom setuptools import setup\r\n\r\n\r\ndef get_version():\r\n    filename = \"labelme/__init__.py\"\r\n    with open(filename) as f:\r\n        match = re.search(r\"\"\"^__version__ = ['\"]([^'\"]*)['\"]\"\"\", f.read(), re.M)\r\n    if not match:\r\n        raise RuntimeError(\"{} doesn't contain __version__\".format(filename))\r\n    version = match.groups()[0]\r\n    return version\r\n\r\n\r\ndef get_install_requires():\r\n    install_requires = [\r\n        \"gdown\",\r\n        \"imgviz>=1.7.5\",\r\n        \"matplotlib\",\r\n        \"natsort>=7.1.0\",\r\n        \"numpy\",\r\n        \"onnxruntime>=1.14.1,!=1.16.0\",\r\n        \"Pillow>=2.8\",\r\n        \"PyYAML\",\r\n        \"qtpy!=1.11.2\",\r\n        \"scikit-image\",\r\n        \"termcolor\",\r\n    ]\r\n\r\n    # Find python binding for qt with priority:\r\n    # PyQt5 -> PySide2\r\n    # and PyQt5 is automatically installed on Python3.\r\n    QT_BINDING = None\r\n"}
{"image_path": "data\\train\\00249.png", "code": "\r\n    try:\r\n        import PyQt5  # NOQA\r\n\r\n        QT_BINDING = \"pyqt5\"\r\n    except ImportError:\r\n        pass\r\n\r\n    if QT_BINDING is None:\r\n        try:\r\n            import PySide2  # NOQA\r\n\r\n            QT_BINDING = \"pyside2\"\r\n        except ImportError:\r\n            pass\r\n\r\n    if QT_BINDING is None:\r\n        # PyQt5 can be installed via pip for Python3\r\n        # 5.15.3, 5.15.4 won't work with PyInstaller\r\n        install_requires.append(\"PyQt5!=5.15.3,!=5.15.4\")\r\n        QT_BINDING = \"pyqt5\"\r\n\r\n    del QT_BINDING\r\n\r\n    if os.name == \"nt\":  # Windows\r\n        install_requires.append(\"colorama\")\r\n\r\n    return install_requires\r\n\r\n\r\ndef get_long_description():\r\n    with open(\"README.md\") as f:\r\n        long_description = f.read()\r\n    try:\r\n        # when this package is being released\r\n        import github2pypi\r\n\r\n        return github2pypi.replace_url(\r\n            slug=\"wkentaro/labelme\", content=long_description, branch=\"main\"\r\n        )\r\n"}
{"image_path": "data\\train\\00250.png", "code": "    except ImportError:\r\n        # when this package is being installed\r\n        return long_description\r\n\r\n\r\ndef main():\r\n    version = get_version()\r\n\r\n    if sys.argv[1] == \"release\":\r\n        try:\r\n            import github2pypi  # NOQA\r\n        except ImportError:\r\n            print(\r\n                \"Please install github2pypi\\n\\n\\tpip install github2pypi\\n\",\r\n                file=sys.stderr,\r\n            )\r\n            sys.exit(1)\r\n\r\n        if not distutils.spawn.find_executable(\"twine\"):\r\n            print(\r\n                \"Please install twine:\\n\\n\\tpip install twine\\n\",\r\n                file=sys.stderr,\r\n            )\r\n            sys.exit(1)\r\n\r\n        commands = [\r\n            \"git push origin main\",\r\n            \"git tag v{:s}\".format(version),\r\n            \"git push origin --tags\",\r\n            \"python setup.py sdist\",\r\n            \"twine upload dist/labelme-{:s}.tar.gz\".format(version),\r\n        ]\r\n        for cmd in commands:\r\n            print(\"+ {:s}\".format(cmd))\r\n            subprocess.check_call(shlex.split(cmd))\r\n        sys.exit(0)\r\n\r\n    setup(\r\n        name=\"labelme\",\r\n        version=version,\r\n"}
{"image_path": "data\\train\\00251.png", "code": "        packages=find_packages(),\r\n        description=\"Image Polygonal Annotation with Python\",\r\n        long_description=get_long_description(),\r\n        long_description_content_type=\"text/markdown\",\r\n        author=\"Kentaro Wada\",\r\n        author_email=\"www.kentaro.wada@gmail.com\",\r\n        url=\"https://github.com/wkentaro/labelme\",\r\n        install_requires=get_install_requires(),\r\n        license=\"GPLv3\",\r\n        keywords=\"Image Annotation, Machine Learning\",\r\n        classifiers=[\r\n            \"Development Status :: 5 - Production/Stable\",\r\n            \"Intended Audience :: Developers\",\r\n            \"Intended Audience :: Science/Research\",\r\n            \"Natural Language :: English\",\r\n            \"Operating System :: OS Independent\",\r\n            \"Programming Language :: Python\",\r\n            \"Programming Language :: Python :: 3.5\",\r\n            \"Programming Language :: Python :: 3.6\",\r\n            \"Programming Language :: Python :: 3.7\",\r\n            \"Programming Language :: Python :: 3.8\",\r\n            \"Programming Language :: Python :: 3.9\",\r\n            \"Programming Language :: Python :: 3 :: Only\",\r\n        ],\r\n        package_data={\"labelme\": [\"icons/*\", \"config/*.yaml\", \"translate/*\"]},\r\n        entry_points={\r\n            \"console_scripts\": [\r\n                \"labelme=labelme.__main__:main\",\r\n                \"labelme_draw_json=labelme.cli.draw_json:main\",\r\n                \"labelme_draw_label_png=labelme.cli.draw_label_png:main\",\r\n                \"labelme_json_to_dataset=labelme.cli.json_to_dataset:main\",\r\n                \"labelme_export_json=labelme.cli.export_json:main\",\r\n                \"labelme_on_docker=labelme.cli.on_docker:main\",\r\n            ],\r\n        },\r\n    )\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"}
{"image_path": "data\\train\\00252.png", "code": "import base64\r\nimport contextlib\r\nimport io\r\nimport json\r\nimport os.path as osp\r\n\r\nimport PIL.Image\r\n\r\nfrom labelme import PY2\r\nfrom labelme import QT4\r\nfrom labelme import __version__\r\nfrom labelme import utils\r\nfrom labelme.logger import logger\r\n\r\nPIL.Image.MAX_IMAGE_PIXELS = None\r\n\r\n\r\n@contextlib.contextmanager\r\ndef open(name, mode):\r\n    assert mode in [\"r\", \"w\"]\r\n    if PY2:\r\n        mode += \"b\"\r\n        encoding = None\r\n    else:\r\n        encoding = \"utf-8\"\r\n    yield io.open(name, mode, encoding=encoding)\r\n    return\r\n\r\n\r\nclass LabelFileError(Exception):\r\n    pass\r\n\r\n\r\nclass LabelFile(object):\r\n    suffix = \".json\"\r\n\r\n    def __init__(self, filename=None):\r\n        self.shapes = []\r\n        self.imagePath = None\r\n        self.imageData = None\r\n"}
{"image_path": "data\\train\\00253.png", "code": "        if filename is not None:\r\n            self.load(filename)\r\n        self.filename = filename\r\n\r\n    @staticmethod\r\n    def load_image_file(filename):\r\n        try:\r\n            image_pil = PIL.Image.open(filename)\r\n        except IOError:\r\n            logger.error(\"Failed opening image file: {}\".format(filename))\r\n            return\r\n\r\n        # apply orientation to image according to exif\r\n        image_pil = utils.apply_exif_orientation(image_pil)\r\n\r\n        with io.BytesIO() as f:\r\n            ext = osp.splitext(filename)[1].lower()\r\n            if PY2 and QT4:\r\n                format = \"PNG\"\r\n            elif ext in [\".jpg\", \".jpeg\"]:\r\n                format = \"JPEG\"\r\n            else:\r\n                format = \"PNG\"\r\n            image_pil.save(f, format=format)\r\n            f.seek(0)\r\n            return f.read()\r\n\r\n    def load(self, filename):\r\n        keys = [\r\n            \"version\",\r\n            \"imageData\",\r\n            \"imagePath\",\r\n            \"shapes\",  # polygonal annotations\r\n            \"flags\",  # image level flags\r\n            \"imageHeight\",\r\n            \"imageWidth\",\r\n        ]\r\n        shape_keys = [\r\n            \"label\",\r\n            \"points\",\r\n"}
{"image_path": "data\\train\\00254.png", "code": "            \"group_id\",\r\n            \"shape_type\",\r\n            \"flags\",\r\n            \"description\",\r\n            \"mask\",\r\n        ]\r\n        try:\r\n            with open(filename, \"r\") as f:\r\n                data = json.load(f)\r\n\r\n            if data[\"imageData\"] is not None:\r\n                imageData = base64.b64decode(data[\"imageData\"])\r\n                if PY2 and QT4:\r\n                    imageData = utils.img_data_to_png_data(imageData)\r\n            else:\r\n                # relative path from label file to relative path from cwd\r\n                imagePath = osp.join(osp.dirname(filename), data[\"imagePath\"])\r\n                imageData = self.load_image_file(imagePath)\r\n            flags = data.get(\"flags\") or {}\r\n            imagePath = data[\"imagePath\"]\r\n            self._check_image_height_and_width(\r\n                base64.b64encode(imageData).decode(\"utf-8\"),\r\n                data.get(\"imageHeight\"),\r\n                data.get(\"imageWidth\"),\r\n            )\r\n            shapes = [\r\n                dict(\r\n                    label=s[\"label\"],\r\n                    points=s[\"points\"],\r\n                    shape_type=s.get(\"shape_type\", \"polygon\"),\r\n                    flags=s.get(\"flags\", {}),\r\n                    description=s.get(\"description\"),\r\n                    group_id=s.get(\"group_id\"),\r\n                    mask=utils.img_b64_to_arr(s[\"mask\"]) if s.get(\"mask\") else None,\r\n                    other_data={k: v for k, v in s.items() if k not in shape_keys},\r\n                )\r\n                for s in data[\"shapes\"]\r\n            ]\r\n        except Exception as e:\r\n            raise LabelFileError(e)\r\n"}
{"image_path": "data\\train\\00255.png", "code": "\r\n        otherData = {}\r\n        for key, value in data.items():\r\n            if key not in keys:\r\n                otherData[key] = value\r\n\r\n        # Only replace data after everything is loaded.\r\n        self.flags = flags\r\n        self.shapes = shapes\r\n        self.imagePath = imagePath\r\n        self.imageData = imageData\r\n        self.filename = filename\r\n        self.otherData = otherData\r\n\r\n    @staticmethod\r\n    def _check_image_height_and_width(imageData, imageHeight, imageWidth):\r\n        img_arr = utils.img_b64_to_arr(imageData)\r\n        if imageHeight is not None and img_arr.shape[0] != imageHeight:\r\n            logger.error(\r\n                \"imageHeight does not match with imageData or imagePath, \"\r\n                \"so getting imageHeight from actual image.\"\r\n            )\r\n            imageHeight = img_arr.shape[0]\r\n        if imageWidth is not None and img_arr.shape[1] != imageWidth:\r\n            logger.error(\r\n                \"imageWidth does not match with imageData or imagePath, \"\r\n                \"so getting imageWidth from actual image.\"\r\n            )\r\n            imageWidth = img_arr.shape[1]\r\n        return imageHeight, imageWidth\r\n\r\n    def save(\r\n        self,\r\n        filename,\r\n        shapes,\r\n        imagePath,\r\n        imageHeight,\r\n        imageWidth,\r\n        imageData=None,\r\n        otherData=None,\r\n"}
{"image_path": "data\\train\\00256.png", "code": "        flags=None,\r\n    ):\r\n        if imageData is not None:\r\n            imageData = base64.b64encode(imageData).decode(\"utf-8\")\r\n            imageHeight, imageWidth = self._check_image_height_and_width(\r\n                imageData, imageHeight, imageWidth\r\n            )\r\n        if otherData is None:\r\n            otherData = {}\r\n        if flags is None:\r\n            flags = {}\r\n        data = dict(\r\n            version=__version__,\r\n            flags=flags,\r\n            shapes=shapes,\r\n            imagePath=imagePath,\r\n            imageData=imageData,\r\n            imageHeight=imageHeight,\r\n            imageWidth=imageWidth,\r\n        )\r\n        for key, value in otherData.items():\r\n            assert key not in data\r\n            data[key] = value\r\n        try:\r\n            with open(filename, \"w\") as f:\r\n                json.dump(data, f, ensure_ascii=False, indent=2)\r\n            self.filename = filename\r\n        except Exception as e:\r\n            raise LabelFileError(e)\r\n\r\n    @staticmethod\r\n    def is_label_file(filename):\r\n        return osp.splitext(filename)[1].lower() == LabelFile.suffix\r\n"}
{"image_path": "data\\train\\00257.png", "code": "import datetime\r\nimport logging\r\nimport os\r\nimport sys\r\n\r\nimport termcolor\r\n\r\nif os.name == \"nt\":  # Windows\r\n    import colorama\r\n\r\n    colorama.init()\r\n\r\nfrom . import __appname__\r\n\r\nCOLORS = {\r\n    \"WARNING\": \"yellow\",\r\n    \"INFO\": \"white\",\r\n    \"DEBUG\": \"blue\",\r\n    \"CRITICAL\": \"red\",\r\n    \"ERROR\": \"red\",\r\n}\r\n\r\n\r\nclass ColoredFormatter(logging.Formatter):\r\n    def __init__(self, fmt, use_color=True):\r\n        logging.Formatter.__init__(self, fmt)\r\n        self.use_color = use_color\r\n\r\n    def format(self, record):\r\n        levelname = record.levelname\r\n        if self.use_color and levelname in COLORS:\r\n\r\n            def colored(text):\r\n                return termcolor.colored(\r\n                    text,\r\n                    color=COLORS[levelname],\r\n                    attrs={\"bold\": True},\r\n                )\r\n\r\n            record.levelname2 = colored(\"{:<7}\".format(record.levelname))\r\n"}
{"image_path": "data\\train\\00258.png", "code": "            record.message2 = colored(record.msg)\r\n\r\n            asctime2 = datetime.datetime.fromtimestamp(record.created)\r\n            record.asctime2 = termcolor.colored(asctime2, color=\"green\")\r\n\r\n            record.module2 = termcolor.colored(record.module, color=\"cyan\")\r\n            record.funcName2 = termcolor.colored(record.funcName, color=\"cyan\")\r\n            record.lineno2 = termcolor.colored(record.lineno, color=\"cyan\")\r\n        return logging.Formatter.format(self, record)\r\n\r\n\r\nlogger = logging.getLogger(__appname__)\r\nlogger.setLevel(logging.INFO)\r\n\r\nstream_handler = logging.StreamHandler(sys.stderr)\r\nhandler_format = ColoredFormatter(\r\n    \"%(asctime)s [%(levelname2)s] %(module2)s:%(funcName2)s:%(lineno2)s\"\r\n    \"- %(message2)s\"\r\n)\r\nstream_handler.setFormatter(handler_format)\r\n\r\nlogger.addHandler(stream_handler)\r\n"}
{"image_path": "data\\train\\00259.png", "code": "import json\r\nimport os.path as osp\r\n\r\nimport imgviz\r\n\r\nimport labelme.utils\r\n\r\n\r\ndef assert_labelfile_sanity(filename):\r\n    assert osp.exists(filename)\r\n\r\n    data = json.load(open(filename))\r\n\r\n    assert \"imagePath\" in data\r\n    imageData = data.get(\"imageData\", None)\r\n    if imageData is None:\r\n        parent_dir = osp.dirname(filename)\r\n        img_file = osp.join(parent_dir, data[\"imagePath\"])\r\n        assert osp.exists(img_file)\r\n        img = imgviz.io.imread(img_file)\r\n    else:\r\n        img = labelme.utils.img_b64_to_arr(imageData)\r\n\r\n    H, W = img.shape[:2]\r\n    assert H == data[\"imageHeight\"]\r\n    assert W == data[\"imageWidth\"]\r\n\r\n    assert \"shapes\" in data\r\n    for shape in data[\"shapes\"]:\r\n        assert \"label\" in shape\r\n        assert \"points\" in shape\r\n        for x, y in shape[\"points\"]:\r\n            assert 0 <= x <= W\r\n            assert 0 <= y <= H\r\n"}
{"image_path": "data\\train\\00260.png", "code": "import argparse\r\nimport codecs\r\nimport logging\r\nimport os\r\nimport os.path as osp\r\nimport sys\r\n\r\nimport yaml\r\nfrom qtpy import QtCore\r\nfrom qtpy import QtWidgets\r\n\r\nfrom labelme import __appname__\r\nfrom labelme import __version__\r\nfrom labelme.app import MainWindow\r\nfrom labelme.config import get_config\r\nfrom labelme.logger import logger\r\nfrom labelme.utils import newIcon\r\n\r\n\r\ndef main():\r\n    parser = argparse.ArgumentParser()\r\n    parser.add_argument(\"--version\", \"-V\", action=\"store_true\", help=\"show version\")\r\n    parser.add_argument(\"--reset-config\", action=\"store_true\", help=\"reset qt config\")\r\n    parser.add_argument(\r\n        \"--logger-level\",\r\n        default=\"debug\",\r\n        choices=[\"debug\", \"info\", \"warning\", \"fatal\", \"error\"],\r\n        help=\"logger level\",\r\n    )\r\n    parser.add_argument(\"filename\", nargs=\"?\", help=\"image or label filename\")\r\n    parser.add_argument(\r\n        \"--output\",\r\n        \"-O\",\r\n        \"-o\",\r\n        help=\"output file or directory (if it ends with .json it is \"\r\n        \"recognized as file, else as directory)\",\r\n    )\r\n    default_config_file = os.path.join(os.path.expanduser(\"~\"), \".labelmerc\")\r\n    parser.add_argument(\r\n        \"--config\",\r\n"}
{"image_path": "data\\train\\00261.png", "code": "        dest=\"config\",\r\n        help=\"config file or yaml-format string (default: {})\".format(\r\n            default_config_file\r\n        ),\r\n        default=default_config_file,\r\n    )\r\n    # config for the gui\r\n    parser.add_argument(\r\n        \"--nodata\",\r\n        dest=\"store_data\",\r\n        action=\"store_false\",\r\n        help=\"stop storing image data to JSON file\",\r\n        default=argparse.SUPPRESS,\r\n    )\r\n    parser.add_argument(\r\n        \"--autosave\",\r\n        dest=\"auto_save\",\r\n        action=\"store_true\",\r\n        help=\"auto save\",\r\n        default=argparse.SUPPRESS,\r\n    )\r\n    parser.add_argument(\r\n        \"--nosortlabels\",\r\n        dest=\"sort_labels\",\r\n        action=\"store_false\",\r\n        help=\"stop sorting labels\",\r\n        default=argparse.SUPPRESS,\r\n    )\r\n    parser.add_argument(\r\n        \"--flags\",\r\n        help=\"comma separated list of flags OR file containing flags\",\r\n        default=argparse.SUPPRESS,\r\n    )\r\n    parser.add_argument(\r\n        \"--labelflags\",\r\n        dest=\"label_flags\",\r\n        help=r\"yaml string of label specific flags OR file containing json \"\r\n        r\"string of label specific flags (ex. {person-\\d+: [male, tall], \"\r\n        r\"dog-\\d+: [black, brown, white], .*: [occluded]})\",  # NOQA\r\n        default=argparse.SUPPRESS,\r\n"}
{"image_path": "data\\train\\00262.png", "code": "    )\r\n    parser.add_argument(\r\n        \"--labels\",\r\n        help=\"comma separated list of labels OR file containing labels\",\r\n        default=argparse.SUPPRESS,\r\n    )\r\n    parser.add_argument(\r\n        \"--validatelabel\",\r\n        dest=\"validate_label\",\r\n        choices=[\"exact\"],\r\n        help=\"label validation types\",\r\n        default=argparse.SUPPRESS,\r\n    )\r\n    parser.add_argument(\r\n        \"--keep-prev\",\r\n        action=\"store_true\",\r\n        help=\"keep annotation of previous frame\",\r\n        default=argparse.SUPPRESS,\r\n    )\r\n    parser.add_argument(\r\n        \"--epsilon\",\r\n        type=float,\r\n        help=\"epsilon to find nearest vertex on canvas\",\r\n        default=argparse.SUPPRESS,\r\n    )\r\n    args = parser.parse_args()\r\n\r\n    if args.version:\r\n        print(\"{0} {1}\".format(__appname__, __version__))\r\n        sys.exit(0)\r\n\r\n    logger.setLevel(getattr(logging, args.logger_level.upper()))\r\n\r\n    if hasattr(args, \"flags\"):\r\n        if os.path.isfile(args.flags):\r\n            with codecs.open(args.flags, \"r\", encoding=\"utf-8\") as f:\r\n                args.flags = [line.strip() for line in f if line.strip()]\r\n        else:\r\n            args.flags = [line for line in args.flags.split(\",\") if line]\r\n\r\n"}
{"image_path": "data\\train\\00263.png", "code": "    if hasattr(args, \"labels\"):\r\n        if os.path.isfile(args.labels):\r\n            with codecs.open(args.labels, \"r\", encoding=\"utf-8\") as f:\r\n                args.labels = [line.strip() for line in f if line.strip()]\r\n        else:\r\n            args.labels = [line for line in args.labels.split(\",\") if line]\r\n\r\n    if hasattr(args, \"label_flags\"):\r\n        if os.path.isfile(args.label_flags):\r\n            with codecs.open(args.label_flags, \"r\", encoding=\"utf-8\") as f:\r\n                args.label_flags = yaml.safe_load(f)\r\n        else:\r\n            args.label_flags = yaml.safe_load(args.label_flags)\r\n\r\n    config_from_args = args.__dict__\r\n    config_from_args.pop(\"version\")\r\n    reset_config = config_from_args.pop(\"reset_config\")\r\n    filename = config_from_args.pop(\"filename\")\r\n    output = config_from_args.pop(\"output\")\r\n    config_file_or_yaml = config_from_args.pop(\"config\")\r\n    config = get_config(config_file_or_yaml, config_from_args)\r\n\r\n    if not config[\"labels\"] and config[\"validate_label\"]:\r\n        logger.error(\r\n            \"--labels must be specified with --validatelabel or \"\r\n            \"validate_label: true in the config file \"\r\n            \"(ex. ~/.labelmerc).\"\r\n        )\r\n        sys.exit(1)\r\n\r\n    output_file = None\r\n    output_dir = None\r\n    if output is not None:\r\n        if output.endswith(\".json\"):\r\n            output_file = output\r\n        else:\r\n            output_dir = output\r\n\r\n    translator = QtCore.QTranslator()\r\n    translator.load(\r\n"}
{"image_path": "data\\train\\00264.png", "code": "        QtCore.QLocale.system().name(),\r\n        osp.dirname(osp.abspath(__file__)) + \"/translate\",\r\n    )\r\n    app = QtWidgets.QApplication(sys.argv)\r\n    app.setApplicationName(__appname__)\r\n    app.setWindowIcon(newIcon(\"icon\"))\r\n    app.installTranslator(translator)\r\n    win = MainWindow(\r\n        config=config,\r\n        filename=filename,\r\n        output_file=output_file,\r\n        output_dir=output_dir,\r\n    )\r\n\r\n    if reset_config:\r\n        logger.info(\"Resetting Qt config: %s\" % win.settings.fileName())\r\n        win.settings.clear()\r\n        sys.exit(0)\r\n\r\n    win.show()\r\n    win.raise_()\r\n    sys.exit(app.exec_())\r\n\r\n\r\n# this main block is required to generate executable by pyinstaller\r\nif __name__ == \"__main__\":\r\n    main()\r\n"}
{"image_path": "data\\train\\00265.png", "code": "# flake8: noqa\r\n\r\nimport logging\r\nimport sys\r\n\r\nfrom qtpy import QT_VERSION\r\n\r\n\r\n__appname__ = \"labelme\"\r\n\r\n# Semantic Versioning 2.0.0: https://semver.org/\r\n# 1. MAJOR version when you make incompatible API changes;\r\n# 2. MINOR version when you add functionality in a backwards-compatible manner;\r\n# 3. PATCH version when you make backwards-compatible bug fixes.\r\n# e.g., 1.0.0a0, 1.0.0a1, 1.0.0b0, 1.0.0rc0, 1.0.0, 1.0.0.post0\r\n__version__ = \"5.4.1\"\r\n\r\nQT4 = QT_VERSION[0] == \"4\"\r\nQT5 = QT_VERSION[0] == \"5\"\r\ndel QT_VERSION\r\n\r\nPY2 = sys.version[0] == \"2\"\r\nPY3 = sys.version[0] == \"3\"\r\ndel sys\r\n\r\nfrom labelme.label_file import LabelFile\r\nfrom labelme import testing\r\nfrom labelme import utils\r\n"}
{"image_path": "data\\train\\00266.png", "code": "import copy\r\nimport math\r\n\r\nimport numpy as np\r\nimport skimage.measure\r\nfrom qtpy import QtCore\r\nfrom qtpy import QtGui\r\n\r\nimport labelme.utils\r\nfrom labelme.logger import logger\r\n\r\n# TODO(unknown):\r\n# - [opt] Store paths instead of creating new ones at each paint.\r\n\r\n\r\nclass Shape(object):\r\n    # Render handles as squares\r\n    P_SQUARE = 0\r\n\r\n    # Render handles as circles\r\n    P_ROUND = 1\r\n\r\n    # Flag for the handles we would move if dragging\r\n    MOVE_VERTEX = 0\r\n\r\n    # Flag for all other handles on the current shape\r\n    NEAR_VERTEX = 1\r\n\r\n    # The following class variables influence the drawing of all shape objects.\r\n    line_color = None\r\n    fill_color = None\r\n    select_line_color = None\r\n    select_fill_color = None\r\n    vertex_fill_color = None\r\n    hvertex_fill_color = None\r\n    point_type = P_ROUND\r\n    point_size = 8\r\n    scale = 1.0\r\n\r\n    def __init__(\r\n"}
{"image_path": "data\\train\\00267.png", "code": "        self,\r\n        label=None,\r\n        line_color=None,\r\n        shape_type=None,\r\n        flags=None,\r\n        group_id=None,\r\n        description=None,\r\n        mask=None,\r\n    ):\r\n        self.label = label\r\n        self.group_id = group_id\r\n        self.points = []\r\n        self.point_labels = []\r\n        self.shape_type = shape_type\r\n        self._shape_raw = None\r\n        self._points_raw = []\r\n        self._shape_type_raw = None\r\n        self.fill = False\r\n        self.selected = False\r\n        self.flags = flags\r\n        self.description = description\r\n        self.other_data = {}\r\n        self.mask = mask\r\n\r\n        self._highlightIndex = None\r\n        self._highlightMode = self.NEAR_VERTEX\r\n        self._highlightSettings = {\r\n            self.NEAR_VERTEX: (4, self.P_ROUND),\r\n            self.MOVE_VERTEX: (1.5, self.P_SQUARE),\r\n        }\r\n\r\n        self._closed = False\r\n\r\n        if line_color is not None:\r\n            # Override the class line_color attribute\r\n            # with an object attribute. Currently this\r\n            # is used for drawing the pending line a different color.\r\n            self.line_color = line_color\r\n\r\n    def setShapeRefined(self, shape_type, points, point_labels, mask=None):\r\n"}
{"image_path": "data\\train\\00268.png", "code": "        self._shape_raw = (self.shape_type, self.points, self.point_labels)\r\n        self.shape_type = shape_type\r\n        self.points = points\r\n        self.point_labels = point_labels\r\n        self.mask = mask\r\n\r\n    def restoreShapeRaw(self):\r\n        if self._shape_raw is None:\r\n            return\r\n        self.shape_type, self.points, self.point_labels = self._shape_raw\r\n        self._shape_raw = None\r\n\r\n    @property\r\n    def shape_type(self):\r\n        return self._shape_type\r\n\r\n    @shape_type.setter\r\n    def shape_type(self, value):\r\n        if value is None:\r\n            value = \"polygon\"\r\n        if value not in [\r\n            \"polygon\",\r\n            \"rectangle\",\r\n            \"point\",\r\n            \"line\",\r\n            \"circle\",\r\n            \"linestrip\",\r\n            \"points\",\r\n            \"mask\",\r\n        ]:\r\n            raise ValueError(\"Unexpected shape_type: {}\".format(value))\r\n        self._shape_type = value\r\n\r\n    def close(self):\r\n        self._closed = True\r\n\r\n    def addPoint(self, point, label=1):\r\n        if self.points and point == self.points[0]:\r\n            self.close()\r\n        else:\r\n"}
{"image_path": "data\\train\\00269.png", "code": "            self.points.append(point)\r\n            self.point_labels.append(label)\r\n\r\n    def canAddPoint(self):\r\n        return self.shape_type in [\"polygon\", \"linestrip\"]\r\n\r\n    def popPoint(self):\r\n        if self.points:\r\n            if self.point_labels:\r\n                self.point_labels.pop()\r\n            return self.points.pop()\r\n        return None\r\n\r\n    def insertPoint(self, i, point, label=1):\r\n        self.points.insert(i, point)\r\n        self.point_labels.insert(i, label)\r\n\r\n    def removePoint(self, i):\r\n        if not self.canAddPoint():\r\n            logger.warning(\r\n                \"Cannot remove point from: shape_type=%r\",\r\n                self.shape_type,\r\n            )\r\n            return\r\n\r\n        if self.shape_type == \"polygon\" and len(self.points) <= 3:\r\n            logger.warning(\r\n                \"Cannot remove point from: shape_type=%r, len(points)=%d\",\r\n                self.shape_type,\r\n                len(self.points),\r\n            )\r\n            return\r\n\r\n        if self.shape_type == \"linestrip\" and len(self.points) <= 2:\r\n            logger.warning(\r\n                \"Cannot remove point from: shape_type=%r, len(points)=%d\",\r\n                self.shape_type,\r\n                len(self.points),\r\n            )\r\n            return\r\n"}
{"image_path": "data\\train\\00270.png", "code": "\r\n        self.points.pop(i)\r\n        self.point_labels.pop(i)\r\n\r\n    def isClosed(self):\r\n        return self._closed\r\n\r\n    def setOpen(self):\r\n        self._closed = False\r\n\r\n    def getRectFromLine(self, pt1, pt2):\r\n        x1, y1 = pt1.x(), pt1.y()\r\n        x2, y2 = pt2.x(), pt2.y()\r\n        return QtCore.QRectF(x1, y1, x2 - x1, y2 - y1)\r\n\r\n    def paint(self, painter):\r\n        if self.mask is None and not self.points:\r\n            return\r\n\r\n        color = self.select_line_color if self.selected else self.line_color\r\n        pen = QtGui.QPen(color)\r\n        # Try using integer sizes for smoother drawing(?)\r\n        pen.setWidth(max(1, int(round(2.0 / self.scale))))\r\n        painter.setPen(pen)\r\n\r\n        if self.mask is not None:\r\n            image_to_draw = np.zeros(self.mask.shape + (4,), dtype=np.uint8)\r\n            fill_color = (\r\n                self.select_fill_color.getRgb()\r\n                if self.selected\r\n                else self.fill_color.getRgb()\r\n            )\r\n            image_to_draw[self.mask] = fill_color\r\n            qimage = QtGui.QImage.fromData(labelme.utils.img_arr_to_data(image_to_draw))\r\n            painter.drawImage(\r\n                int(round(self.points[0].x())),\r\n                int(round(self.points[0].y())),\r\n                qimage,\r\n            )\r\n\r\n"}
{"image_path": "data\\train\\00271.png", "code": "            line_path = QtGui.QPainterPath()\r\n            contours = skimage.measure.find_contours(np.pad(self.mask, pad_width=1))\r\n            for contour in contours:\r\n                contour += [self.points[0].y(), self.points[0].x()]\r\n                line_path.moveTo(contour[0, 1], contour[0, 0])\r\n                for point in contour[1:]:\r\n                    line_path.lineTo(point[1], point[0])\r\n            painter.drawPath(line_path)\r\n\r\n        if self.points:\r\n            line_path = QtGui.QPainterPath()\r\n            vrtx_path = QtGui.QPainterPath()\r\n            negative_vrtx_path = QtGui.QPainterPath()\r\n\r\n            if self.shape_type in [\"rectangle\", \"mask\"]:\r\n                assert len(self.points) in [1, 2]\r\n                if len(self.points) == 2:\r\n                    rectangle = self.getRectFromLine(*self.points)\r\n                    line_path.addRect(rectangle)\r\n                if self.shape_type == \"rectangle\":\r\n                    for i in range(len(self.points)):\r\n                        self.drawVertex(vrtx_path, i)\r\n            elif self.shape_type == \"circle\":\r\n                assert len(self.points) in [1, 2]\r\n                if len(self.points) == 2:\r\n                    rectangle = self.getCircleRectFromLine(self.points)\r\n                    line_path.addEllipse(rectangle)\r\n                for i in range(len(self.points)):\r\n                    self.drawVertex(vrtx_path, i)\r\n            elif self.shape_type == \"linestrip\":\r\n                line_path.moveTo(self.points[0])\r\n                for i, p in enumerate(self.points):\r\n                    line_path.lineTo(p)\r\n                    self.drawVertex(vrtx_path, i)\r\n            elif self.shape_type == \"points\":\r\n                assert len(self.points) == len(self.point_labels)\r\n                for i, point_label in enumerate(self.point_labels):\r\n                    if point_label == 1:\r\n                        self.drawVertex(vrtx_path, i)\r\n                    else:\r\n"}
{"image_path": "data\\train\\00272.png", "code": "                        self.drawVertex(negative_vrtx_path, i)\r\n            else:\r\n                line_path.moveTo(self.points[0])\r\n                # Uncommenting the following line will draw 2 paths\r\n                # for the 1st vertex, and make it non-filled, which\r\n                # may be desirable.\r\n                # self.drawVertex(vrtx_path, 0)\r\n\r\n                for i, p in enumerate(self.points):\r\n                    line_path.lineTo(p)\r\n                    self.drawVertex(vrtx_path, i)\r\n                if self.isClosed():\r\n                    line_path.lineTo(self.points[0])\r\n\r\n            painter.drawPath(line_path)\r\n            if vrtx_path.length() > 0:\r\n                painter.drawPath(vrtx_path)\r\n                painter.fillPath(vrtx_path, self._vertex_fill_color)\r\n            if self.fill and self.mask is None:\r\n                color = self.select_fill_color if self.selected else self.fill_color\r\n                painter.fillPath(line_path, color)\r\n\r\n            pen.setColor(QtGui.QColor(255, 0, 0, 255))\r\n            painter.setPen(pen)\r\n            painter.drawPath(negative_vrtx_path)\r\n            painter.fillPath(negative_vrtx_path, QtGui.QColor(255, 0, 0, 255))\r\n\r\n    def drawVertex(self, path, i):\r\n        d = self.point_size / self.scale\r\n        shape = self.point_type\r\n        point = self.points[i]\r\n        if i == self._highlightIndex:\r\n            size, shape = self._highlightSettings[self._highlightMode]\r\n            d *= size\r\n        if self._highlightIndex is not None:\r\n            self._vertex_fill_color = self.hvertex_fill_color\r\n        else:\r\n            self._vertex_fill_color = self.vertex_fill_color\r\n        if shape == self.P_SQUARE:\r\n            path.addRect(point.x() - d / 2, point.y() - d / 2, d, d)\r\n"}
{"image_path": "data\\train\\00273.png", "code": "        elif shape == self.P_ROUND:\r\n            path.addEllipse(point, d / 2.0, d / 2.0)\r\n        else:\r\n            assert False, \"unsupported vertex shape\"\r\n\r\n    def nearestVertex(self, point, epsilon):\r\n        min_distance = float(\"inf\")\r\n        min_i = None\r\n        for i, p in enumerate(self.points):\r\n            dist = labelme.utils.distance(p - point)\r\n            if dist <= epsilon and dist < min_distance:\r\n                min_distance = dist\r\n                min_i = i\r\n        return min_i\r\n\r\n    def nearestEdge(self, point, epsilon):\r\n        min_distance = float(\"inf\")\r\n        post_i = None\r\n        for i in range(len(self.points)):\r\n            line = [self.points[i - 1], self.points[i]]\r\n            dist = labelme.utils.distancetoline(point, line)\r\n            if dist <= epsilon and dist < min_distance:\r\n                min_distance = dist\r\n                post_i = i\r\n        return post_i\r\n\r\n    def containsPoint(self, point):\r\n        if self.mask is not None:\r\n            y = np.clip(\r\n                int(round(point.y() - self.points[0].y())),\r\n                0,\r\n                self.mask.shape[0] - 1,\r\n            )\r\n            x = np.clip(\r\n                int(round(point.x() - self.points[0].x())),\r\n                0,\r\n                self.mask.shape[1] - 1,\r\n            )\r\n            return self.mask[y, x]\r\n        return self.makePath().contains(point)\r\n"}
{"image_path": "data\\train\\00274.png", "code": "\r\n    def getCircleRectFromLine(self, line):\r\n        \"\"\"Computes parameters to draw with `QPainterPath::addEllipse`\"\"\"\r\n        if len(line) != 2:\r\n            return None\r\n        (c, point) = line\r\n        r = line[0] - line[1]\r\n        d = math.sqrt(math.pow(r.x(), 2) + math.pow(r.y(), 2))\r\n        rectangle = QtCore.QRectF(c.x() - d, c.y() - d, 2 * d, 2 * d)\r\n        return rectangle\r\n\r\n    def makePath(self):\r\n        if self.shape_type in [\"rectangle\", \"mask\"]:\r\n            path = QtGui.QPainterPath()\r\n            if len(self.points) == 2:\r\n                rectangle = self.getRectFromLine(*self.points)\r\n                path.addRect(rectangle)\r\n        elif self.shape_type == \"circle\":\r\n            path = QtGui.QPainterPath()\r\n            if len(self.points) == 2:\r\n                rectangle = self.getCircleRectFromLine(self.points)\r\n                path.addEllipse(rectangle)\r\n        else:\r\n            path = QtGui.QPainterPath(self.points[0])\r\n            for p in self.points[1:]:\r\n                path.lineTo(p)\r\n        return path\r\n\r\n    def boundingRect(self):\r\n        return self.makePath().boundingRect()\r\n\r\n    def moveBy(self, offset):\r\n        self.points = [p + offset for p in self.points]\r\n\r\n    def moveVertexBy(self, i, offset):\r\n        self.points[i] = self.points[i] + offset\r\n\r\n    def highlightVertex(self, i, action):\r\n        \"\"\"Highlight a vertex appropriately based on the current action\r\n\r\n"}
{"image_path": "data\\train\\00275.png", "code": "        Args:\r\n            i (int): The vertex index\r\n            action (int): The action\r\n            (see Shape.NEAR_VERTEX and Shape.MOVE_VERTEX)\r\n        \"\"\"\r\n        self._highlightIndex = i\r\n        self._highlightMode = action\r\n\r\n    def highlightClear(self):\r\n        \"\"\"Clear the highlighted point\"\"\"\r\n        self._highlightIndex = None\r\n\r\n    def copy(self):\r\n        return copy.deepcopy(self)\r\n\r\n    def __len__(self):\r\n        return len(self.points)\r\n\r\n    def __getitem__(self, key):\r\n        return self.points[key]\r\n\r\n    def __setitem__(self, key, value):\r\n        self.points[key] = value\r\n"}
{"image_path": "data\\train\\00276.png", "code": "# -*- coding: utf-8 -*-\r\n\r\nimport functools\r\nimport html\r\nimport math\r\nimport os\r\nimport os.path as osp\r\nimport re\r\nimport webbrowser\r\n\r\nimport imgviz\r\nimport natsort\r\nfrom qtpy import QtCore\r\nfrom qtpy import QtGui\r\nfrom qtpy import QtWidgets\r\nfrom qtpy.QtCore import Qt\r\n\r\nfrom labelme import PY2\r\nfrom labelme import __appname__\r\nfrom labelme.ai import MODELS\r\nfrom labelme.config import get_config\r\nfrom labelme.label_file import LabelFile\r\nfrom labelme.label_file import LabelFileError\r\nfrom labelme.logger import logger\r\nfrom labelme.shape import Shape\r\nfrom labelme.widgets import BrightnessContrastDialog\r\nfrom labelme.widgets import Canvas\r\nfrom labelme.widgets import FileDialogPreview\r\nfrom labelme.widgets import LabelDialog\r\nfrom labelme.widgets import LabelListWidget\r\nfrom labelme.widgets import LabelListWidgetItem\r\nfrom labelme.widgets import ToolBar\r\nfrom labelme.widgets import UniqueLabelQListWidget\r\nfrom labelme.widgets import ZoomWidget\r\n\r\nfrom . import utils\r\n\r\n# FIXME\r\n# - [medium] Set max zoom value to something big enough for FitWidth/Window\r\n\r\n"}
{"image_path": "data\\train\\00277.png", "code": "# TODO(unknown):\r\n# - Zoom is too \"steppy\".\r\n\r\n\r\nLABEL_COLORMAP = imgviz.label_colormap()\r\n\r\n\r\nclass MainWindow(QtWidgets.QMainWindow):\r\n    FIT_WINDOW, FIT_WIDTH, MANUAL_ZOOM = 0, 1, 2\r\n\r\n    def __init__(\r\n        self,\r\n        config=None,\r\n        filename=None,\r\n        output=None,\r\n        output_file=None,\r\n        output_dir=None,\r\n    ):\r\n        if output is not None:\r\n            logger.warning(\"argument output is deprecated, use output_file instead\")\r\n            if output_file is None:\r\n                output_file = output\r\n\r\n        # see labelme/config/default_config.yaml for valid configuration\r\n        if config is None:\r\n            config = get_config()\r\n        self._config = config\r\n\r\n        # set default shape colors\r\n        Shape.line_color = QtGui.QColor(*self._config[\"shape\"][\"line_color\"])\r\n        Shape.fill_color = QtGui.QColor(*self._config[\"shape\"][\"fill_color\"])\r\n        Shape.select_line_color = QtGui.QColor(\r\n            *self._config[\"shape\"][\"select_line_color\"]\r\n        )\r\n        Shape.select_fill_color = QtGui.QColor(\r\n            *self._config[\"shape\"][\"select_fill_color\"]\r\n        )\r\n        Shape.vertex_fill_color = QtGui.QColor(\r\n            *self._config[\"shape\"][\"vertex_fill_color\"]\r\n        )\r\n"}
{"image_path": "data\\train\\00278.png", "code": "        Shape.hvertex_fill_color = QtGui.QColor(\r\n            *self._config[\"shape\"][\"hvertex_fill_color\"]\r\n        )\r\n\r\n        # Set point size from config file\r\n        Shape.point_size = self._config[\"shape\"][\"point_size\"]\r\n\r\n        super(MainWindow, self).__init__()\r\n        self.setWindowTitle(__appname__)\r\n\r\n        # Whether we need to save or not.\r\n        self.dirty = False\r\n\r\n        self._noSelectionSlot = False\r\n\r\n        self._copied_shapes = None\r\n\r\n        # Main widgets and related state.\r\n        self.labelDialog = LabelDialog(\r\n            parent=self,\r\n            labels=self._config[\"labels\"],\r\n            sort_labels=self._config[\"sort_labels\"],\r\n            show_text_field=self._config[\"show_label_text_field\"],\r\n            completion=self._config[\"label_completion\"],\r\n            fit_to_content=self._config[\"fit_to_content\"],\r\n            flags=self._config[\"label_flags\"],\r\n        )\r\n\r\n        self.labelList = LabelListWidget()\r\n        self.lastOpenDir = None\r\n\r\n        self.flag_dock = self.flag_widget = None\r\n        self.flag_dock = QtWidgets.QDockWidget(self.tr(\"Flags\"), self)\r\n        self.flag_dock.setObjectName(\"Flags\")\r\n        self.flag_widget = QtWidgets.QListWidget()\r\n        if config[\"flags\"]:\r\n            self.loadFlags({k: False for k in config[\"flags\"]})\r\n        self.flag_dock.setWidget(self.flag_widget)\r\n        self.flag_widget.itemChanged.connect(self.setDirty)\r\n\r\n"}
{"image_path": "data\\train\\00279.png", "code": "        self.labelList.itemSelectionChanged.connect(self.labelSelectionChanged)\r\n        self.labelList.itemDoubleClicked.connect(self.editLabel)\r\n        self.labelList.itemChanged.connect(self.labelItemChanged)\r\n        self.labelList.itemDropped.connect(self.labelOrderChanged)\r\n        self.shape_dock = QtWidgets.QDockWidget(self.tr(\"Polygon Labels\"), self)\r\n        self.shape_dock.setObjectName(\"Labels\")\r\n        self.shape_dock.setWidget(self.labelList)\r\n\r\n        self.uniqLabelList = UniqueLabelQListWidget()\r\n        self.uniqLabelList.setToolTip(\r\n            self.tr(\r\n                \"Select label to start annotating for it. \" \"Press 'Esc' to deselect.\"\r\n            )\r\n        )\r\n        if self._config[\"labels\"]:\r\n            for label in self._config[\"labels\"]:\r\n                item = self.uniqLabelList.createItemFromLabel(label)\r\n                self.uniqLabelList.addItem(item)\r\n                rgb = self._get_rgb_by_label(label)\r\n                self.uniqLabelList.setItemLabel(item, label, rgb)\r\n        self.label_dock = QtWidgets.QDockWidget(self.tr(\"Label List\"), self)\r\n        self.label_dock.setObjectName(\"Label List\")\r\n        self.label_dock.setWidget(self.uniqLabelList)\r\n\r\n        self.fileSearch = QtWidgets.QLineEdit()\r\n        self.fileSearch.setPlaceholderText(self.tr(\"Search Filename\"))\r\n        self.fileSearch.textChanged.connect(self.fileSearchChanged)\r\n        self.fileListWidget = QtWidgets.QListWidget()\r\n        self.fileListWidget.itemSelectionChanged.connect(self.fileSelectionChanged)\r\n        fileListLayout = QtWidgets.QVBoxLayout()\r\n        fileListLayout.setContentsMargins(0, 0, 0, 0)\r\n        fileListLayout.setSpacing(0)\r\n        fileListLayout.addWidget(self.fileSearch)\r\n        fileListLayout.addWidget(self.fileListWidget)\r\n        self.file_dock = QtWidgets.QDockWidget(self.tr(\"File List\"), self)\r\n        self.file_dock.setObjectName(\"Files\")\r\n        fileListWidget = QtWidgets.QWidget()\r\n        fileListWidget.setLayout(fileListLayout)\r\n        self.file_dock.setWidget(fileListWidget)\r\n\r\n"}
{"image_path": "data\\train\\00280.png", "code": "        self.zoomWidget = ZoomWidget()\r\n        self.setAcceptDrops(True)\r\n\r\n        self.canvas = self.labelList.canvas = Canvas(\r\n            epsilon=self._config[\"epsilon\"],\r\n            double_click=self._config[\"canvas\"][\"double_click\"],\r\n            num_backups=self._config[\"canvas\"][\"num_backups\"],\r\n            crosshair=self._config[\"canvas\"][\"crosshair\"],\r\n        )\r\n        self.canvas.zoomRequest.connect(self.zoomRequest)\r\n\r\n        scrollArea = QtWidgets.QScrollArea()\r\n        scrollArea.setWidget(self.canvas)\r\n        scrollArea.setWidgetResizable(True)\r\n        self.scrollBars = {\r\n            Qt.Vertical: scrollArea.verticalScrollBar(),\r\n            Qt.Horizontal: scrollArea.horizontalScrollBar(),\r\n        }\r\n        self.canvas.scrollRequest.connect(self.scrollRequest)\r\n\r\n        self.canvas.newShape.connect(self.newShape)\r\n        self.canvas.shapeMoved.connect(self.setDirty)\r\n        self.canvas.selectionChanged.connect(self.shapeSelectionChanged)\r\n        self.canvas.drawingPolygon.connect(self.toggleDrawingSensitive)\r\n\r\n        self.setCentralWidget(scrollArea)\r\n\r\n        features = QtWidgets.QDockWidget.DockWidgetFeatures()\r\n        for dock in [\"flag_dock\", \"label_dock\", \"shape_dock\", \"file_dock\"]:\r\n            if self._config[dock][\"closable\"]:\r\n                features = features | QtWidgets.QDockWidget.DockWidgetClosable\r\n            if self._config[dock][\"floatable\"]:\r\n                features = features | QtWidgets.QDockWidget.DockWidgetFloatable\r\n            if self._config[dock][\"movable\"]:\r\n                features = features | QtWidgets.QDockWidget.DockWidgetMovable\r\n            getattr(self, dock).setFeatures(features)\r\n            if self._config[dock][\"show\"] is False:\r\n                getattr(self, dock).setVisible(False)\r\n\r\n        self.addDockWidget(Qt.RightDockWidgetArea, self.flag_dock)\r\n"}
{"image_path": "data\\train\\00281.png", "code": "        self.addDockWidget(Qt.RightDockWidgetArea, self.label_dock)\r\n        self.addDockWidget(Qt.RightDockWidgetArea, self.shape_dock)\r\n        self.addDockWidget(Qt.RightDockWidgetArea, self.file_dock)\r\n\r\n        # Actions\r\n        action = functools.partial(utils.newAction, self)\r\n        shortcuts = self._config[\"shortcuts\"]\r\n        quit = action(\r\n            self.tr(\"&Quit\"),\r\n            self.close,\r\n            shortcuts[\"quit\"],\r\n            \"quit\",\r\n            self.tr(\"Quit application\"),\r\n        )\r\n        open_ = action(\r\n            self.tr(\"&Open\\n\"),\r\n            self.openFile,\r\n            shortcuts[\"open\"],\r\n            \"open\",\r\n            self.tr(\"Open image or label file\"),\r\n        )\r\n        opendir = action(\r\n            self.tr(\"Open Dir\"),\r\n            self.openDirDialog,\r\n            shortcuts[\"open_dir\"],\r\n            \"open\",\r\n            self.tr(\"Open Dir\"),\r\n        )\r\n        openNextImg = action(\r\n            self.tr(\"&Next Image\"),\r\n            self.openNextImg,\r\n            shortcuts[\"open_next\"],\r\n            \"next\",\r\n            self.tr(\"Open next (hold Ctl+Shift to copy labels)\"),\r\n            enabled=False,\r\n        )\r\n        openPrevImg = action(\r\n            self.tr(\"&Prev Image\"),\r\n            self.openPrevImg,\r\n            shortcuts[\"open_prev\"],\r\n"}
{"image_path": "data\\train\\00282.png", "code": "            \"prev\",\r\n            self.tr(\"Open prev (hold Ctl+Shift to copy labels)\"),\r\n            enabled=False,\r\n        )\r\n        save = action(\r\n            self.tr(\"&Save\\n\"),\r\n            self.saveFile,\r\n            shortcuts[\"save\"],\r\n            \"save\",\r\n            self.tr(\"Save labels to file\"),\r\n            enabled=False,\r\n        )\r\n        saveAs = action(\r\n            self.tr(\"&Save As\"),\r\n            self.saveFileAs,\r\n            shortcuts[\"save_as\"],\r\n            \"save-as\",\r\n            self.tr(\"Save labels to a different file\"),\r\n            enabled=False,\r\n        )\r\n\r\n        deleteFile = action(\r\n            self.tr(\"&Delete File\"),\r\n            self.deleteFile,\r\n            shortcuts[\"delete_file\"],\r\n            \"delete\",\r\n            self.tr(\"Delete current label file\"),\r\n            enabled=False,\r\n        )\r\n\r\n        changeOutputDir = action(\r\n            self.tr(\"&Change Output Dir\"),\r\n            slot=self.changeOutputDirDialog,\r\n            shortcut=shortcuts[\"save_to\"],\r\n            icon=\"open\",\r\n            tip=self.tr(\"Change where annotations are loaded/saved\"),\r\n        )\r\n\r\n        saveAuto = action(\r\n            text=self.tr(\"Save &Automatically\"),\r\n"}
{"image_path": "data\\train\\00283.png", "code": "            slot=lambda x: self.actions.saveAuto.setChecked(x),\r\n            icon=\"save\",\r\n            tip=self.tr(\"Save automatically\"),\r\n            checkable=True,\r\n            enabled=True,\r\n        )\r\n        saveAuto.setChecked(self._config[\"auto_save\"])\r\n\r\n        saveWithImageData = action(\r\n            text=\"Save With Image Data\",\r\n            slot=self.enableSaveImageWithData,\r\n            tip=\"Save image data in label file\",\r\n            checkable=True,\r\n            checked=self._config[\"store_data\"],\r\n        )\r\n\r\n        close = action(\r\n            \"&Close\",\r\n            self.closeFile,\r\n            shortcuts[\"close\"],\r\n            \"close\",\r\n            \"Close current file\",\r\n        )\r\n\r\n        toggle_keep_prev_mode = action(\r\n            self.tr(\"Keep Previous Annotation\"),\r\n            self.toggleKeepPrevMode,\r\n            shortcuts[\"toggle_keep_prev_mode\"],\r\n            None,\r\n            self.tr('Toggle \"keep pevious annotation\" mode'),\r\n            checkable=True,\r\n        )\r\n        toggle_keep_prev_mode.setChecked(self._config[\"keep_prev\"])\r\n\r\n        createMode = action(\r\n            self.tr(\"Create Polygons\"),\r\n            lambda: self.toggleDrawMode(False, createMode=\"polygon\"),\r\n            shortcuts[\"create_polygon\"],\r\n            \"objects\",\r\n            self.tr(\"Start drawing polygons\"),\r\n"}
{"image_path": "data\\train\\00284.png", "code": "            enabled=False,\r\n        )\r\n        createRectangleMode = action(\r\n            self.tr(\"Create Rectangle\"),\r\n            lambda: self.toggleDrawMode(False, createMode=\"rectangle\"),\r\n            shortcuts[\"create_rectangle\"],\r\n            \"objects\",\r\n            self.tr(\"Start drawing rectangles\"),\r\n            enabled=False,\r\n        )\r\n        createCircleMode = action(\r\n            self.tr(\"Create Circle\"),\r\n            lambda: self.toggleDrawMode(False, createMode=\"circle\"),\r\n            shortcuts[\"create_circle\"],\r\n            \"objects\",\r\n            self.tr(\"Start drawing circles\"),\r\n            enabled=False,\r\n        )\r\n        createLineMode = action(\r\n            self.tr(\"Create Line\"),\r\n            lambda: self.toggleDrawMode(False, createMode=\"line\"),\r\n            shortcuts[\"create_line\"],\r\n            \"objects\",\r\n            self.tr(\"Start drawing lines\"),\r\n            enabled=False,\r\n        )\r\n        createPointMode = action(\r\n            self.tr(\"Create Point\"),\r\n            lambda: self.toggleDrawMode(False, createMode=\"point\"),\r\n            shortcuts[\"create_point\"],\r\n            \"objects\",\r\n            self.tr(\"Start drawing points\"),\r\n            enabled=False,\r\n        )\r\n        createLineStripMode = action(\r\n            self.tr(\"Create LineStrip\"),\r\n            lambda: self.toggleDrawMode(False, createMode=\"linestrip\"),\r\n            shortcuts[\"create_linestrip\"],\r\n            \"objects\",\r\n            self.tr(\"Start drawing linestrip. Ctrl+LeftClick ends creation.\"),\r\n"}
{"image_path": "data\\train\\00285.png", "code": "            enabled=False,\r\n        )\r\n        createAiPolygonMode = action(\r\n            self.tr(\"Create AI-Polygon\"),\r\n            lambda: self.toggleDrawMode(False, createMode=\"ai_polygon\"),\r\n            None,\r\n            \"objects\",\r\n            self.tr(\"Start drawing ai_polygon. Ctrl+LeftClick ends creation.\"),\r\n            enabled=False,\r\n        )\r\n        createAiPolygonMode.changed.connect(\r\n            lambda: self.canvas.initializeAiModel(\r\n                name=self._selectAiModelComboBox.currentText()\r\n            )\r\n            if self.canvas.createMode == \"ai_polygon\"\r\n            else None\r\n        )\r\n        createAiMaskMode = action(\r\n            self.tr(\"Create AI-Mask\"),\r\n            lambda: self.toggleDrawMode(False, createMode=\"ai_mask\"),\r\n            None,\r\n            \"objects\",\r\n            self.tr(\"Start drawing ai_mask. Ctrl+LeftClick ends creation.\"),\r\n            enabled=False,\r\n        )\r\n        createAiMaskMode.changed.connect(\r\n            lambda: self.canvas.initializeAiModel(\r\n                name=self._selectAiModelComboBox.currentText()\r\n            )\r\n            if self.canvas.createMode == \"ai_mask\"\r\n            else None\r\n        )\r\n        editMode = action(\r\n            self.tr(\"Edit Polygons\"),\r\n            self.setEditMode,\r\n            shortcuts[\"edit_polygon\"],\r\n            \"edit\",\r\n            self.tr(\"Move and edit the selected polygons\"),\r\n            enabled=False,\r\n        )\r\n"}
{"image_path": "data\\train\\00286.png", "code": "\r\n        delete = action(\r\n            self.tr(\"Delete Polygons\"),\r\n            self.deleteSelectedShape,\r\n            shortcuts[\"delete_polygon\"],\r\n            \"cancel\",\r\n            self.tr(\"Delete the selected polygons\"),\r\n            enabled=False,\r\n        )\r\n        duplicate = action(\r\n            self.tr(\"Duplicate Polygons\"),\r\n            self.duplicateSelectedShape,\r\n            shortcuts[\"duplicate_polygon\"],\r\n            \"copy\",\r\n            self.tr(\"Create a duplicate of the selected polygons\"),\r\n            enabled=False,\r\n        )\r\n        copy = action(\r\n            self.tr(\"Copy Polygons\"),\r\n            self.copySelectedShape,\r\n            shortcuts[\"copy_polygon\"],\r\n            \"copy_clipboard\",\r\n            self.tr(\"Copy selected polygons to clipboard\"),\r\n            enabled=False,\r\n        )\r\n        paste = action(\r\n            self.tr(\"Paste Polygons\"),\r\n            self.pasteSelectedShape,\r\n            shortcuts[\"paste_polygon\"],\r\n            \"paste\",\r\n            self.tr(\"Paste copied polygons\"),\r\n            enabled=False,\r\n        )\r\n        undoLastPoint = action(\r\n            self.tr(\"Undo last point\"),\r\n            self.canvas.undoLastPoint,\r\n            shortcuts[\"undo_last_point\"],\r\n            \"undo\",\r\n            self.tr(\"Undo last drawn point\"),\r\n            enabled=False,\r\n"}
{"image_path": "data\\train\\00287.png", "code": "        )\r\n        removePoint = action(\r\n            text=\"Remove Selected Point\",\r\n            slot=self.removeSelectedPoint,\r\n            shortcut=shortcuts[\"remove_selected_point\"],\r\n            icon=\"edit\",\r\n            tip=\"Remove selected point from polygon\",\r\n            enabled=False,\r\n        )\r\n\r\n        undo = action(\r\n            self.tr(\"Undo\\n\"),\r\n            self.undoShapeEdit,\r\n            shortcuts[\"undo\"],\r\n            \"undo\",\r\n            self.tr(\"Undo last add and edit of shape\"),\r\n            enabled=False,\r\n        )\r\n\r\n        hideAll = action(\r\n            self.tr(\"&Hide\\nPolygons\"),\r\n            functools.partial(self.togglePolygons, False),\r\n            shortcuts[\"hide_all_polygons\"],\r\n            icon=\"eye\",\r\n            tip=self.tr(\"Hide all polygons\"),\r\n            enabled=False,\r\n        )\r\n        showAll = action(\r\n            self.tr(\"&Show\\nPolygons\"),\r\n            functools.partial(self.togglePolygons, True),\r\n            shortcuts[\"show_all_polygons\"],\r\n            icon=\"eye\",\r\n            tip=self.tr(\"Show all polygons\"),\r\n            enabled=False,\r\n        )\r\n        toggleAll = action(\r\n            self.tr(\"&Toggle\\nPolygons\"),\r\n            functools.partial(self.togglePolygons, None),\r\n            shortcuts[\"toggle_all_polygons\"],\r\n            icon=\"eye\",\r\n"}
{"image_path": "data\\train\\00288.png", "code": "            tip=self.tr(\"Toggle all polygons\"),\r\n            enabled=False,\r\n        )\r\n\r\n        help = action(\r\n            self.tr(\"&Tutorial\"),\r\n            self.tutorial,\r\n            icon=\"help\",\r\n            tip=self.tr(\"Show tutorial page\"),\r\n        )\r\n\r\n        zoom = QtWidgets.QWidgetAction(self)\r\n        zoomBoxLayout = QtWidgets.QVBoxLayout()\r\n        zoomLabel = QtWidgets.QLabel(\"Zoom\")\r\n        zoomLabel.setAlignment(Qt.AlignCenter)\r\n        zoomBoxLayout.addWidget(zoomLabel)\r\n        zoomBoxLayout.addWidget(self.zoomWidget)\r\n        zoom.setDefaultWidget(QtWidgets.QWidget())\r\n        zoom.defaultWidget().setLayout(zoomBoxLayout)\r\n        self.zoomWidget.setWhatsThis(\r\n            str(\r\n                self.tr(\r\n                    \"Zoom in or out of the image. Also accessible with \"\r\n                    \"{} and {} from the canvas.\"\r\n                )\r\n            ).format(\r\n                utils.fmtShortcut(\r\n                    \"{},{}\".format(shortcuts[\"zoom_in\"], shortcuts[\"zoom_out\"])\r\n                ),\r\n                utils.fmtShortcut(self.tr(\"Ctrl+Wheel\")),\r\n            )\r\n        )\r\n        self.zoomWidget.setEnabled(False)\r\n\r\n        zoomIn = action(\r\n            self.tr(\"Zoom &In\"),\r\n            functools.partial(self.addZoom, 1.1),\r\n            shortcuts[\"zoom_in\"],\r\n            \"zoom-in\",\r\n            self.tr(\"Increase zoom level\"),\r\n"}
{"image_path": "data\\train\\00289.png", "code": "            enabled=False,\r\n        )\r\n        zoomOut = action(\r\n            self.tr(\"&Zoom Out\"),\r\n            functools.partial(self.addZoom, 0.9),\r\n            shortcuts[\"zoom_out\"],\r\n            \"zoom-out\",\r\n            self.tr(\"Decrease zoom level\"),\r\n            enabled=False,\r\n        )\r\n        zoomOrg = action(\r\n            self.tr(\"&Original size\"),\r\n            functools.partial(self.setZoom, 100),\r\n            shortcuts[\"zoom_to_original\"],\r\n            \"zoom\",\r\n            self.tr(\"Zoom to original size\"),\r\n            enabled=False,\r\n        )\r\n        keepPrevScale = action(\r\n            self.tr(\"&Keep Previous Scale\"),\r\n            self.enableKeepPrevScale,\r\n            tip=self.tr(\"Keep previous zoom scale\"),\r\n            checkable=True,\r\n            checked=self._config[\"keep_prev_scale\"],\r\n            enabled=True,\r\n        )\r\n        fitWindow = action(\r\n            self.tr(\"&Fit Window\"),\r\n            self.setFitWindow,\r\n            shortcuts[\"fit_window\"],\r\n            \"fit-window\",\r\n            self.tr(\"Zoom follows window size\"),\r\n            checkable=True,\r\n            enabled=False,\r\n        )\r\n        fitWidth = action(\r\n            self.tr(\"Fit &Width\"),\r\n            self.setFitWidth,\r\n            shortcuts[\"fit_width\"],\r\n            \"fit-width\",\r\n"}
{"image_path": "data\\train\\00290.png", "code": "            self.tr(\"Zoom follows window width\"),\r\n            checkable=True,\r\n            enabled=False,\r\n        )\r\n        brightnessContrast = action(\r\n            \"&Brightness Contrast\",\r\n            self.brightnessContrast,\r\n            None,\r\n            \"color\",\r\n            \"Adjust brightness and contrast\",\r\n            enabled=False,\r\n        )\r\n        # Group zoom controls into a list for easier toggling.\r\n        zoomActions = (\r\n            self.zoomWidget,\r\n            zoomIn,\r\n            zoomOut,\r\n            zoomOrg,\r\n            fitWindow,\r\n            fitWidth,\r\n        )\r\n        self.zoomMode = self.FIT_WINDOW\r\n        fitWindow.setChecked(Qt.Checked)\r\n        self.scalers = {\r\n            self.FIT_WINDOW: self.scaleFitWindow,\r\n            self.FIT_WIDTH: self.scaleFitWidth,\r\n            # Set to one to scale to 100% when loading files.\r\n            self.MANUAL_ZOOM: lambda: 1,\r\n        }\r\n\r\n        edit = action(\r\n            self.tr(\"&Edit Label\"),\r\n            self.editLabel,\r\n            shortcuts[\"edit_label\"],\r\n            \"edit\",\r\n            self.tr(\"Modify the label of the selected polygon\"),\r\n            enabled=False,\r\n        )\r\n\r\n        fill_drawing = action(\r\n"}
{"image_path": "data\\train\\00291.png", "code": "            self.tr(\"Fill Drawing Polygon\"),\r\n            self.canvas.setFillDrawing,\r\n            None,\r\n            \"color\",\r\n            self.tr(\"Fill polygon while drawing\"),\r\n            checkable=True,\r\n            enabled=True,\r\n        )\r\n        if self._config[\"canvas\"][\"fill_drawing\"]:\r\n            fill_drawing.trigger()\r\n\r\n        # Lavel list context menu.\r\n        labelMenu = QtWidgets.QMenu()\r\n        utils.addActions(labelMenu, (edit, delete))\r\n        self.labelList.setContextMenuPolicy(Qt.CustomContextMenu)\r\n        self.labelList.customContextMenuRequested.connect(self.popLabelListMenu)\r\n\r\n        # Store actions for further handling.\r\n        self.actions = utils.struct(\r\n            saveAuto=saveAuto,\r\n            saveWithImageData=saveWithImageData,\r\n            changeOutputDir=changeOutputDir,\r\n            save=save,\r\n            saveAs=saveAs,\r\n            open=open_,\r\n            close=close,\r\n            deleteFile=deleteFile,\r\n            toggleKeepPrevMode=toggle_keep_prev_mode,\r\n            delete=delete,\r\n            edit=edit,\r\n            duplicate=duplicate,\r\n            copy=copy,\r\n            paste=paste,\r\n            undoLastPoint=undoLastPoint,\r\n            undo=undo,\r\n            removePoint=removePoint,\r\n            createMode=createMode,\r\n            editMode=editMode,\r\n            createRectangleMode=createRectangleMode,\r\n            createCircleMode=createCircleMode,\r\n"}
{"image_path": "data\\train\\00292.png", "code": "            createLineMode=createLineMode,\r\n            createPointMode=createPointMode,\r\n            createLineStripMode=createLineStripMode,\r\n            createAiPolygonMode=createAiPolygonMode,\r\n            createAiMaskMode=createAiMaskMode,\r\n            zoom=zoom,\r\n            zoomIn=zoomIn,\r\n            zoomOut=zoomOut,\r\n            zoomOrg=zoomOrg,\r\n            keepPrevScale=keepPrevScale,\r\n            fitWindow=fitWindow,\r\n            fitWidth=fitWidth,\r\n            brightnessContrast=brightnessContrast,\r\n            zoomActions=zoomActions,\r\n            openNextImg=openNextImg,\r\n            openPrevImg=openPrevImg,\r\n            fileMenuActions=(open_, opendir, save, saveAs, close, quit),\r\n            tool=(),\r\n            # XXX: need to add some actions here to activate the shortcut\r\n            editMenu=(\r\n                edit,\r\n                duplicate,\r\n                copy,\r\n                paste,\r\n                delete,\r\n                None,\r\n                undo,\r\n                undoLastPoint,\r\n                None,\r\n                removePoint,\r\n                None,\r\n                toggle_keep_prev_mode,\r\n            ),\r\n            # menu shown at right click\r\n            menu=(\r\n                createMode,\r\n                createRectangleMode,\r\n                createCircleMode,\r\n                createLineMode,\r\n                createPointMode,\r\n"}
{"image_path": "data\\train\\00293.png", "code": "                createLineStripMode,\r\n                createAiPolygonMode,\r\n                createAiMaskMode,\r\n                editMode,\r\n                edit,\r\n                duplicate,\r\n                copy,\r\n                paste,\r\n                delete,\r\n                undo,\r\n                undoLastPoint,\r\n                removePoint,\r\n            ),\r\n            onLoadActive=(\r\n                close,\r\n                createMode,\r\n                createRectangleMode,\r\n                createCircleMode,\r\n                createLineMode,\r\n                createPointMode,\r\n                createLineStripMode,\r\n                createAiPolygonMode,\r\n                createAiMaskMode,\r\n                editMode,\r\n                brightnessContrast,\r\n            ),\r\n            onShapesPresent=(saveAs, hideAll, showAll, toggleAll),\r\n        )\r\n\r\n        self.canvas.vertexSelected.connect(self.actions.removePoint.setEnabled)\r\n\r\n        self.menus = utils.struct(\r\n            file=self.menu(self.tr(\"&File\")),\r\n            edit=self.menu(self.tr(\"&Edit\")),\r\n            view=self.menu(self.tr(\"&View\")),\r\n            help=self.menu(self.tr(\"&Help\")),\r\n            recentFiles=QtWidgets.QMenu(self.tr(\"Open &Recent\")),\r\n            labelList=labelMenu,\r\n        )\r\n\r\n"}
{"image_path": "data\\train\\00294.png", "code": "        utils.addActions(\r\n            self.menus.file,\r\n            (\r\n                open_,\r\n                openNextImg,\r\n                openPrevImg,\r\n                opendir,\r\n                self.menus.recentFiles,\r\n                save,\r\n                saveAs,\r\n                saveAuto,\r\n                changeOutputDir,\r\n                saveWithImageData,\r\n                close,\r\n                deleteFile,\r\n                None,\r\n                quit,\r\n            ),\r\n        )\r\n        utils.addActions(self.menus.help, (help,))\r\n        utils.addActions(\r\n            self.menus.view,\r\n            (\r\n                self.flag_dock.toggleViewAction(),\r\n                self.label_dock.toggleViewAction(),\r\n                self.shape_dock.toggleViewAction(),\r\n                self.file_dock.toggleViewAction(),\r\n                None,\r\n                fill_drawing,\r\n                None,\r\n                hideAll,\r\n                showAll,\r\n                toggleAll,\r\n                None,\r\n                zoomIn,\r\n                zoomOut,\r\n                zoomOrg,\r\n                keepPrevScale,\r\n                None,\r\n                fitWindow,\r\n"}
{"image_path": "data\\train\\00295.png", "code": "                fitWidth,\r\n                None,\r\n                brightnessContrast,\r\n            ),\r\n        )\r\n\r\n        self.menus.file.aboutToShow.connect(self.updateFileMenu)\r\n\r\n        # Custom context menu for the canvas widget:\r\n        utils.addActions(self.canvas.menus[0], self.actions.menu)\r\n        utils.addActions(\r\n            self.canvas.menus[1],\r\n            (\r\n                action(\"&Copy here\", self.copyShape),\r\n                action(\"&Move here\", self.moveShape),\r\n            ),\r\n        )\r\n\r\n        selectAiModel = QtWidgets.QWidgetAction(self)\r\n        selectAiModel.setDefaultWidget(QtWidgets.QWidget())\r\n        selectAiModel.defaultWidget().setLayout(QtWidgets.QVBoxLayout())\r\n        #\r\n        selectAiModelLabel = QtWidgets.QLabel(self.tr(\"AI Model\"))\r\n        selectAiModelLabel.setAlignment(QtCore.Qt.AlignCenter)\r\n        selectAiModel.defaultWidget().layout().addWidget(selectAiModelLabel)\r\n        #\r\n        self._selectAiModelComboBox = QtWidgets.QComboBox()\r\n        selectAiModel.defaultWidget().layout().addWidget(self._selectAiModelComboBox)\r\n        model_names = [model.name for model in MODELS]\r\n        self._selectAiModelComboBox.addItems(model_names)\r\n        if self._config[\"ai\"][\"default\"] in model_names:\r\n            model_index = model_names.index(self._config[\"ai\"][\"default\"])\r\n        else:\r\n            logger.warning(\r\n                \"Default AI model is not found: %r\",\r\n                self._config[\"ai\"][\"default\"],\r\n            )\r\n            model_index = 0\r\n        self._selectAiModelComboBox.setCurrentIndex(model_index)\r\n        self._selectAiModelComboBox.currentIndexChanged.connect(\r\n"}
{"image_path": "data\\train\\00296.png", "code": "            lambda: self.canvas.initializeAiModel(\r\n                name=self._selectAiModelComboBox.currentText()\r\n            )\r\n            if self.canvas.createMode in [\"ai_polygon\", \"ai_mask\"]\r\n            else None\r\n        )\r\n\r\n        self.tools = self.toolbar(\"Tools\")\r\n        self.actions.tool = (\r\n            open_,\r\n            opendir,\r\n            openPrevImg,\r\n            openNextImg,\r\n            save,\r\n            deleteFile,\r\n            None,\r\n            createMode,\r\n            editMode,\r\n            duplicate,\r\n            delete,\r\n            undo,\r\n            brightnessContrast,\r\n            None,\r\n            fitWindow,\r\n            zoom,\r\n            None,\r\n            selectAiModel,\r\n        )\r\n\r\n        self.statusBar().showMessage(str(self.tr(\"%s started.\")) % __appname__)\r\n        self.statusBar().show()\r\n\r\n        if output_file is not None and self._config[\"auto_save\"]:\r\n            logger.warn(\r\n                \"If `auto_save` argument is True, `output_file` argument \"\r\n                \"is ignored and output filename is automatically \"\r\n                \"set as IMAGE_BASENAME.json.\"\r\n            )\r\n        self.output_file = output_file\r\n        self.output_dir = output_dir\r\n"}
{"image_path": "data\\train\\00297.png", "code": "\r\n        # Application state.\r\n        self.image = QtGui.QImage()\r\n        self.imagePath = None\r\n        self.recentFiles = []\r\n        self.maxRecent = 7\r\n        self.otherData = None\r\n        self.zoom_level = 100\r\n        self.fit_window = False\r\n        self.zoom_values = {}  # key=filename, value=(zoom_mode, zoom_value)\r\n        self.brightnessContrast_values = {}\r\n        self.scroll_values = {\r\n            Qt.Horizontal: {},\r\n            Qt.Vertical: {},\r\n        }  # key=filename, value=scroll_value\r\n\r\n        if filename is not None and osp.isdir(filename):\r\n            self.importDirImages(filename, load=False)\r\n        else:\r\n            self.filename = filename\r\n\r\n        if config[\"file_search\"]:\r\n            self.fileSearch.setText(config[\"file_search\"])\r\n            self.fileSearchChanged()\r\n\r\n        # XXX: Could be completely declarative.\r\n        # Restore application settings.\r\n        self.settings = QtCore.QSettings(\"labelme\", \"labelme\")\r\n        self.recentFiles = self.settings.value(\"recentFiles\", []) or []\r\n        size = self.settings.value(\"window/size\", QtCore.QSize(600, 500))\r\n        position = self.settings.value(\"window/position\", QtCore.QPoint(0, 0))\r\n        state = self.settings.value(\"window/state\", QtCore.QByteArray())\r\n        self.resize(size)\r\n        self.move(position)\r\n        # or simply:\r\n        # self.restoreGeometry(settings['window/geometry']\r\n        self.restoreState(state)\r\n\r\n        # Populate the File menu dynamically.\r\n        self.updateFileMenu()\r\n"}
{"image_path": "data\\train\\00298.png", "code": "        # Since loading the file may take some time,\r\n        # make sure it runs in the background.\r\n        if self.filename is not None:\r\n            self.queueEvent(functools.partial(self.loadFile, self.filename))\r\n\r\n        # Callbacks:\r\n        self.zoomWidget.valueChanged.connect(self.paintCanvas)\r\n\r\n        self.populateModeActions()\r\n\r\n        # self.firstStart = True\r\n        # if self.firstStart:\r\n        #    QWhatsThis.enterWhatsThisMode()\r\n\r\n    def menu(self, title, actions=None):\r\n        menu = self.menuBar().addMenu(title)\r\n        if actions:\r\n            utils.addActions(menu, actions)\r\n        return menu\r\n\r\n    def toolbar(self, title, actions=None):\r\n        toolbar = ToolBar(title)\r\n        toolbar.setObjectName(\"%sToolBar\" % title)\r\n        # toolbar.setOrientation(Qt.Vertical)\r\n        toolbar.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)\r\n        if actions:\r\n            utils.addActions(toolbar, actions)\r\n        self.addToolBar(Qt.TopToolBarArea, toolbar)\r\n        return toolbar\r\n\r\n    # Support Functions\r\n\r\n    def noShapes(self):\r\n        return not len(self.labelList)\r\n\r\n    def populateModeActions(self):\r\n        tool, menu = self.actions.tool, self.actions.menu\r\n        self.tools.clear()\r\n        utils.addActions(self.tools, tool)\r\n        self.canvas.menus[0].clear()\r\n"}
{"image_path": "data\\train\\00299.png", "code": "        utils.addActions(self.canvas.menus[0], menu)\r\n        self.menus.edit.clear()\r\n        actions = (\r\n            self.actions.createMode,\r\n            self.actions.createRectangleMode,\r\n            self.actions.createCircleMode,\r\n            self.actions.createLineMode,\r\n            self.actions.createPointMode,\r\n            self.actions.createLineStripMode,\r\n            self.actions.createAiPolygonMode,\r\n            self.actions.createAiMaskMode,\r\n            self.actions.editMode,\r\n        )\r\n        utils.addActions(self.menus.edit, actions + self.actions.editMenu)\r\n\r\n    def setDirty(self):\r\n        # Even if we autosave the file, we keep the ability to undo\r\n        self.actions.undo.setEnabled(self.canvas.isShapeRestorable)\r\n\r\n        if self._config[\"auto_save\"] or self.actions.saveAuto.isChecked():\r\n            label_file = osp.splitext(self.imagePath)[0] + \".json\"\r\n            if self.output_dir:\r\n                label_file_without_path = osp.basename(label_file)\r\n                label_file = osp.join(self.output_dir, label_file_without_path)\r\n            self.saveLabels(label_file)\r\n            return\r\n        self.dirty = True\r\n        self.actions.save.setEnabled(True)\r\n        title = __appname__\r\n        if self.filename is not None:\r\n            title = \"{} - {}*\".format(title, self.filename)\r\n        self.setWindowTitle(title)\r\n\r\n    def setClean(self):\r\n        self.dirty = False\r\n        self.actions.save.setEnabled(False)\r\n        self.actions.createMode.setEnabled(True)\r\n        self.actions.createRectangleMode.setEnabled(True)\r\n        self.actions.createCircleMode.setEnabled(True)\r\n        self.actions.createLineMode.setEnabled(True)\r\n"}
{"image_path": "data\\train\\00300.png", "code": "        self.actions.createPointMode.setEnabled(True)\r\n        self.actions.createLineStripMode.setEnabled(True)\r\n        self.actions.createAiPolygonMode.setEnabled(True)\r\n        self.actions.createAiMaskMode.setEnabled(True)\r\n        title = __appname__\r\n        if self.filename is not None:\r\n            title = \"{} - {}\".format(title, self.filename)\r\n        self.setWindowTitle(title)\r\n\r\n        if self.hasLabelFile():\r\n            self.actions.deleteFile.setEnabled(True)\r\n        else:\r\n            self.actions.deleteFile.setEnabled(False)\r\n\r\n    def toggleActions(self, value=True):\r\n        \"\"\"Enable/Disable widgets which depend on an opened image.\"\"\"\r\n        for z in self.actions.zoomActions:\r\n            z.setEnabled(value)\r\n        for action in self.actions.onLoadActive:\r\n            action.setEnabled(value)\r\n\r\n    def queueEvent(self, function):\r\n        QtCore.QTimer.singleShot(0, function)\r\n\r\n    def status(self, message, delay=5000):\r\n        self.statusBar().showMessage(message, delay)\r\n\r\n    def resetState(self):\r\n        self.labelList.clear()\r\n        self.filename = None\r\n        self.imagePath = None\r\n        self.imageData = None\r\n        self.labelFile = None\r\n        self.otherData = None\r\n        self.canvas.resetState()\r\n\r\n    def currentItem(self):\r\n        items = self.labelList.selectedItems()\r\n        if items:\r\n            return items[0]\r\n"}
{"image_path": "data\\train\\00301.png", "code": "        return None\r\n\r\n    def addRecentFile(self, filename):\r\n        if filename in self.recentFiles:\r\n            self.recentFiles.remove(filename)\r\n        elif len(self.recentFiles) >= self.maxRecent:\r\n            self.recentFiles.pop()\r\n        self.recentFiles.insert(0, filename)\r\n\r\n    # Callbacks\r\n\r\n    def undoShapeEdit(self):\r\n        self.canvas.restoreShape()\r\n        self.labelList.clear()\r\n        self.loadShapes(self.canvas.shapes)\r\n        self.actions.undo.setEnabled(self.canvas.isShapeRestorable)\r\n\r\n    def tutorial(self):\r\n        url = \"https://github.com/wkentaro/labelme/tree/main/examples/tutorial\"  # NOQA\r\n        webbrowser.open(url)\r\n\r\n    def toggleDrawingSensitive(self, drawing=True):\r\n        \"\"\"Toggle drawing sensitive.\r\n\r\n        In the middle of drawing, toggling between modes should be disabled.\r\n        \"\"\"\r\n        self.actions.editMode.setEnabled(not drawing)\r\n        self.actions.undoLastPoint.setEnabled(drawing)\r\n        self.actions.undo.setEnabled(not drawing)\r\n        self.actions.delete.setEnabled(not drawing)\r\n\r\n    def toggleDrawMode(self, edit=True, createMode=\"polygon\"):\r\n        draw_actions = {\r\n            \"polygon\": self.actions.createMode,\r\n            \"rectangle\": self.actions.createRectangleMode,\r\n            \"circle\": self.actions.createCircleMode,\r\n            \"point\": self.actions.createPointMode,\r\n            \"line\": self.actions.createLineMode,\r\n            \"linestrip\": self.actions.createLineStripMode,\r\n            \"ai_polygon\": self.actions.createAiPolygonMode,\r\n"}
{"image_path": "data\\train\\00302.png", "code": "            \"ai_mask\": self.actions.createAiMaskMode,\r\n        }\r\n\r\n        self.canvas.setEditing(edit)\r\n        self.canvas.createMode = createMode\r\n        if edit:\r\n            for draw_action in draw_actions.values():\r\n                draw_action.setEnabled(True)\r\n        else:\r\n            for draw_mode, draw_action in draw_actions.items():\r\n                draw_action.setEnabled(createMode != draw_mode)\r\n        self.actions.editMode.setEnabled(not edit)\r\n\r\n    def setEditMode(self):\r\n        self.toggleDrawMode(True)\r\n\r\n    def updateFileMenu(self):\r\n        current = self.filename\r\n\r\n        def exists(filename):\r\n            return osp.exists(str(filename))\r\n\r\n        menu = self.menus.recentFiles\r\n        menu.clear()\r\n        files = [f for f in self.recentFiles if f != current and exists(f)]\r\n        for i, f in enumerate(files):\r\n            icon = utils.newIcon(\"labels\")\r\n            action = QtWidgets.QAction(\r\n                icon, \"&%d %s\" % (i + 1, QtCore.QFileInfo(f).fileName()), self\r\n            )\r\n            action.triggered.connect(functools.partial(self.loadRecent, f))\r\n            menu.addAction(action)\r\n\r\n    def popLabelListMenu(self, point):\r\n        self.menus.labelList.exec_(self.labelList.mapToGlobal(point))\r\n\r\n    def validateLabel(self, label):\r\n        # no validation\r\n        if self._config[\"validate_label\"] is None:\r\n            return True\r\n"}
{"image_path": "data\\train\\00303.png", "code": "\r\n        for i in range(self.uniqLabelList.count()):\r\n            label_i = self.uniqLabelList.item(i).data(Qt.UserRole)\r\n            if self._config[\"validate_label\"] in [\"exact\"]:\r\n                if label_i == label:\r\n                    return True\r\n        return False\r\n\r\n    def editLabel(self, item=None):\r\n        if item and not isinstance(item, LabelListWidgetItem):\r\n            raise TypeError(\"item must be LabelListWidgetItem type\")\r\n\r\n        if not self.canvas.editing():\r\n            return\r\n        if not item:\r\n            item = self.currentItem()\r\n        if item is None:\r\n            return\r\n        shape = item.shape()\r\n        if shape is None:\r\n            return\r\n        text, flags, group_id, description = self.labelDialog.popUp(\r\n            text=shape.label,\r\n            flags=shape.flags,\r\n            group_id=shape.group_id,\r\n            description=shape.description,\r\n        )\r\n        if text is None:\r\n            return\r\n        if not self.validateLabel(text):\r\n            self.errorMessage(\r\n                self.tr(\"Invalid label\"),\r\n                self.tr(\"Invalid label '{}' with validation type '{}'\").format(\r\n                    text, self._config[\"validate_label\"]\r\n                ),\r\n            )\r\n            return\r\n        shape.label = text\r\n        shape.flags = flags\r\n        shape.group_id = group_id\r\n"}
{"image_path": "data\\train\\00304.png", "code": "        shape.description = description\r\n\r\n        self._update_shape_color(shape)\r\n        if shape.group_id is None:\r\n            item.setText(\r\n                '{} <font color=\"#{:02x}{:02x}{:02x}\">\u25cf</font>'.format(\r\n                    html.escape(shape.label), *shape.fill_color.getRgb()[:3]\r\n                )\r\n            )\r\n        else:\r\n            item.setText(\"{} ({})\".format(shape.label, shape.group_id))\r\n        self.setDirty()\r\n        if self.uniqLabelList.findItemByLabel(shape.label) is None:\r\n            item = self.uniqLabelList.createItemFromLabel(shape.label)\r\n            self.uniqLabelList.addItem(item)\r\n            rgb = self._get_rgb_by_label(shape.label)\r\n            self.uniqLabelList.setItemLabel(item, shape.label, rgb)\r\n\r\n    def fileSearchChanged(self):\r\n        self.importDirImages(\r\n            self.lastOpenDir,\r\n            pattern=self.fileSearch.text(),\r\n            load=False,\r\n        )\r\n\r\n    def fileSelectionChanged(self):\r\n        items = self.fileListWidget.selectedItems()\r\n        if not items:\r\n            return\r\n        item = items[0]\r\n\r\n        if not self.mayContinue():\r\n            return\r\n\r\n        currIndex = self.imageList.index(str(item.text()))\r\n        if currIndex < len(self.imageList):\r\n            filename = self.imageList[currIndex]\r\n            if filename:\r\n                self.loadFile(filename)\r\n\r\n"}
{"image_path": "data\\train\\00305.png", "code": "    # React to canvas signals.\r\n    def shapeSelectionChanged(self, selected_shapes):\r\n        self._noSelectionSlot = True\r\n        for shape in self.canvas.selectedShapes:\r\n            shape.selected = False\r\n        self.labelList.clearSelection()\r\n        self.canvas.selectedShapes = selected_shapes\r\n        for shape in self.canvas.selectedShapes:\r\n            shape.selected = True\r\n            item = self.labelList.findItemByShape(shape)\r\n            self.labelList.selectItem(item)\r\n            self.labelList.scrollToItem(item)\r\n        self._noSelectionSlot = False\r\n        n_selected = len(selected_shapes)\r\n        self.actions.delete.setEnabled(n_selected)\r\n        self.actions.duplicate.setEnabled(n_selected)\r\n        self.actions.copy.setEnabled(n_selected)\r\n        self.actions.edit.setEnabled(n_selected == 1)\r\n\r\n    def addLabel(self, shape):\r\n        if shape.group_id is None:\r\n            text = shape.label\r\n        else:\r\n            text = \"{} ({})\".format(shape.label, shape.group_id)\r\n        label_list_item = LabelListWidgetItem(text, shape)\r\n        self.labelList.addItem(label_list_item)\r\n        if self.uniqLabelList.findItemByLabel(shape.label) is None:\r\n            item = self.uniqLabelList.createItemFromLabel(shape.label)\r\n            self.uniqLabelList.addItem(item)\r\n            rgb = self._get_rgb_by_label(shape.label)\r\n            self.uniqLabelList.setItemLabel(item, shape.label, rgb)\r\n        self.labelDialog.addLabelHistory(shape.label)\r\n        for action in self.actions.onShapesPresent:\r\n            action.setEnabled(True)\r\n\r\n        self._update_shape_color(shape)\r\n        label_list_item.setText(\r\n            '{} <font color=\"#{:02x}{:02x}{:02x}\">\u25cf</font>'.format(\r\n                html.escape(text), *shape.fill_color.getRgb()[:3]\r\n            )\r\n"}
{"image_path": "data\\train\\00306.png", "code": "        )\r\n\r\n    def _update_shape_color(self, shape):\r\n        r, g, b = self._get_rgb_by_label(shape.label)\r\n        shape.line_color = QtGui.QColor(r, g, b)\r\n        shape.vertex_fill_color = QtGui.QColor(r, g, b)\r\n        shape.hvertex_fill_color = QtGui.QColor(255, 255, 255)\r\n        shape.fill_color = QtGui.QColor(r, g, b, 128)\r\n        shape.select_line_color = QtGui.QColor(255, 255, 255)\r\n        shape.select_fill_color = QtGui.QColor(r, g, b, 155)\r\n\r\n    def _get_rgb_by_label(self, label):\r\n        if self._config[\"shape_color\"] == \"auto\":\r\n            item = self.uniqLabelList.findItemByLabel(label)\r\n            if item is None:\r\n                item = self.uniqLabelList.createItemFromLabel(label)\r\n                self.uniqLabelList.addItem(item)\r\n                rgb = self._get_rgb_by_label(label)\r\n                self.uniqLabelList.setItemLabel(item, label, rgb)\r\n            label_id = self.uniqLabelList.indexFromItem(item).row() + 1\r\n            label_id += self._config[\"shift_auto_shape_color\"]\r\n            return LABEL_COLORMAP[label_id % len(LABEL_COLORMAP)]\r\n        elif (\r\n            self._config[\"shape_color\"] == \"manual\"\r\n            and self._config[\"label_colors\"]\r\n            and label in self._config[\"label_colors\"]\r\n        ):\r\n            return self._config[\"label_colors\"][label]\r\n        elif self._config[\"default_shape_color\"]:\r\n            return self._config[\"default_shape_color\"]\r\n        return (0, 255, 0)\r\n\r\n    def remLabels(self, shapes):\r\n        for shape in shapes:\r\n            item = self.labelList.findItemByShape(shape)\r\n            self.labelList.removeItem(item)\r\n\r\n    def loadShapes(self, shapes, replace=True):\r\n        self._noSelectionSlot = True\r\n        for shape in shapes:\r\n"}
{"image_path": "data\\train\\00307.png", "code": "            self.addLabel(shape)\r\n        self.labelList.clearSelection()\r\n        self._noSelectionSlot = False\r\n        self.canvas.loadShapes(shapes, replace=replace)\r\n\r\n    def loadLabels(self, shapes):\r\n        s = []\r\n        for shape in shapes:\r\n            label = shape[\"label\"]\r\n            points = shape[\"points\"]\r\n            shape_type = shape[\"shape_type\"]\r\n            flags = shape[\"flags\"]\r\n            description = shape.get(\"description\", \"\")\r\n            group_id = shape[\"group_id\"]\r\n            other_data = shape[\"other_data\"]\r\n\r\n            if not points:\r\n                # skip point-empty shape\r\n                continue\r\n\r\n            shape = Shape(\r\n                label=label,\r\n                shape_type=shape_type,\r\n                group_id=group_id,\r\n                description=description,\r\n                mask=shape[\"mask\"],\r\n            )\r\n            for x, y in points:\r\n                shape.addPoint(QtCore.QPointF(x, y))\r\n            shape.close()\r\n\r\n            default_flags = {}\r\n            if self._config[\"label_flags\"]:\r\n                for pattern, keys in self._config[\"label_flags\"].items():\r\n                    if re.match(pattern, label):\r\n                        for key in keys:\r\n                            default_flags[key] = False\r\n            shape.flags = default_flags\r\n            shape.flags.update(flags)\r\n            shape.other_data = other_data\r\n"}
{"image_path": "data\\train\\00308.png", "code": "\r\n            s.append(shape)\r\n        self.loadShapes(s)\r\n\r\n    def loadFlags(self, flags):\r\n        self.flag_widget.clear()\r\n        for key, flag in flags.items():\r\n            item = QtWidgets.QListWidgetItem(key)\r\n            item.setFlags(item.flags() | Qt.ItemIsUserCheckable)\r\n            item.setCheckState(Qt.Checked if flag else Qt.Unchecked)\r\n            self.flag_widget.addItem(item)\r\n\r\n    def saveLabels(self, filename):\r\n        lf = LabelFile()\r\n\r\n        def format_shape(s):\r\n            data = s.other_data.copy()\r\n            data.update(\r\n                dict(\r\n                    label=s.label.encode(\"utf-8\") if PY2 else s.label,\r\n                    points=[(p.x(), p.y()) for p in s.points],\r\n                    group_id=s.group_id,\r\n                    description=s.description,\r\n                    shape_type=s.shape_type,\r\n                    flags=s.flags,\r\n                    mask=None if s.mask is None else utils.img_arr_to_b64(s.mask),\r\n                )\r\n            )\r\n            return data\r\n\r\n        shapes = [format_shape(item.shape()) for item in self.labelList]\r\n        flags = {}\r\n        for i in range(self.flag_widget.count()):\r\n            item = self.flag_widget.item(i)\r\n            key = item.text()\r\n            flag = item.checkState() == Qt.Checked\r\n            flags[key] = flag\r\n        try:\r\n            imagePath = osp.relpath(self.imagePath, osp.dirname(filename))\r\n            imageData = self.imageData if self._config[\"store_data\"] else None\r\n"}
{"image_path": "data\\train\\00309.png", "code": "            if osp.dirname(filename) and not osp.exists(osp.dirname(filename)):\r\n                os.makedirs(osp.dirname(filename))\r\n            lf.save(\r\n                filename=filename,\r\n                shapes=shapes,\r\n                imagePath=imagePath,\r\n                imageData=imageData,\r\n                imageHeight=self.image.height(),\r\n                imageWidth=self.image.width(),\r\n                otherData=self.otherData,\r\n                flags=flags,\r\n            )\r\n            self.labelFile = lf\r\n            items = self.fileListWidget.findItems(self.imagePath, Qt.MatchExactly)\r\n            if len(items) > 0:\r\n                if len(items) != 1:\r\n                    raise RuntimeError(\"There are duplicate files.\")\r\n                items[0].setCheckState(Qt.Checked)\r\n            # disable allows next and previous image to proceed\r\n            # self.filename = filename\r\n            return True\r\n        except LabelFileError as e:\r\n            self.errorMessage(\r\n                self.tr(\"Error saving label data\"), self.tr(\"<b>%s</b>\") % e\r\n            )\r\n            return False\r\n\r\n    def duplicateSelectedShape(self):\r\n        added_shapes = self.canvas.duplicateSelectedShapes()\r\n        for shape in added_shapes:\r\n            self.addLabel(shape)\r\n        self.setDirty()\r\n\r\n    def pasteSelectedShape(self):\r\n        self.loadShapes(self._copied_shapes, replace=False)\r\n        self.setDirty()\r\n\r\n    def copySelectedShape(self):\r\n        self._copied_shapes = [s.copy() for s in self.canvas.selectedShapes]\r\n        self.actions.paste.setEnabled(len(self._copied_shapes) > 0)\r\n"}
{"image_path": "data\\train\\00310.png", "code": "\r\n    def labelSelectionChanged(self):\r\n        if self._noSelectionSlot:\r\n            return\r\n        if self.canvas.editing():\r\n            selected_shapes = []\r\n            for item in self.labelList.selectedItems():\r\n                selected_shapes.append(item.shape())\r\n            if selected_shapes:\r\n                self.canvas.selectShapes(selected_shapes)\r\n            else:\r\n                self.canvas.deSelectShape()\r\n\r\n    def labelItemChanged(self, item):\r\n        shape = item.shape()\r\n        self.canvas.setShapeVisible(shape, item.checkState() == Qt.Checked)\r\n\r\n    def labelOrderChanged(self):\r\n        self.setDirty()\r\n        self.canvas.loadShapes([item.shape() for item in self.labelList])\r\n\r\n    # Callback functions:\r\n\r\n    def newShape(self):\r\n        \"\"\"Pop-up and give focus to the label editor.\r\n\r\n        position MUST be in global coordinates.\r\n        \"\"\"\r\n        items = self.uniqLabelList.selectedItems()\r\n        text = None\r\n        if items:\r\n            text = items[0].data(Qt.UserRole)\r\n        flags = {}\r\n        group_id = None\r\n        description = \"\"\r\n        if self._config[\"display_label_popup\"] or not text:\r\n            previous_text = self.labelDialog.edit.text()\r\n            text, flags, group_id, description = self.labelDialog.popUp(text)\r\n            if not text:\r\n                self.labelDialog.edit.setText(previous_text)\r\n"}
{"image_path": "data\\train\\00311.png", "code": "\r\n        if text and not self.validateLabel(text):\r\n            self.errorMessage(\r\n                self.tr(\"Invalid label\"),\r\n                self.tr(\"Invalid label '{}' with validation type '{}'\").format(\r\n                    text, self._config[\"validate_label\"]\r\n                ),\r\n            )\r\n            text = \"\"\r\n        if text:\r\n            self.labelList.clearSelection()\r\n            shape = self.canvas.setLastLabel(text, flags)\r\n            shape.group_id = group_id\r\n            shape.description = description\r\n            self.addLabel(shape)\r\n            self.actions.editMode.setEnabled(True)\r\n            self.actions.undoLastPoint.setEnabled(False)\r\n            self.actions.undo.setEnabled(True)\r\n            self.setDirty()\r\n        else:\r\n            self.canvas.undoLastLine()\r\n            self.canvas.shapesBackups.pop()\r\n\r\n    def scrollRequest(self, delta, orientation):\r\n        units = -delta * 0.1  # natural scroll\r\n        bar = self.scrollBars[orientation]\r\n        value = bar.value() + bar.singleStep() * units\r\n        self.setScroll(orientation, value)\r\n\r\n    def setScroll(self, orientation, value):\r\n        self.scrollBars[orientation].setValue(int(value))\r\n        self.scroll_values[orientation][self.filename] = value\r\n\r\n    def setZoom(self, value):\r\n        self.actions.fitWidth.setChecked(False)\r\n        self.actions.fitWindow.setChecked(False)\r\n        self.zoomMode = self.MANUAL_ZOOM\r\n        self.zoomWidget.setValue(value)\r\n        self.zoom_values[self.filename] = (self.zoomMode, value)\r\n\r\n"}
{"image_path": "data\\train\\00312.png", "code": "    def addZoom(self, increment=1.1):\r\n        zoom_value = self.zoomWidget.value() * increment\r\n        if increment > 1:\r\n            zoom_value = math.ceil(zoom_value)\r\n        else:\r\n            zoom_value = math.floor(zoom_value)\r\n        self.setZoom(zoom_value)\r\n\r\n    def zoomRequest(self, delta, pos):\r\n        canvas_width_old = self.canvas.width()\r\n        units = 1.1\r\n        if delta < 0:\r\n            units = 0.9\r\n        self.addZoom(units)\r\n\r\n        canvas_width_new = self.canvas.width()\r\n        if canvas_width_old != canvas_width_new:\r\n            canvas_scale_factor = canvas_width_new / canvas_width_old\r\n\r\n            x_shift = round(pos.x() * canvas_scale_factor) - pos.x()\r\n            y_shift = round(pos.y() * canvas_scale_factor) - pos.y()\r\n\r\n            self.setScroll(\r\n                Qt.Horizontal,\r\n                self.scrollBars[Qt.Horizontal].value() + x_shift,\r\n            )\r\n            self.setScroll(\r\n                Qt.Vertical,\r\n                self.scrollBars[Qt.Vertical].value() + y_shift,\r\n            )\r\n\r\n    def setFitWindow(self, value=True):\r\n        if value:\r\n            self.actions.fitWidth.setChecked(False)\r\n        self.zoomMode = self.FIT_WINDOW if value else self.MANUAL_ZOOM\r\n        self.adjustScale()\r\n\r\n    def setFitWidth(self, value=True):\r\n        if value:\r\n            self.actions.fitWindow.setChecked(False)\r\n"}
{"image_path": "data\\train\\00313.png", "code": "        self.zoomMode = self.FIT_WIDTH if value else self.MANUAL_ZOOM\r\n        self.adjustScale()\r\n\r\n    def enableKeepPrevScale(self, enabled):\r\n        self._config[\"keep_prev_scale\"] = enabled\r\n        self.actions.keepPrevScale.setChecked(enabled)\r\n\r\n    def onNewBrightnessContrast(self, qimage):\r\n        self.canvas.loadPixmap(QtGui.QPixmap.fromImage(qimage), clear_shapes=False)\r\n\r\n    def brightnessContrast(self, value):\r\n        dialog = BrightnessContrastDialog(\r\n            utils.img_data_to_pil(self.imageData),\r\n            self.onNewBrightnessContrast,\r\n            parent=self,\r\n        )\r\n        brightness, contrast = self.brightnessContrast_values.get(\r\n            self.filename, (None, None)\r\n        )\r\n        if brightness is not None:\r\n            dialog.slider_brightness.setValue(brightness)\r\n        if contrast is not None:\r\n            dialog.slider_contrast.setValue(contrast)\r\n        dialog.exec_()\r\n\r\n        brightness = dialog.slider_brightness.value()\r\n        contrast = dialog.slider_contrast.value()\r\n        self.brightnessContrast_values[self.filename] = (brightness, contrast)\r\n\r\n    def togglePolygons(self, value):\r\n        flag = value\r\n        for item in self.labelList:\r\n            if value is None:\r\n                flag = item.checkState() == Qt.Unchecked\r\n            item.setCheckState(Qt.Checked if flag else Qt.Unchecked)\r\n\r\n    def loadFile(self, filename=None):\r\n        \"\"\"Load the specified file, or the last opened file if None.\"\"\"\r\n        # changing fileListWidget loads file\r\n        if filename in self.imageList and (\r\n"}
{"image_path": "data\\train\\00314.png", "code": "            self.fileListWidget.currentRow() != self.imageList.index(filename)\r\n        ):\r\n            self.fileListWidget.setCurrentRow(self.imageList.index(filename))\r\n            self.fileListWidget.repaint()\r\n            return\r\n\r\n        self.resetState()\r\n        self.canvas.setEnabled(False)\r\n        if filename is None:\r\n            filename = self.settings.value(\"filename\", \"\")\r\n        filename = str(filename)\r\n        if not QtCore.QFile.exists(filename):\r\n            self.errorMessage(\r\n                self.tr(\"Error opening file\"),\r\n                self.tr(\"No such file: <b>%s</b>\") % filename,\r\n            )\r\n            return False\r\n        # assumes same name, but json extension\r\n        self.status(str(self.tr(\"Loading %s...\")) % osp.basename(str(filename)))\r\n        label_file = osp.splitext(filename)[0] + \".json\"\r\n        if self.output_dir:\r\n            label_file_without_path = osp.basename(label_file)\r\n            label_file = osp.join(self.output_dir, label_file_without_path)\r\n        if QtCore.QFile.exists(label_file) and LabelFile.is_label_file(label_file):\r\n            try:\r\n                self.labelFile = LabelFile(label_file)\r\n            except LabelFileError as e:\r\n                self.errorMessage(\r\n                    self.tr(\"Error opening file\"),\r\n                    self.tr(\r\n                        \"<p><b>%s</b></p>\"\r\n                        \"<p>Make sure <i>%s</i> is a valid label file.\"\r\n                    )\r\n                    % (e, label_file),\r\n                )\r\n                self.status(self.tr(\"Error reading %s\") % label_file)\r\n                return False\r\n            self.imageData = self.labelFile.imageData\r\n            self.imagePath = osp.join(\r\n                osp.dirname(label_file),\r\n"}
{"image_path": "data\\train\\00315.png", "code": "                self.labelFile.imagePath,\r\n            )\r\n            self.otherData = self.labelFile.otherData\r\n        else:\r\n            self.imageData = LabelFile.load_image_file(filename)\r\n            if self.imageData:\r\n                self.imagePath = filename\r\n            self.labelFile = None\r\n        image = QtGui.QImage.fromData(self.imageData)\r\n\r\n        if image.isNull():\r\n            formats = [\r\n                \"*.{}\".format(fmt.data().decode())\r\n                for fmt in QtGui.QImageReader.supportedImageFormats()\r\n            ]\r\n            self.errorMessage(\r\n                self.tr(\"Error opening file\"),\r\n                self.tr(\r\n                    \"<p>Make sure <i>{0}</i> is a valid image file.<br/>\"\r\n                    \"Supported image formats: {1}</p>\"\r\n                ).format(filename, \",\".join(formats)),\r\n            )\r\n            self.status(self.tr(\"Error reading %s\") % filename)\r\n            return False\r\n        self.image = image\r\n        self.filename = filename\r\n        if self._config[\"keep_prev\"]:\r\n            prev_shapes = self.canvas.shapes\r\n        self.canvas.loadPixmap(QtGui.QPixmap.fromImage(image))\r\n        flags = {k: False for k in self._config[\"flags\"] or []}\r\n        if self.labelFile:\r\n            self.loadLabels(self.labelFile.shapes)\r\n            if self.labelFile.flags is not None:\r\n                flags.update(self.labelFile.flags)\r\n        self.loadFlags(flags)\r\n        if self._config[\"keep_prev\"] and self.noShapes():\r\n            self.loadShapes(prev_shapes, replace=False)\r\n            self.setDirty()\r\n        else:\r\n            self.setClean()\r\n"}
{"image_path": "data\\train\\00316.png", "code": "        self.canvas.setEnabled(True)\r\n        # set zoom values\r\n        is_initial_load = not self.zoom_values\r\n        if self.filename in self.zoom_values:\r\n            self.zoomMode = self.zoom_values[self.filename][0]\r\n            self.setZoom(self.zoom_values[self.filename][1])\r\n        elif is_initial_load or not self._config[\"keep_prev_scale\"]:\r\n            self.adjustScale(initial=True)\r\n        # set scroll values\r\n        for orientation in self.scroll_values:\r\n            if self.filename in self.scroll_values[orientation]:\r\n                self.setScroll(\r\n                    orientation, self.scroll_values[orientation][self.filename]\r\n                )\r\n        # set brightness contrast values\r\n        dialog = BrightnessContrastDialog(\r\n            utils.img_data_to_pil(self.imageData),\r\n            self.onNewBrightnessContrast,\r\n            parent=self,\r\n        )\r\n        brightness, contrast = self.brightnessContrast_values.get(\r\n            self.filename, (None, None)\r\n        )\r\n        if self._config[\"keep_prev_brightness\"] and self.recentFiles:\r\n            brightness, _ = self.brightnessContrast_values.get(\r\n                self.recentFiles[0], (None, None)\r\n            )\r\n        if self._config[\"keep_prev_contrast\"] and self.recentFiles:\r\n            _, contrast = self.brightnessContrast_values.get(\r\n                self.recentFiles[0], (None, None)\r\n            )\r\n        if brightness is not None:\r\n            dialog.slider_brightness.setValue(brightness)\r\n        if contrast is not None:\r\n            dialog.slider_contrast.setValue(contrast)\r\n        self.brightnessContrast_values[self.filename] = (brightness, contrast)\r\n        if brightness is not None or contrast is not None:\r\n            dialog.onNewValue(None)\r\n        self.paintCanvas()\r\n        self.addRecentFile(self.filename)\r\n"}
{"image_path": "data\\train\\00317.png", "code": "        self.toggleActions(True)\r\n        self.canvas.setFocus()\r\n        self.status(str(self.tr(\"Loaded %s\")) % osp.basename(str(filename)))\r\n        return True\r\n\r\n    def resizeEvent(self, event):\r\n        if (\r\n            self.canvas\r\n            and not self.image.isNull()\r\n            and self.zoomMode != self.MANUAL_ZOOM\r\n        ):\r\n            self.adjustScale()\r\n        super(MainWindow, self).resizeEvent(event)\r\n\r\n    def paintCanvas(self):\r\n        assert not self.image.isNull(), \"cannot paint null image\"\r\n        self.canvas.scale = 0.01 * self.zoomWidget.value()\r\n        self.canvas.adjustSize()\r\n        self.canvas.update()\r\n\r\n    def adjustScale(self, initial=False):\r\n        value = self.scalers[self.FIT_WINDOW if initial else self.zoomMode]()\r\n        value = int(100 * value)\r\n        self.zoomWidget.setValue(value)\r\n        self.zoom_values[self.filename] = (self.zoomMode, value)\r\n\r\n    def scaleFitWindow(self):\r\n        \"\"\"Figure out the size of the pixmap to fit the main widget.\"\"\"\r\n        e = 2.0  # So that no scrollbars are generated.\r\n        w1 = self.centralWidget().width() - e\r\n        h1 = self.centralWidget().height() - e\r\n        a1 = w1 / h1\r\n        # Calculate a new scale value based on the pixmap's aspect ratio.\r\n        w2 = self.canvas.pixmap.width() - 0.0\r\n        h2 = self.canvas.pixmap.height() - 0.0\r\n        a2 = w2 / h2\r\n        return w1 / w2 if a2 >= a1 else h1 / h2\r\n\r\n    def scaleFitWidth(self):\r\n        # The epsilon does not seem to work too well here.\r\n"}
{"image_path": "data\\train\\00318.png", "code": "        w = self.centralWidget().width() - 2.0\r\n        return w / self.canvas.pixmap.width()\r\n\r\n    def enableSaveImageWithData(self, enabled):\r\n        self._config[\"store_data\"] = enabled\r\n        self.actions.saveWithImageData.setChecked(enabled)\r\n\r\n    def closeEvent(self, event):\r\n        if not self.mayContinue():\r\n            event.ignore()\r\n        self.settings.setValue(\"filename\", self.filename if self.filename else \"\")\r\n        self.settings.setValue(\"window/size\", self.size())\r\n        self.settings.setValue(\"window/position\", self.pos())\r\n        self.settings.setValue(\"window/state\", self.saveState())\r\n        self.settings.setValue(\"recentFiles\", self.recentFiles)\r\n        # ask the use for where to save the labels\r\n        # self.settings.setValue('window/geometry', self.saveGeometry())\r\n\r\n    def dragEnterEvent(self, event):\r\n        extensions = [\r\n            \".%s\" % fmt.data().decode().lower()\r\n            for fmt in QtGui.QImageReader.supportedImageFormats()\r\n        ]\r\n        if event.mimeData().hasUrls():\r\n            items = [i.toLocalFile() for i in event.mimeData().urls()]\r\n            if any([i.lower().endswith(tuple(extensions)) for i in items]):\r\n                event.accept()\r\n        else:\r\n            event.ignore()\r\n\r\n    def dropEvent(self, event):\r\n        if not self.mayContinue():\r\n            event.ignore()\r\n            return\r\n        items = [i.toLocalFile() for i in event.mimeData().urls()]\r\n        self.importDroppedImageFiles(items)\r\n\r\n    # User Dialogs #\r\n\r\n    def loadRecent(self, filename):\r\n"}
{"image_path": "data\\train\\00319.png", "code": "        if self.mayContinue():\r\n            self.loadFile(filename)\r\n\r\n    def openPrevImg(self, _value=False):\r\n        keep_prev = self._config[\"keep_prev\"]\r\n        if QtWidgets.QApplication.keyboardModifiers() == (\r\n            Qt.ControlModifier | Qt.ShiftModifier\r\n        ):\r\n            self._config[\"keep_prev\"] = True\r\n\r\n        if not self.mayContinue():\r\n            return\r\n\r\n        if len(self.imageList) <= 0:\r\n            return\r\n\r\n        if self.filename is None:\r\n            return\r\n\r\n        currIndex = self.imageList.index(self.filename)\r\n        if currIndex - 1 >= 0:\r\n            filename = self.imageList[currIndex - 1]\r\n            if filename:\r\n                self.loadFile(filename)\r\n\r\n        self._config[\"keep_prev\"] = keep_prev\r\n\r\n    def openNextImg(self, _value=False, load=True):\r\n        keep_prev = self._config[\"keep_prev\"]\r\n        if QtWidgets.QApplication.keyboardModifiers() == (\r\n            Qt.ControlModifier | Qt.ShiftModifier\r\n        ):\r\n            self._config[\"keep_prev\"] = True\r\n\r\n        if not self.mayContinue():\r\n            return\r\n\r\n        if len(self.imageList) <= 0:\r\n            return\r\n\r\n"}
{"image_path": "data\\train\\00320.png", "code": "        filename = None\r\n        if self.filename is None:\r\n            filename = self.imageList[0]\r\n        else:\r\n            currIndex = self.imageList.index(self.filename)\r\n            if currIndex + 1 < len(self.imageList):\r\n                filename = self.imageList[currIndex + 1]\r\n            else:\r\n                filename = self.imageList[-1]\r\n        self.filename = filename\r\n\r\n        if self.filename and load:\r\n            self.loadFile(self.filename)\r\n\r\n        self._config[\"keep_prev\"] = keep_prev\r\n\r\n    def openFile(self, _value=False):\r\n        if not self.mayContinue():\r\n            return\r\n        path = osp.dirname(str(self.filename)) if self.filename else \".\"\r\n        formats = [\r\n            \"*.{}\".format(fmt.data().decode())\r\n            for fmt in QtGui.QImageReader.supportedImageFormats()\r\n        ]\r\n        filters = self.tr(\"Image & Label files (%s)\") % \" \".join(\r\n            formats + [\"*%s\" % LabelFile.suffix]\r\n        )\r\n        fileDialog = FileDialogPreview(self)\r\n        fileDialog.setFileMode(FileDialogPreview.ExistingFile)\r\n        fileDialog.setNameFilter(filters)\r\n        fileDialog.setWindowTitle(\r\n            self.tr(\"%s - Choose Image or Label file\") % __appname__,\r\n        )\r\n        fileDialog.setWindowFilePath(path)\r\n        fileDialog.setViewMode(FileDialogPreview.Detail)\r\n        if fileDialog.exec_():\r\n            fileName = fileDialog.selectedFiles()[0]\r\n            if fileName:\r\n                self.loadFile(fileName)\r\n\r\n"}
{"image_path": "data\\train\\00321.png", "code": "    def changeOutputDirDialog(self, _value=False):\r\n        default_output_dir = self.output_dir\r\n        if default_output_dir is None and self.filename:\r\n            default_output_dir = osp.dirname(self.filename)\r\n        if default_output_dir is None:\r\n            default_output_dir = self.currentPath()\r\n\r\n        output_dir = QtWidgets.QFileDialog.getExistingDirectory(\r\n            self,\r\n            self.tr(\"%s - Save/Load Annotations in Directory\") % __appname__,\r\n            default_output_dir,\r\n            QtWidgets.QFileDialog.ShowDirsOnly\r\n            | QtWidgets.QFileDialog.DontResolveSymlinks,\r\n        )\r\n        output_dir = str(output_dir)\r\n\r\n        if not output_dir:\r\n            return\r\n\r\n        self.output_dir = output_dir\r\n\r\n        self.statusBar().showMessage(\r\n            self.tr(\"%s . Annotations will be saved/loaded in %s\")\r\n            % (\"Change Annotations Dir\", self.output_dir)\r\n        )\r\n        self.statusBar().show()\r\n\r\n        current_filename = self.filename\r\n        self.importDirImages(self.lastOpenDir, load=False)\r\n\r\n        if current_filename in self.imageList:\r\n            # retain currently selected file\r\n            self.fileListWidget.setCurrentRow(self.imageList.index(current_filename))\r\n            self.fileListWidget.repaint()\r\n\r\n    def saveFile(self, _value=False):\r\n        assert not self.image.isNull(), \"cannot save empty image\"\r\n        if self.labelFile:\r\n            # DL20180323 - overwrite when in directory\r\n            self._saveFile(self.labelFile.filename)\r\n"}
{"image_path": "data\\train\\00322.png", "code": "        elif self.output_file:\r\n            self._saveFile(self.output_file)\r\n            self.close()\r\n        else:\r\n            self._saveFile(self.saveFileDialog())\r\n\r\n    def saveFileAs(self, _value=False):\r\n        assert not self.image.isNull(), \"cannot save empty image\"\r\n        self._saveFile(self.saveFileDialog())\r\n\r\n    def saveFileDialog(self):\r\n        caption = self.tr(\"%s - Choose File\") % __appname__\r\n        filters = self.tr(\"Label files (*%s)\") % LabelFile.suffix\r\n        if self.output_dir:\r\n            dlg = QtWidgets.QFileDialog(self, caption, self.output_dir, filters)\r\n        else:\r\n            dlg = QtWidgets.QFileDialog(self, caption, self.currentPath(), filters)\r\n        dlg.setDefaultSuffix(LabelFile.suffix[1:])\r\n        dlg.setAcceptMode(QtWidgets.QFileDialog.AcceptSave)\r\n        dlg.setOption(QtWidgets.QFileDialog.DontConfirmOverwrite, False)\r\n        dlg.setOption(QtWidgets.QFileDialog.DontUseNativeDialog, False)\r\n        basename = osp.basename(osp.splitext(self.filename)[0])\r\n        if self.output_dir:\r\n            default_labelfile_name = osp.join(\r\n                self.output_dir, basename + LabelFile.suffix\r\n            )\r\n        else:\r\n            default_labelfile_name = osp.join(\r\n                self.currentPath(), basename + LabelFile.suffix\r\n            )\r\n        filename = dlg.getSaveFileName(\r\n            self,\r\n            self.tr(\"Choose File\"),\r\n            default_labelfile_name,\r\n            self.tr(\"Label files (*%s)\") % LabelFile.suffix,\r\n        )\r\n        if isinstance(filename, tuple):\r\n            filename, _ = filename\r\n        return filename\r\n\r\n"}
{"image_path": "data\\train\\00323.png", "code": "    def _saveFile(self, filename):\r\n        if filename and self.saveLabels(filename):\r\n            self.addRecentFile(filename)\r\n            self.setClean()\r\n\r\n    def closeFile(self, _value=False):\r\n        if not self.mayContinue():\r\n            return\r\n        self.resetState()\r\n        self.setClean()\r\n        self.toggleActions(False)\r\n        self.canvas.setEnabled(False)\r\n        self.actions.saveAs.setEnabled(False)\r\n\r\n    def getLabelFile(self):\r\n        if self.filename.lower().endswith(\".json\"):\r\n            label_file = self.filename\r\n        else:\r\n            label_file = osp.splitext(self.filename)[0] + \".json\"\r\n\r\n        return label_file\r\n\r\n    def deleteFile(self):\r\n        mb = QtWidgets.QMessageBox\r\n        msg = self.tr(\r\n            \"You are about to permanently delete this label file, \" \"proceed anyway?\"\r\n        )\r\n        answer = mb.warning(self, self.tr(\"Attention\"), msg, mb.Yes | mb.No)\r\n        if answer != mb.Yes:\r\n            return\r\n\r\n        label_file = self.getLabelFile()\r\n        if osp.exists(label_file):\r\n            os.remove(label_file)\r\n            logger.info(\"Label file is removed: {}\".format(label_file))\r\n\r\n            item = self.fileListWidget.currentItem()\r\n            item.setCheckState(Qt.Unchecked)\r\n\r\n            self.resetState()\r\n"}
{"image_path": "data\\train\\00324.png", "code": "\r\n    # Message Dialogs. #\r\n    def hasLabels(self):\r\n        if self.noShapes():\r\n            self.errorMessage(\r\n                \"No objects labeled\",\r\n                \"You must label at least one object to save the file.\",\r\n            )\r\n            return False\r\n        return True\r\n\r\n    def hasLabelFile(self):\r\n        if self.filename is None:\r\n            return False\r\n\r\n        label_file = self.getLabelFile()\r\n        return osp.exists(label_file)\r\n\r\n    def mayContinue(self):\r\n        if not self.dirty:\r\n            return True\r\n        mb = QtWidgets.QMessageBox\r\n        msg = self.tr('Save annotations to \"{}\" before closing?').format(self.filename)\r\n        answer = mb.question(\r\n            self,\r\n            self.tr(\"Save annotations?\"),\r\n            msg,\r\n            mb.Save | mb.Discard | mb.Cancel,\r\n            mb.Save,\r\n        )\r\n        if answer == mb.Discard:\r\n            return True\r\n        elif answer == mb.Save:\r\n            self.saveFile()\r\n            return True\r\n        else:  # answer == mb.Cancel\r\n            return False\r\n\r\n    def errorMessage(self, title, message):\r\n        return QtWidgets.QMessageBox.critical(\r\n"}
{"image_path": "data\\train\\00325.png", "code": "            self, title, \"<p><b>%s</b></p>%s\" % (title, message)\r\n        )\r\n\r\n    def currentPath(self):\r\n        return osp.dirname(str(self.filename)) if self.filename else \".\"\r\n\r\n    def toggleKeepPrevMode(self):\r\n        self._config[\"keep_prev\"] = not self._config[\"keep_prev\"]\r\n\r\n    def removeSelectedPoint(self):\r\n        self.canvas.removeSelectedPoint()\r\n        self.canvas.update()\r\n        if not self.canvas.hShape.points:\r\n            self.canvas.deleteShape(self.canvas.hShape)\r\n            self.remLabels([self.canvas.hShape])\r\n            if self.noShapes():\r\n                for action in self.actions.onShapesPresent:\r\n                    action.setEnabled(False)\r\n        self.setDirty()\r\n\r\n    def deleteSelectedShape(self):\r\n        yes, no = QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No\r\n        msg = self.tr(\r\n            \"You are about to permanently delete {} polygons, \" \"proceed anyway?\"\r\n        ).format(len(self.canvas.selectedShapes))\r\n        if yes == QtWidgets.QMessageBox.warning(\r\n            self, self.tr(\"Attention\"), msg, yes | no, yes\r\n        ):\r\n            self.remLabels(self.canvas.deleteSelected())\r\n            self.setDirty()\r\n            if self.noShapes():\r\n                for action in self.actions.onShapesPresent:\r\n                    action.setEnabled(False)\r\n\r\n    def copyShape(self):\r\n        self.canvas.endMove(copy=True)\r\n        for shape in self.canvas.selectedShapes:\r\n            self.addLabel(shape)\r\n        self.labelList.clearSelection()\r\n        self.setDirty()\r\n"}
{"image_path": "data\\train\\00326.png", "code": "\r\n    def moveShape(self):\r\n        self.canvas.endMove(copy=False)\r\n        self.setDirty()\r\n\r\n    def openDirDialog(self, _value=False, dirpath=None):\r\n        if not self.mayContinue():\r\n            return\r\n\r\n        defaultOpenDirPath = dirpath if dirpath else \".\"\r\n        if self.lastOpenDir and osp.exists(self.lastOpenDir):\r\n            defaultOpenDirPath = self.lastOpenDir\r\n        else:\r\n            defaultOpenDirPath = osp.dirname(self.filename) if self.filename else \".\"\r\n\r\n        targetDirPath = str(\r\n            QtWidgets.QFileDialog.getExistingDirectory(\r\n                self,\r\n                self.tr(\"%s - Open Directory\") % __appname__,\r\n                defaultOpenDirPath,\r\n                QtWidgets.QFileDialog.ShowDirsOnly\r\n                | QtWidgets.QFileDialog.DontResolveSymlinks,\r\n            )\r\n        )\r\n        self.importDirImages(targetDirPath)\r\n\r\n    @property\r\n    def imageList(self):\r\n        lst = []\r\n        for i in range(self.fileListWidget.count()):\r\n            item = self.fileListWidget.item(i)\r\n            lst.append(item.text())\r\n        return lst\r\n\r\n    def importDroppedImageFiles(self, imageFiles):\r\n        extensions = [\r\n            \".%s\" % fmt.data().decode().lower()\r\n            for fmt in QtGui.QImageReader.supportedImageFormats()\r\n        ]\r\n\r\n"}
{"image_path": "data\\train\\00327.png", "code": "        self.filename = None\r\n        for file in imageFiles:\r\n            if file in self.imageList or not file.lower().endswith(tuple(extensions)):\r\n                continue\r\n            label_file = osp.splitext(file)[0] + \".json\"\r\n            if self.output_dir:\r\n                label_file_without_path = osp.basename(label_file)\r\n                label_file = osp.join(self.output_dir, label_file_without_path)\r\n            item = QtWidgets.QListWidgetItem(file)\r\n            item.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable)\r\n            if QtCore.QFile.exists(label_file) and LabelFile.is_label_file(label_file):\r\n                item.setCheckState(Qt.Checked)\r\n            else:\r\n                item.setCheckState(Qt.Unchecked)\r\n            self.fileListWidget.addItem(item)\r\n\r\n        if len(self.imageList) > 1:\r\n            self.actions.openNextImg.setEnabled(True)\r\n            self.actions.openPrevImg.setEnabled(True)\r\n\r\n        self.openNextImg()\r\n\r\n    def importDirImages(self, dirpath, pattern=None, load=True):\r\n        self.actions.openNextImg.setEnabled(True)\r\n        self.actions.openPrevImg.setEnabled(True)\r\n\r\n        if not self.mayContinue() or not dirpath:\r\n            return\r\n\r\n        self.lastOpenDir = dirpath\r\n        self.filename = None\r\n        self.fileListWidget.clear()\r\n\r\n        filenames = self.scanAllImages(dirpath)\r\n        if pattern:\r\n            try:\r\n                filenames = [f for f in filenames if re.search(pattern, f)]\r\n            except re.error:\r\n                pass\r\n        for filename in filenames:\r\n"}
{"image_path": "data\\train\\00328.png", "code": "            label_file = osp.splitext(filename)[0] + \".json\"\r\n            if self.output_dir:\r\n                label_file_without_path = osp.basename(label_file)\r\n                label_file = osp.join(self.output_dir, label_file_without_path)\r\n            item = QtWidgets.QListWidgetItem(filename)\r\n            item.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable)\r\n            if QtCore.QFile.exists(label_file) and LabelFile.is_label_file(label_file):\r\n                item.setCheckState(Qt.Checked)\r\n            else:\r\n                item.setCheckState(Qt.Unchecked)\r\n            self.fileListWidget.addItem(item)\r\n        self.openNextImg(load=load)\r\n\r\n    def scanAllImages(self, folderPath):\r\n        extensions = [\r\n            \".%s\" % fmt.data().decode().lower()\r\n            for fmt in QtGui.QImageReader.supportedImageFormats()\r\n        ]\r\n\r\n        images = []\r\n        for root, dirs, files in os.walk(folderPath):\r\n            for file in files:\r\n                if file.lower().endswith(tuple(extensions)):\r\n                    relativePath = os.path.normpath(osp.join(root, file))\r\n                    images.append(relativePath)\r\n        images = natsort.os_sorted(images)\r\n        return images\r\n"}
{"image_path": "data\\train\\00329.png", "code": "import collections\r\nimport threading\r\n\r\nimport imgviz\r\nimport numpy as np\r\nimport onnxruntime\r\nimport skimage\r\n\r\nfrom ..logger import logger\r\nfrom . import _utils\r\n\r\n\r\nclass EfficientSam:\r\n    def __init__(self, encoder_path, decoder_path):\r\n        self._encoder_session = onnxruntime.InferenceSession(encoder_path)\r\n        self._decoder_session = onnxruntime.InferenceSession(decoder_path)\r\n\r\n        self._lock = threading.Lock()\r\n        self._image_embedding_cache = collections.OrderedDict()\r\n\r\n        self._thread = None\r\n\r\n    def set_image(self, image: np.ndarray):\r\n        with self._lock:\r\n            self._image = image\r\n            self._image_embedding = self._image_embedding_cache.get(\r\n                self._image.tobytes()\r\n            )\r\n\r\n        if self._image_embedding is None:\r\n            self._thread = threading.Thread(\r\n                target=self._compute_and_cache_image_embedding\r\n            )\r\n            self._thread.start()\r\n\r\n    def _compute_and_cache_image_embedding(self):\r\n        with self._lock:\r\n            logger.debug(\"Computing image embedding...\")\r\n            image = imgviz.rgba2rgb(self._image)\r\n            batched_images = image.transpose(2, 0, 1)[None].astype(np.float32) / 255.0\r\n"}
{"image_path": "data\\train\\00330.png", "code": "            (self._image_embedding,) = self._encoder_session.run(\r\n                output_names=None,\r\n                input_feed={\"batched_images\": batched_images},\r\n            )\r\n            if len(self._image_embedding_cache) > 10:\r\n                self._image_embedding_cache.popitem(last=False)\r\n            self._image_embedding_cache[self._image.tobytes()] = self._image_embedding\r\n            logger.debug(\"Done computing image embedding.\")\r\n\r\n    def _get_image_embedding(self):\r\n        if self._thread is not None:\r\n            self._thread.join()\r\n            self._thread = None\r\n        with self._lock:\r\n            return self._image_embedding\r\n\r\n    def predict_mask_from_points(self, points, point_labels):\r\n        return _compute_mask_from_points(\r\n            decoder_session=self._decoder_session,\r\n            image=self._image,\r\n            image_embedding=self._get_image_embedding(),\r\n            points=points,\r\n            point_labels=point_labels,\r\n        )\r\n\r\n    def predict_polygon_from_points(self, points, point_labels):\r\n        mask = self.predict_mask_from_points(points=points, point_labels=point_labels)\r\n        return _utils.compute_polygon_from_mask(mask=mask)\r\n\r\n\r\ndef _compute_mask_from_points(\r\n    decoder_session, image, image_embedding, points, point_labels\r\n):\r\n    input_point = np.array(points, dtype=np.float32)\r\n    input_label = np.array(point_labels, dtype=np.float32)\r\n\r\n    # batch_size, num_queries, num_points, 2\r\n    batched_point_coords = input_point[None, None, :, :]\r\n    # batch_size, num_queries, num_points\r\n    batched_point_labels = input_label[None, None, :]\r\n"}
{"image_path": "data\\train\\00331.png", "code": "\r\n    decoder_inputs = {\r\n        \"image_embeddings\": image_embedding,\r\n        \"batched_point_coords\": batched_point_coords,\r\n        \"batched_point_labels\": batched_point_labels,\r\n        \"orig_im_size\": np.array(image.shape[:2], dtype=np.int64),\r\n    }\r\n\r\n    masks, _, _ = decoder_session.run(None, decoder_inputs)\r\n    mask = masks[0, 0, 0, :, :]  # (1, 1, 3, H, W) -> (H, W)\r\n    mask = mask > 0.0\r\n\r\n    MIN_SIZE_RATIO = 0.05\r\n    skimage.morphology.remove_small_objects(\r\n        mask, min_size=mask.sum() * MIN_SIZE_RATIO, out=mask\r\n    )\r\n\r\n    if 0:\r\n        imgviz.io.imsave(\"mask.jpg\", imgviz.label2rgb(mask, imgviz.rgb2gray(image)))\r\n    return mask\r\n"}
{"image_path": "data\\train\\00332.png", "code": "import gdown\r\n\r\nfrom .efficient_sam import EfficientSam\r\nfrom .segment_anything_model import SegmentAnythingModel\r\n\r\n\r\nclass SegmentAnythingModelVitB(SegmentAnythingModel):\r\n    name = \"SegmentAnything (speed)\"\r\n\r\n    def __init__(self):\r\n        super().__init__(\r\n            encoder_path=gdown.cached_download(\r\n                url=\"https://github.com/wkentaro/labelme/releases/download/sam-20230416/sam_vit_b_01ec64.quantized.encoder.onnx\",  # NOQA\r\n                md5=\"80fd8d0ab6c6ae8cb7b3bd5f368a752c\",\r\n            ),\r\n            decoder_path=gdown.cached_download(\r\n                url=\"https://github.com/wkentaro/labelme/releases/download/sam-20230416/sam_vit_b_01ec64.quantized.decoder.onnx\",  # NOQA\r\n                md5=\"4253558be238c15fc265a7a876aaec82\",\r\n            ),\r\n        )\r\n\r\n\r\nclass SegmentAnythingModelVitL(SegmentAnythingModel):\r\n    name = \"SegmentAnything (balanced)\"\r\n\r\n    def __init__(self):\r\n        super().__init__(\r\n            encoder_path=gdown.cached_download(\r\n                url=\"https://github.com/wkentaro/labelme/releases/download/sam-20230416/sam_vit_l_0b3195.quantized.encoder.onnx\",  # NOQA\r\n                md5=\"080004dc9992724d360a49399d1ee24b\",\r\n            ),\r\n            decoder_path=gdown.cached_download(\r\n                url=\"https://github.com/wkentaro/labelme/releases/download/sam-20230416/sam_vit_l_0b3195.quantized.decoder.onnx\",  # NOQA\r\n                md5=\"851b7faac91e8e23940ee1294231d5c7\",\r\n            ),\r\n        )\r\n\r\n\r\nclass SegmentAnythingModelVitH(SegmentAnythingModel):\r\n    name = \"SegmentAnything (accuracy)\"\r\n"}
{"image_path": "data\\train\\00333.png", "code": "\r\n    def __init__(self):\r\n        super().__init__(\r\n            encoder_path=gdown.cached_download(\r\n                url=\"https://github.com/wkentaro/labelme/releases/download/sam-20230416/sam_vit_h_4b8939.quantized.encoder.onnx\",  # NOQA\r\n                md5=\"958b5710d25b198d765fb6b94798f49e\",\r\n            ),\r\n            decoder_path=gdown.cached_download(\r\n                url=\"https://github.com/wkentaro/labelme/releases/download/sam-20230416/sam_vit_h_4b8939.quantized.decoder.onnx\",  # NOQA\r\n                md5=\"a997a408347aa081b17a3ffff9f42a80\",\r\n            ),\r\n        )\r\n\r\n\r\nclass EfficientSamVitT(EfficientSam):\r\n    name = \"EfficientSam (speed)\"\r\n\r\n    def __init__(self):\r\n        super().__init__(\r\n            encoder_path=gdown.cached_download(\r\n                url=\"https://github.com/labelmeai/efficient-sam/releases/download/onnx-models-20231225/efficient_sam_vitt_encoder.onnx\",  # NOQA\r\n                md5=\"2d4a1303ff0e19fe4a8b8ede69c2f5c7\",\r\n            ),\r\n            decoder_path=gdown.cached_download(\r\n                url=\"https://github.com/labelmeai/efficient-sam/releases/download/onnx-models-20231225/efficient_sam_vitt_decoder.onnx\",  # NOQA\r\n                md5=\"be3575ca4ed9b35821ac30991ab01843\",\r\n            ),\r\n        )\r\n\r\n\r\nclass EfficientSamVitS(EfficientSam):\r\n    name = \"EfficientSam (accuracy)\"\r\n\r\n    def __init__(self):\r\n        super().__init__(\r\n            encoder_path=gdown.cached_download(\r\n                url=\"https://github.com/labelmeai/efficient-sam/releases/download/onnx-models-20231225/efficient_sam_vits_encoder.onnx\",  # NOQA\r\n                md5=\"7d97d23e8e0847d4475ca7c9f80da96d\",\r\n            ),\r\n            decoder_path=gdown.cached_download(\r\n"}
{"image_path": "data\\train\\00334.png", "code": "                url=\"https://github.com/labelmeai/efficient-sam/releases/download/onnx-models-20231225/efficient_sam_vits_decoder.onnx\",  # NOQA\r\n                md5=\"d9372f4a7bbb1a01d236b0508300b994\",\r\n            ),\r\n        )\r\n\r\n\r\nMODELS = [\r\n    SegmentAnythingModelVitB,\r\n    SegmentAnythingModelVitL,\r\n    SegmentAnythingModelVitH,\r\n    EfficientSamVitT,\r\n    EfficientSamVitS,\r\n]\r\n"}
{"image_path": "data\\train\\00335.png", "code": "import imgviz\r\nimport numpy as np\r\nimport skimage\r\n\r\nfrom labelme.logger import logger\r\n\r\n\r\ndef _get_contour_length(contour):\r\n    contour_start = contour\r\n    contour_end = np.r_[contour[1:], contour[0:1]]\r\n    return np.linalg.norm(contour_end - contour_start, axis=1).sum()\r\n\r\n\r\ndef compute_polygon_from_mask(mask):\r\n    contours = skimage.measure.find_contours(np.pad(mask, pad_width=1))\r\n    if len(contours) == 0:\r\n        logger.warning(\"No contour found, so returning empty polygon.\")\r\n        return np.empty((0, 2), dtype=np.float32)\r\n\r\n    contour = max(contours, key=_get_contour_length)\r\n    POLYGON_APPROX_TOLERANCE = 0.004\r\n    polygon = skimage.measure.approximate_polygon(\r\n        coords=contour,\r\n        tolerance=np.ptp(contour, axis=0).max() * POLYGON_APPROX_TOLERANCE,\r\n    )\r\n    polygon = np.clip(polygon, (0, 0), (mask.shape[0] - 1, mask.shape[1] - 1))\r\n    polygon = polygon[:-1]  # drop last point that is duplicate of first point\r\n\r\n    if 0:\r\n        import PIL.Image\r\n\r\n        image_pil = PIL.Image.fromarray(imgviz.gray2rgb(imgviz.bool2ubyte(mask)))\r\n        imgviz.draw.line_(image_pil, yx=polygon, fill=(0, 255, 0))\r\n        for point in polygon:\r\n            imgviz.draw.circle_(image_pil, center=point, diameter=10, fill=(0, 255, 0))\r\n        imgviz.io.imsave(\"contour.jpg\", np.asarray(image_pil))\r\n\r\n    return polygon[:, ::-1]  # yx -> xy\r\n"}
{"image_path": "data\\train\\00336.png", "code": "import collections\r\nimport threading\r\n\r\nimport imgviz\r\nimport numpy as np\r\nimport onnxruntime\r\nimport skimage\r\n\r\nfrom ..logger import logger\r\nfrom . import _utils\r\n\r\n\r\nclass SegmentAnythingModel:\r\n    def __init__(self, encoder_path, decoder_path):\r\n        self._image_size = 1024\r\n\r\n        self._encoder_session = onnxruntime.InferenceSession(encoder_path)\r\n        self._decoder_session = onnxruntime.InferenceSession(decoder_path)\r\n\r\n        self._lock = threading.Lock()\r\n        self._image_embedding_cache = collections.OrderedDict()\r\n\r\n        self._thread = None\r\n\r\n    def set_image(self, image: np.ndarray):\r\n        with self._lock:\r\n            self._image = image\r\n            self._image_embedding = self._image_embedding_cache.get(\r\n                self._image.tobytes()\r\n            )\r\n\r\n        if self._image_embedding is None:\r\n            self._thread = threading.Thread(\r\n                target=self._compute_and_cache_image_embedding\r\n            )\r\n            self._thread.start()\r\n\r\n    def _compute_and_cache_image_embedding(self):\r\n        with self._lock:\r\n            logger.debug(\"Computing image embedding...\")\r\n"}
{"image_path": "data\\train\\00337.png", "code": "            self._image_embedding = _compute_image_embedding(\r\n                image_size=self._image_size,\r\n                encoder_session=self._encoder_session,\r\n                image=self._image,\r\n            )\r\n            if len(self._image_embedding_cache) > 10:\r\n                self._image_embedding_cache.popitem(last=False)\r\n            self._image_embedding_cache[self._image.tobytes()] = self._image_embedding\r\n            logger.debug(\"Done computing image embedding.\")\r\n\r\n    def _get_image_embedding(self):\r\n        if self._thread is not None:\r\n            self._thread.join()\r\n            self._thread = None\r\n        with self._lock:\r\n            return self._image_embedding\r\n\r\n    def predict_mask_from_points(self, points, point_labels):\r\n        return _compute_mask_from_points(\r\n            image_size=self._image_size,\r\n            decoder_session=self._decoder_session,\r\n            image=self._image,\r\n            image_embedding=self._get_image_embedding(),\r\n            points=points,\r\n            point_labels=point_labels,\r\n        )\r\n\r\n    def predict_polygon_from_points(self, points, point_labels):\r\n        mask = self.predict_mask_from_points(points=points, point_labels=point_labels)\r\n        return _utils.compute_polygon_from_mask(mask=mask)\r\n\r\n\r\ndef _compute_scale_to_resize_image(image_size, image):\r\n    height, width = image.shape[:2]\r\n    if width > height:\r\n        scale = image_size / width\r\n        new_height = int(round(height * scale))\r\n        new_width = image_size\r\n    else:\r\n        scale = image_size / height\r\n"}
{"image_path": "data\\train\\00338.png", "code": "        new_height = image_size\r\n        new_width = int(round(width * scale))\r\n    return scale, new_height, new_width\r\n\r\n\r\ndef _resize_image(image_size, image):\r\n    scale, new_height, new_width = _compute_scale_to_resize_image(\r\n        image_size=image_size, image=image\r\n    )\r\n    scaled_image = imgviz.resize(\r\n        image,\r\n        height=new_height,\r\n        width=new_width,\r\n        backend=\"pillow\",\r\n    ).astype(np.float32)\r\n    return scale, scaled_image\r\n\r\n\r\ndef _compute_image_embedding(image_size, encoder_session, image):\r\n    image = imgviz.asrgb(image)\r\n\r\n    scale, x = _resize_image(image_size, image)\r\n    x = (x - np.array([123.675, 116.28, 103.53], dtype=np.float32)) / np.array(\r\n        [58.395, 57.12, 57.375], dtype=np.float32\r\n    )\r\n    x = np.pad(\r\n        x,\r\n        (\r\n            (0, image_size - x.shape[0]),\r\n            (0, image_size - x.shape[1]),\r\n            (0, 0),\r\n        ),\r\n    )\r\n    x = x.transpose(2, 0, 1)[None, :, :, :]\r\n\r\n    output = encoder_session.run(output_names=None, input_feed={\"x\": x})\r\n    image_embedding = output[0]\r\n\r\n    return image_embedding\r\n\r\n"}
{"image_path": "data\\train\\00339.png", "code": "\r\ndef _compute_mask_from_points(\r\n    image_size, decoder_session, image, image_embedding, points, point_labels\r\n):\r\n    input_point = np.array(points, dtype=np.float32)\r\n    input_label = np.array(point_labels, dtype=np.int32)\r\n\r\n    onnx_coord = np.concatenate([input_point, np.array([[0.0, 0.0]])], axis=0)[\r\n        None, :, :\r\n    ]\r\n    onnx_label = np.concatenate([input_label, np.array([-1])], axis=0)[None, :].astype(\r\n        np.float32\r\n    )\r\n\r\n    scale, new_height, new_width = _compute_scale_to_resize_image(\r\n        image_size=image_size, image=image\r\n    )\r\n    onnx_coord = (\r\n        onnx_coord.astype(float)\r\n        * (new_width / image.shape[1], new_height / image.shape[0])\r\n    ).astype(np.float32)\r\n\r\n    onnx_mask_input = np.zeros((1, 1, 256, 256), dtype=np.float32)\r\n    onnx_has_mask_input = np.array([-1], dtype=np.float32)\r\n\r\n    decoder_inputs = {\r\n        \"image_embeddings\": image_embedding,\r\n        \"point_coords\": onnx_coord,\r\n        \"point_labels\": onnx_label,\r\n        \"mask_input\": onnx_mask_input,\r\n        \"has_mask_input\": onnx_has_mask_input,\r\n        \"orig_im_size\": np.array(image.shape[:2], dtype=np.float32),\r\n    }\r\n\r\n    masks, _, _ = decoder_session.run(None, decoder_inputs)\r\n    mask = masks[0, 0]  # (1, 1, H, W) -> (H, W)\r\n    mask = mask > 0.0\r\n\r\n    MIN_SIZE_RATIO = 0.05\r\n    skimage.morphology.remove_small_objects(\r\n"}
{"image_path": "data\\train\\00340.png", "code": "        mask, min_size=mask.sum() * MIN_SIZE_RATIO, out=mask\r\n    )\r\n\r\n    if 0:\r\n        imgviz.io.imsave(\"mask.jpg\", imgviz.label2rgb(mask, imgviz.rgb2gray(image)))\r\n    return mask\r\n"}
{"image_path": "data\\train\\00341.png", "code": "import os.path as osp\r\nimport shutil\r\n\r\nimport yaml\r\n\r\nfrom labelme.logger import logger\r\n\r\nhere = osp.dirname(osp.abspath(__file__))\r\n\r\n\r\ndef update_dict(target_dict, new_dict, validate_item=None):\r\n    for key, value in new_dict.items():\r\n        if validate_item:\r\n            validate_item(key, value)\r\n        if key not in target_dict:\r\n            logger.warn(\"Skipping unexpected key in config: {}\".format(key))\r\n            continue\r\n        if isinstance(target_dict[key], dict) and isinstance(value, dict):\r\n            update_dict(target_dict[key], value, validate_item=validate_item)\r\n        else:\r\n            target_dict[key] = value\r\n\r\n\r\n# -----------------------------------------------------------------------------\r\n\r\n\r\ndef get_default_config():\r\n    config_file = osp.join(here, \"default_config.yaml\")\r\n    with open(config_file) as f:\r\n        config = yaml.safe_load(f)\r\n\r\n    # save default config to ~/.labelmerc\r\n    user_config_file = osp.join(osp.expanduser(\"~\"), \".labelmerc\")\r\n    if not osp.exists(user_config_file):\r\n        try:\r\n            shutil.copy(config_file, user_config_file)\r\n        except Exception:\r\n            logger.warn(\"Failed to save config: {}\".format(user_config_file))\r\n\r\n    return config\r\n"}
{"image_path": "data\\train\\00342.png", "code": "\r\n\r\ndef validate_config_item(key, value):\r\n    if key == \"validate_label\" and value not in [None, \"exact\"]:\r\n        raise ValueError(\r\n            \"Unexpected value for config key 'validate_label': {}\".format(value)\r\n        )\r\n    if key == \"shape_color\" and value not in [None, \"auto\", \"manual\"]:\r\n        raise ValueError(\r\n            \"Unexpected value for config key 'shape_color': {}\".format(value)\r\n        )\r\n    if key == \"labels\" and value is not None and len(value) != len(set(value)):\r\n        raise ValueError(\r\n            \"Duplicates are detected for config key 'labels': {}\".format(value)\r\n        )\r\n\r\n\r\ndef get_config(config_file_or_yaml=None, config_from_args=None):\r\n    # 1. default config\r\n    config = get_default_config()\r\n\r\n    # 2. specified as file or yaml\r\n    if config_file_or_yaml is not None:\r\n        config_from_yaml = yaml.safe_load(config_file_or_yaml)\r\n        if not isinstance(config_from_yaml, dict):\r\n            with open(config_from_yaml) as f:\r\n                logger.info(\"Loading config file from: {}\".format(config_from_yaml))\r\n                config_from_yaml = yaml.safe_load(f)\r\n        update_dict(config, config_from_yaml, validate_item=validate_config_item)\r\n\r\n    # 3. command line argument or specified config file\r\n    if config_from_args is not None:\r\n        update_dict(config, config_from_args, validate_item=validate_config_item)\r\n\r\n    return config\r\n"}
{"image_path": "data\\train\\00343.png", "code": "# -*- encoding: utf-8 -*-\r\n\r\nimport html\r\n\r\nfrom qtpy import QtWidgets\r\nfrom qtpy.QtCore import Qt\r\n\r\nfrom .escapable_qlist_widget import EscapableQListWidget\r\n\r\n\r\nclass UniqueLabelQListWidget(EscapableQListWidget):\r\n    def mousePressEvent(self, event):\r\n        super(UniqueLabelQListWidget, self).mousePressEvent(event)\r\n        if not self.indexAt(event.pos()).isValid():\r\n            self.clearSelection()\r\n\r\n    def findItemByLabel(self, label):\r\n        for row in range(self.count()):\r\n            item = self.item(row)\r\n            if item.data(Qt.UserRole) == label:\r\n                return item\r\n\r\n    def createItemFromLabel(self, label):\r\n        if self.findItemByLabel(label):\r\n            raise ValueError(\"Item for label '{}' already exists\".format(label))\r\n\r\n        item = QtWidgets.QListWidgetItem()\r\n        item.setData(Qt.UserRole, label)\r\n        return item\r\n\r\n    def setItemLabel(self, item, label, color=None):\r\n        qlabel = QtWidgets.QLabel()\r\n        if color is None:\r\n            qlabel.setText(\"{}\".format(label))\r\n        else:\r\n            qlabel.setText(\r\n                '{} <font color=\"#{:02x}{:02x}{:02x}\">\u25cf</font>'.format(\r\n                    html.escape(label), *color\r\n                )\r\n            )\r\n"}
{"image_path": "data\\train\\00344.png", "code": "        qlabel.setAlignment(Qt.AlignBottom)\r\n\r\n        item.setSizeHint(qlabel.sizeHint())\r\n\r\n        self.setItemWidget(item, qlabel)\r\n"}
{"image_path": "data\\train\\00345.png", "code": "from qtpy import QtCore\r\nfrom qtpy import QtWidgets\r\n\r\n\r\nclass ToolBar(QtWidgets.QToolBar):\r\n    def __init__(self, title):\r\n        super(ToolBar, self).__init__(title)\r\n        layout = self.layout()\r\n        m = (0, 0, 0, 0)\r\n        layout.setSpacing(0)\r\n        layout.setContentsMargins(*m)\r\n        self.setContentsMargins(*m)\r\n        self.setWindowFlags(self.windowFlags() | QtCore.Qt.FramelessWindowHint)\r\n\r\n    def addAction(self, action):\r\n        if isinstance(action, QtWidgets.QWidgetAction):\r\n            return super(ToolBar, self).addAction(action)\r\n        btn = QtWidgets.QToolButton()\r\n        btn.setDefaultAction(action)\r\n        btn.setToolButtonStyle(self.toolButtonStyle())\r\n        self.addWidget(btn)\r\n\r\n        # center align\r\n        for i in range(self.layout().count()):\r\n            if isinstance(self.layout().itemAt(i).widget(), QtWidgets.QToolButton):\r\n                self.layout().itemAt(i).setAlignment(QtCore.Qt.AlignCenter)\r\n"}
{"image_path": "data\\train\\00346.png", "code": "import re\r\n\r\nfrom qtpy import QT_VERSION\r\nfrom qtpy import QtCore\r\nfrom qtpy import QtGui\r\nfrom qtpy import QtWidgets\r\n\r\nimport labelme.utils\r\nfrom labelme.logger import logger\r\n\r\nQT5 = QT_VERSION[0] == \"5\"\r\n\r\n\r\n# TODO(unknown):\r\n# - Calculate optimal position so as not to go out of screen area.\r\n\r\n\r\nclass LabelQLineEdit(QtWidgets.QLineEdit):\r\n    def setListWidget(self, list_widget):\r\n        self.list_widget = list_widget\r\n\r\n    def keyPressEvent(self, e):\r\n        if e.key() in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Down]:\r\n            self.list_widget.keyPressEvent(e)\r\n        else:\r\n            super(LabelQLineEdit, self).keyPressEvent(e)\r\n\r\n\r\nclass LabelDialog(QtWidgets.QDialog):\r\n    def __init__(\r\n        self,\r\n        text=\"Enter object label\",\r\n        parent=None,\r\n        labels=None,\r\n        sort_labels=True,\r\n        show_text_field=True,\r\n        completion=\"startswith\",\r\n        fit_to_content=None,\r\n        flags=None,\r\n    ):\r\n"}
{"image_path": "data\\train\\00347.png", "code": "        if fit_to_content is None:\r\n            fit_to_content = {\"row\": False, \"column\": True}\r\n        self._fit_to_content = fit_to_content\r\n\r\n        super(LabelDialog, self).__init__(parent)\r\n        self.edit = LabelQLineEdit()\r\n        self.edit.setPlaceholderText(text)\r\n        self.edit.setValidator(labelme.utils.labelValidator())\r\n        self.edit.editingFinished.connect(self.postProcess)\r\n        if flags:\r\n            self.edit.textChanged.connect(self.updateFlags)\r\n        self.edit_group_id = QtWidgets.QLineEdit()\r\n        self.edit_group_id.setPlaceholderText(\"Group ID\")\r\n        self.edit_group_id.setValidator(\r\n            QtGui.QRegExpValidator(QtCore.QRegExp(r\"\\d*\"), None)\r\n        )\r\n        layout = QtWidgets.QVBoxLayout()\r\n        if show_text_field:\r\n            layout_edit = QtWidgets.QHBoxLayout()\r\n            layout_edit.addWidget(self.edit, 6)\r\n            layout_edit.addWidget(self.edit_group_id, 2)\r\n            layout.addLayout(layout_edit)\r\n        # buttons\r\n        self.buttonBox = bb = QtWidgets.QDialogButtonBox(\r\n            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,\r\n            QtCore.Qt.Horizontal,\r\n            self,\r\n        )\r\n        bb.button(bb.Ok).setIcon(labelme.utils.newIcon(\"done\"))\r\n        bb.button(bb.Cancel).setIcon(labelme.utils.newIcon(\"undo\"))\r\n        bb.accepted.connect(self.validate)\r\n        bb.rejected.connect(self.reject)\r\n        layout.addWidget(bb)\r\n        # label_list\r\n        self.labelList = QtWidgets.QListWidget()\r\n        if self._fit_to_content[\"row\"]:\r\n            self.labelList.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\r\n        if self._fit_to_content[\"column\"]:\r\n            self.labelList.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\r\n        self._sort_labels = sort_labels\r\n"}
{"image_path": "data\\train\\00348.png", "code": "        if labels:\r\n            self.labelList.addItems(labels)\r\n        if self._sort_labels:\r\n            self.labelList.sortItems()\r\n        else:\r\n            self.labelList.setDragDropMode(QtWidgets.QAbstractItemView.InternalMove)\r\n        self.labelList.currentItemChanged.connect(self.labelSelected)\r\n        self.labelList.itemDoubleClicked.connect(self.labelDoubleClicked)\r\n        self.labelList.setFixedHeight(150)\r\n        self.edit.setListWidget(self.labelList)\r\n        layout.addWidget(self.labelList)\r\n        # label_flags\r\n        if flags is None:\r\n            flags = {}\r\n        self._flags = flags\r\n        self.flagsLayout = QtWidgets.QVBoxLayout()\r\n        self.resetFlags()\r\n        layout.addItem(self.flagsLayout)\r\n        self.edit.textChanged.connect(self.updateFlags)\r\n        # text edit\r\n        self.editDescription = QtWidgets.QTextEdit()\r\n        self.editDescription.setPlaceholderText(\"Label description\")\r\n        self.editDescription.setFixedHeight(50)\r\n        layout.addWidget(self.editDescription)\r\n        self.setLayout(layout)\r\n        # completion\r\n        completer = QtWidgets.QCompleter()\r\n        if not QT5 and completion != \"startswith\":\r\n            logger.warn(\r\n                \"completion other than 'startswith' is only \"\r\n                \"supported with Qt5. Using 'startswith'\"\r\n            )\r\n            completion = \"startswith\"\r\n        if completion == \"startswith\":\r\n            completer.setCompletionMode(QtWidgets.QCompleter.InlineCompletion)\r\n            # Default settings.\r\n            # completer.setFilterMode(QtCore.Qt.MatchStartsWith)\r\n        elif completion == \"contains\":\r\n            completer.setCompletionMode(QtWidgets.QCompleter.PopupCompletion)\r\n            completer.setFilterMode(QtCore.Qt.MatchContains)\r\n"}
{"image_path": "data\\train\\00349.png", "code": "        else:\r\n            raise ValueError(\"Unsupported completion: {}\".format(completion))\r\n        completer.setModel(self.labelList.model())\r\n        self.edit.setCompleter(completer)\r\n\r\n    def addLabelHistory(self, label):\r\n        if self.labelList.findItems(label, QtCore.Qt.MatchExactly):\r\n            return\r\n        self.labelList.addItem(label)\r\n        if self._sort_labels:\r\n            self.labelList.sortItems()\r\n\r\n    def labelSelected(self, item):\r\n        self.edit.setText(item.text())\r\n\r\n    def validate(self):\r\n        text = self.edit.text()\r\n        if hasattr(text, \"strip\"):\r\n            text = text.strip()\r\n        else:\r\n            text = text.trimmed()\r\n        if text:\r\n            self.accept()\r\n\r\n    def labelDoubleClicked(self, item):\r\n        self.validate()\r\n\r\n    def postProcess(self):\r\n        text = self.edit.text()\r\n        if hasattr(text, \"strip\"):\r\n            text = text.strip()\r\n        else:\r\n            text = text.trimmed()\r\n        self.edit.setText(text)\r\n\r\n    def updateFlags(self, label_new):\r\n        # keep state of shared flags\r\n        flags_old = self.getFlags()\r\n\r\n        flags_new = {}\r\n"}
{"image_path": "data\\train\\00350.png", "code": "        for pattern, keys in self._flags.items():\r\n            if re.match(pattern, label_new):\r\n                for key in keys:\r\n                    flags_new[key] = flags_old.get(key, False)\r\n        self.setFlags(flags_new)\r\n\r\n    def deleteFlags(self):\r\n        for i in reversed(range(self.flagsLayout.count())):\r\n            item = self.flagsLayout.itemAt(i).widget()\r\n            self.flagsLayout.removeWidget(item)\r\n            item.setParent(None)\r\n\r\n    def resetFlags(self, label=\"\"):\r\n        flags = {}\r\n        for pattern, keys in self._flags.items():\r\n            if re.match(pattern, label):\r\n                for key in keys:\r\n                    flags[key] = False\r\n        self.setFlags(flags)\r\n\r\n    def setFlags(self, flags):\r\n        self.deleteFlags()\r\n        for key in flags:\r\n            item = QtWidgets.QCheckBox(key, self)\r\n            item.setChecked(flags[key])\r\n            self.flagsLayout.addWidget(item)\r\n            item.show()\r\n\r\n    def getFlags(self):\r\n        flags = {}\r\n        for i in range(self.flagsLayout.count()):\r\n            item = self.flagsLayout.itemAt(i).widget()\r\n            flags[item.text()] = item.isChecked()\r\n        return flags\r\n\r\n    def getGroupId(self):\r\n        group_id = self.edit_group_id.text()\r\n        if group_id:\r\n            return int(group_id)\r\n        return None\r\n"}
{"image_path": "data\\train\\00351.png", "code": "\r\n    def popUp(self, text=None, move=True, flags=None, group_id=None, description=None):\r\n        if self._fit_to_content[\"row\"]:\r\n            self.labelList.setMinimumHeight(\r\n                self.labelList.sizeHintForRow(0) * self.labelList.count() + 2\r\n            )\r\n        if self._fit_to_content[\"column\"]:\r\n            self.labelList.setMinimumWidth(self.labelList.sizeHintForColumn(0) + 2)\r\n        # if text is None, the previous label in self.edit is kept\r\n        if text is None:\r\n            text = self.edit.text()\r\n        # description is always initialized by empty text c.f., self.edit.text\r\n        if description is None:\r\n            description = \"\"\r\n        self.editDescription.setPlainText(description)\r\n        if flags:\r\n            self.setFlags(flags)\r\n        else:\r\n            self.resetFlags(text)\r\n        self.edit.setText(text)\r\n        self.edit.setSelection(0, len(text))\r\n        if group_id is None:\r\n            self.edit_group_id.clear()\r\n        else:\r\n            self.edit_group_id.setText(str(group_id))\r\n        items = self.labelList.findItems(text, QtCore.Qt.MatchFixedString)\r\n        if items:\r\n            if len(items) != 1:\r\n                logger.warning(\"Label list has duplicate '{}'\".format(text))\r\n            self.labelList.setCurrentItem(items[0])\r\n            row = self.labelList.row(items[0])\r\n            self.edit.completer().setCurrentRow(row)\r\n        self.edit.setFocus(QtCore.Qt.PopupFocusReason)\r\n        if move:\r\n            self.move(QtGui.QCursor.pos())\r\n        if self.exec_():\r\n            return (\r\n                self.edit.text(),\r\n                self.getFlags(),\r\n                self.getGroupId(),\r\n"}
{"image_path": "data\\train\\00352.png", "code": "                self.editDescription.toPlainText(),\r\n            )\r\n        else:\r\n            return None, None, None, None\r\n"}
{"image_path": "data\\train\\00353.png", "code": "# flake8: noqa\r\n\r\nfrom .brightness_contrast_dialog import BrightnessContrastDialog\r\n\r\nfrom .canvas import Canvas\r\n\r\nfrom .color_dialog import ColorDialog\r\n\r\nfrom .file_dialog_preview import FileDialogPreview\r\n\r\nfrom .label_dialog import LabelDialog\r\nfrom .label_dialog import LabelQLineEdit\r\n\r\nfrom .label_list_widget import LabelListWidget\r\nfrom .label_list_widget import LabelListWidgetItem\r\n\r\nfrom .tool_bar import ToolBar\r\n\r\nfrom .unique_label_qlist_widget import UniqueLabelQListWidget\r\n\r\nfrom .zoom_widget import ZoomWidget\r\n"}
{"image_path": "data\\train\\00354.png", "code": "from qtpy import QtWidgets\r\nfrom qtpy.QtCore import Qt\r\n\r\n\r\nclass EscapableQListWidget(QtWidgets.QListWidget):\r\n    def keyPressEvent(self, event):\r\n        super(EscapableQListWidget, self).keyPressEvent(event)\r\n        if event.key() == Qt.Key_Escape:\r\n            self.clearSelection()\r\n"}
{"image_path": "data\\train\\00355.png", "code": "import imgviz\r\nfrom qtpy import QtCore\r\nfrom qtpy import QtGui\r\nfrom qtpy import QtWidgets\r\n\r\nimport labelme.ai\r\nimport labelme.utils\r\nfrom labelme import QT5\r\nfrom labelme.logger import logger\r\nfrom labelme.shape import Shape\r\n\r\n# TODO(unknown):\r\n# - [maybe] Find optimal epsilon value.\r\n\r\n\r\nCURSOR_DEFAULT = QtCore.Qt.ArrowCursor\r\nCURSOR_POINT = QtCore.Qt.PointingHandCursor\r\nCURSOR_DRAW = QtCore.Qt.CrossCursor\r\nCURSOR_MOVE = QtCore.Qt.ClosedHandCursor\r\nCURSOR_GRAB = QtCore.Qt.OpenHandCursor\r\n\r\nMOVE_SPEED = 5.0\r\n\r\n\r\nclass Canvas(QtWidgets.QWidget):\r\n    zoomRequest = QtCore.Signal(int, QtCore.QPoint)\r\n    scrollRequest = QtCore.Signal(int, int)\r\n    newShape = QtCore.Signal()\r\n    selectionChanged = QtCore.Signal(list)\r\n    shapeMoved = QtCore.Signal()\r\n    drawingPolygon = QtCore.Signal(bool)\r\n    vertexSelected = QtCore.Signal(bool)\r\n\r\n    CREATE, EDIT = 0, 1\r\n\r\n    # polygon, rectangle, line, or point\r\n    _createMode = \"polygon\"\r\n\r\n    _fill_drawing = False\r\n\r\n"}
{"image_path": "data\\train\\00356.png", "code": "    def __init__(self, *args, **kwargs):\r\n        self.epsilon = kwargs.pop(\"epsilon\", 10.0)\r\n        self.double_click = kwargs.pop(\"double_click\", \"close\")\r\n        if self.double_click not in [None, \"close\"]:\r\n            raise ValueError(\r\n                \"Unexpected value for double_click event: {}\".format(self.double_click)\r\n            )\r\n        self.num_backups = kwargs.pop(\"num_backups\", 10)\r\n        self._crosshair = kwargs.pop(\r\n            \"crosshair\",\r\n            {\r\n                \"polygon\": False,\r\n                \"rectangle\": True,\r\n                \"circle\": False,\r\n                \"line\": False,\r\n                \"point\": False,\r\n                \"linestrip\": False,\r\n                \"ai_polygon\": False,\r\n                \"ai_mask\": False,\r\n            },\r\n        )\r\n        super(Canvas, self).__init__(*args, **kwargs)\r\n        # Initialise local state.\r\n        self.mode = self.EDIT\r\n        self.shapes = []\r\n        self.shapesBackups = []\r\n        self.current = None\r\n        self.selectedShapes = []  # save the selected shapes here\r\n        self.selectedShapesCopy = []\r\n        # self.line represents:\r\n        #   - createMode == 'polygon': edge from last point to current\r\n        #   - createMode == 'rectangle': diagonal line of the rectangle\r\n        #   - createMode == 'line': the line\r\n        #   - createMode == 'point': the point\r\n        self.line = Shape()\r\n        self.prevPoint = QtCore.QPoint()\r\n        self.prevMovePoint = QtCore.QPoint()\r\n        self.offsets = QtCore.QPoint(), QtCore.QPoint()\r\n        self.scale = 1.0\r\n        self.pixmap = QtGui.QPixmap()\r\n"}
{"image_path": "data\\train\\00357.png", "code": "        self.visible = {}\r\n        self._hideBackround = False\r\n        self.hideBackround = False\r\n        self.hShape = None\r\n        self.prevhShape = None\r\n        self.hVertex = None\r\n        self.prevhVertex = None\r\n        self.hEdge = None\r\n        self.prevhEdge = None\r\n        self.movingShape = False\r\n        self.snapping = True\r\n        self.hShapeIsSelected = False\r\n        self._painter = QtGui.QPainter()\r\n        self._cursor = CURSOR_DEFAULT\r\n        # Menus:\r\n        # 0: right-click without selection and dragging of shapes\r\n        # 1: right-click with selection and dragging of shapes\r\n        self.menus = (QtWidgets.QMenu(), QtWidgets.QMenu())\r\n        # Set widget options.\r\n        self.setMouseTracking(True)\r\n        self.setFocusPolicy(QtCore.Qt.WheelFocus)\r\n\r\n        self._ai_model = None\r\n\r\n    def fillDrawing(self):\r\n        return self._fill_drawing\r\n\r\n    def setFillDrawing(self, value):\r\n        self._fill_drawing = value\r\n\r\n    @property\r\n    def createMode(self):\r\n        return self._createMode\r\n\r\n    @createMode.setter\r\n    def createMode(self, value):\r\n        if value not in [\r\n            \"polygon\",\r\n            \"rectangle\",\r\n            \"circle\",\r\n"}
{"image_path": "data\\train\\00358.png", "code": "            \"line\",\r\n            \"point\",\r\n            \"linestrip\",\r\n            \"ai_polygon\",\r\n            \"ai_mask\",\r\n        ]:\r\n            raise ValueError(\"Unsupported createMode: %s\" % value)\r\n        self._createMode = value\r\n\r\n    def initializeAiModel(self, name):\r\n        if name not in [model.name for model in labelme.ai.MODELS]:\r\n            raise ValueError(\"Unsupported ai model: %s\" % name)\r\n        model = [model for model in labelme.ai.MODELS if model.name == name][0]\r\n\r\n        if self._ai_model is not None and self._ai_model.name == model.name:\r\n            logger.debug(\"AI model is already initialized: %r\" % model.name)\r\n        else:\r\n            logger.debug(\"Initializing AI model: %r\" % model.name)\r\n            self._ai_model = model()\r\n\r\n        if self.pixmap is None:\r\n            logger.warning(\"Pixmap is not set yet\")\r\n            return\r\n\r\n        self._ai_model.set_image(\r\n            image=labelme.utils.img_qt_to_arr(self.pixmap.toImage())\r\n        )\r\n\r\n    def storeShapes(self):\r\n        shapesBackup = []\r\n        for shape in self.shapes:\r\n            shapesBackup.append(shape.copy())\r\n        if len(self.shapesBackups) > self.num_backups:\r\n            self.shapesBackups = self.shapesBackups[-self.num_backups - 1 :]\r\n        self.shapesBackups.append(shapesBackup)\r\n\r\n    @property\r\n    def isShapeRestorable(self):\r\n        # We save the state AFTER each edit (not before) so for an\r\n        # edit to be undoable, we expect the CURRENT and the PREVIOUS state\r\n"}
{"image_path": "data\\train\\00359.png", "code": "        # to be in the undo stack.\r\n        if len(self.shapesBackups) < 2:\r\n            return False\r\n        return True\r\n\r\n    def restoreShape(self):\r\n        # This does _part_ of the job of restoring shapes.\r\n        # The complete process is also done in app.py::undoShapeEdit\r\n        # and app.py::loadShapes and our own Canvas::loadShapes function.\r\n        if not self.isShapeRestorable:\r\n            return\r\n        self.shapesBackups.pop()  # latest\r\n\r\n        # The application will eventually call Canvas.loadShapes which will\r\n        # push this right back onto the stack.\r\n        shapesBackup = self.shapesBackups.pop()\r\n        self.shapes = shapesBackup\r\n        self.selectedShapes = []\r\n        for shape in self.shapes:\r\n            shape.selected = False\r\n        self.update()\r\n\r\n    def enterEvent(self, ev):\r\n        self.overrideCursor(self._cursor)\r\n\r\n    def leaveEvent(self, ev):\r\n        self.unHighlight()\r\n        self.restoreCursor()\r\n\r\n    def focusOutEvent(self, ev):\r\n        self.restoreCursor()\r\n\r\n    def isVisible(self, shape):\r\n        return self.visible.get(shape, True)\r\n\r\n    def drawing(self):\r\n        return self.mode == self.CREATE\r\n\r\n    def editing(self):\r\n        return self.mode == self.EDIT\r\n"}
{"image_path": "data\\train\\00360.png", "code": "\r\n    def setEditing(self, value=True):\r\n        self.mode = self.EDIT if value else self.CREATE\r\n        if self.mode == self.EDIT:\r\n            # CREATE -> EDIT\r\n            self.repaint()  # clear crosshair\r\n        else:\r\n            # EDIT -> CREATE\r\n            self.unHighlight()\r\n            self.deSelectShape()\r\n\r\n    def unHighlight(self):\r\n        if self.hShape:\r\n            self.hShape.highlightClear()\r\n            self.update()\r\n        self.prevhShape = self.hShape\r\n        self.prevhVertex = self.hVertex\r\n        self.prevhEdge = self.hEdge\r\n        self.hShape = self.hVertex = self.hEdge = None\r\n\r\n    def selectedVertex(self):\r\n        return self.hVertex is not None\r\n\r\n    def selectedEdge(self):\r\n        return self.hEdge is not None\r\n\r\n    def mouseMoveEvent(self, ev):\r\n        \"\"\"Update line with last point and current coordinates.\"\"\"\r\n        try:\r\n            if QT5:\r\n                pos = self.transformPos(ev.localPos())\r\n            else:\r\n                pos = self.transformPos(ev.posF())\r\n        except AttributeError:\r\n            return\r\n\r\n        self.prevMovePoint = pos\r\n        self.restoreCursor()\r\n\r\n        is_shift_pressed = ev.modifiers() & QtCore.Qt.ShiftModifier\r\n"}
{"image_path": "data\\train\\00361.png", "code": "\r\n        # Polygon drawing.\r\n        if self.drawing():\r\n            if self.createMode in [\"ai_polygon\", \"ai_mask\"]:\r\n                self.line.shape_type = \"points\"\r\n            else:\r\n                self.line.shape_type = self.createMode\r\n\r\n            self.overrideCursor(CURSOR_DRAW)\r\n            if not self.current:\r\n                self.repaint()  # draw crosshair\r\n                return\r\n\r\n            if self.outOfPixmap(pos):\r\n                # Don't allow the user to draw outside the pixmap.\r\n                # Project the point to the pixmap's edges.\r\n                pos = self.intersectionPoint(self.current[-1], pos)\r\n            elif (\r\n                self.snapping\r\n                and len(self.current) > 1\r\n                and self.createMode == \"polygon\"\r\n                and self.closeEnough(pos, self.current[0])\r\n            ):\r\n                # Attract line to starting point and\r\n                # colorise to alert the user.\r\n                pos = self.current[0]\r\n                self.overrideCursor(CURSOR_POINT)\r\n                self.current.highlightVertex(0, Shape.NEAR_VERTEX)\r\n            if self.createMode in [\"polygon\", \"linestrip\"]:\r\n                self.line.points = [self.current[-1], pos]\r\n                self.line.point_labels = [1, 1]\r\n            elif self.createMode in [\"ai_polygon\", \"ai_mask\"]:\r\n                self.line.points = [self.current.points[-1], pos]\r\n                self.line.point_labels = [\r\n                    self.current.point_labels[-1],\r\n                    0 if is_shift_pressed else 1,\r\n                ]\r\n            elif self.createMode == \"rectangle\":\r\n                self.line.points = [self.current[0], pos]\r\n                self.line.point_labels = [1, 1]\r\n"}
{"image_path": "data\\train\\00362.png", "code": "                self.line.close()\r\n            elif self.createMode == \"circle\":\r\n                self.line.points = [self.current[0], pos]\r\n                self.line.point_labels = [1, 1]\r\n                self.line.shape_type = \"circle\"\r\n            elif self.createMode == \"line\":\r\n                self.line.points = [self.current[0], pos]\r\n                self.line.point_labels = [1, 1]\r\n                self.line.close()\r\n            elif self.createMode == \"point\":\r\n                self.line.points = [self.current[0]]\r\n                self.line.point_labels = [1]\r\n                self.line.close()\r\n            assert len(self.line.points) == len(self.line.point_labels)\r\n            self.repaint()\r\n            self.current.highlightClear()\r\n            return\r\n\r\n        # Polygon copy moving.\r\n        if QtCore.Qt.RightButton & ev.buttons():\r\n            if self.selectedShapesCopy and self.prevPoint:\r\n                self.overrideCursor(CURSOR_MOVE)\r\n                self.boundedMoveShapes(self.selectedShapesCopy, pos)\r\n                self.repaint()\r\n            elif self.selectedShapes:\r\n                self.selectedShapesCopy = [s.copy() for s in self.selectedShapes]\r\n                self.repaint()\r\n            return\r\n\r\n        # Polygon/Vertex moving.\r\n        if QtCore.Qt.LeftButton & ev.buttons():\r\n            if self.selectedVertex():\r\n                self.boundedMoveVertex(pos)\r\n                self.repaint()\r\n                self.movingShape = True\r\n            elif self.selectedShapes and self.prevPoint:\r\n                self.overrideCursor(CURSOR_MOVE)\r\n                self.boundedMoveShapes(self.selectedShapes, pos)\r\n                self.repaint()\r\n                self.movingShape = True\r\n"}
{"image_path": "data\\train\\00363.png", "code": "            return\r\n\r\n        # Just hovering over the canvas, 2 possibilities:\r\n        # - Highlight shapes\r\n        # - Highlight vertex\r\n        # Update shape/vertex fill and tooltip value accordingly.\r\n        self.setToolTip(self.tr(\"Image\"))\r\n        for shape in reversed([s for s in self.shapes if self.isVisible(s)]):\r\n            # Look for a nearby vertex to highlight. If that fails,\r\n            # check if we happen to be inside a shape.\r\n            index = shape.nearestVertex(pos, self.epsilon / self.scale)\r\n            index_edge = shape.nearestEdge(pos, self.epsilon / self.scale)\r\n            if index is not None:\r\n                if self.selectedVertex():\r\n                    self.hShape.highlightClear()\r\n                self.prevhVertex = self.hVertex = index\r\n                self.prevhShape = self.hShape = shape\r\n                self.prevhEdge = self.hEdge\r\n                self.hEdge = None\r\n                shape.highlightVertex(index, shape.MOVE_VERTEX)\r\n                self.overrideCursor(CURSOR_POINT)\r\n                self.setToolTip(self.tr(\"Click & drag to move point\"))\r\n                self.setStatusTip(self.toolTip())\r\n                self.update()\r\n                break\r\n            elif index_edge is not None and shape.canAddPoint():\r\n                if self.selectedVertex():\r\n                    self.hShape.highlightClear()\r\n                self.prevhVertex = self.hVertex\r\n                self.hVertex = None\r\n                self.prevhShape = self.hShape = shape\r\n                self.prevhEdge = self.hEdge = index_edge\r\n                self.overrideCursor(CURSOR_POINT)\r\n                self.setToolTip(self.tr(\"Click to create point\"))\r\n                self.setStatusTip(self.toolTip())\r\n                self.update()\r\n                break\r\n            elif shape.containsPoint(pos):\r\n                if self.selectedVertex():\r\n                    self.hShape.highlightClear()\r\n"}
{"image_path": "data\\train\\00364.png", "code": "                self.prevhVertex = self.hVertex\r\n                self.hVertex = None\r\n                self.prevhShape = self.hShape = shape\r\n                self.prevhEdge = self.hEdge\r\n                self.hEdge = None\r\n                self.setToolTip(\r\n                    self.tr(\"Click & drag to move shape '%s'\") % shape.label\r\n                )\r\n                self.setStatusTip(self.toolTip())\r\n                self.overrideCursor(CURSOR_GRAB)\r\n                self.update()\r\n                break\r\n        else:  # Nothing found, clear highlights, reset state.\r\n            self.unHighlight()\r\n        self.vertexSelected.emit(self.hVertex is not None)\r\n\r\n    def addPointToEdge(self):\r\n        shape = self.prevhShape\r\n        index = self.prevhEdge\r\n        point = self.prevMovePoint\r\n        if shape is None or index is None or point is None:\r\n            return\r\n        shape.insertPoint(index, point)\r\n        shape.highlightVertex(index, shape.MOVE_VERTEX)\r\n        self.hShape = shape\r\n        self.hVertex = index\r\n        self.hEdge = None\r\n        self.movingShape = True\r\n\r\n    def removeSelectedPoint(self):\r\n        shape = self.prevhShape\r\n        index = self.prevhVertex\r\n        if shape is None or index is None:\r\n            return\r\n        shape.removePoint(index)\r\n        shape.highlightClear()\r\n        self.hShape = shape\r\n        self.prevhVertex = None\r\n        self.movingShape = True  # Save changes\r\n\r\n"}
{"image_path": "data\\train\\00365.png", "code": "    def mousePressEvent(self, ev):\r\n        if QT5:\r\n            pos = self.transformPos(ev.localPos())\r\n        else:\r\n            pos = self.transformPos(ev.posF())\r\n\r\n        is_shift_pressed = ev.modifiers() & QtCore.Qt.ShiftModifier\r\n\r\n        if ev.button() == QtCore.Qt.LeftButton:\r\n            if self.drawing():\r\n                if self.current:\r\n                    # Add point to existing shape.\r\n                    if self.createMode == \"polygon\":\r\n                        self.current.addPoint(self.line[1])\r\n                        self.line[0] = self.current[-1]\r\n                        if self.current.isClosed():\r\n                            self.finalise()\r\n                    elif self.createMode in [\"rectangle\", \"circle\", \"line\"]:\r\n                        assert len(self.current.points) == 1\r\n                        self.current.points = self.line.points\r\n                        self.finalise()\r\n                    elif self.createMode == \"linestrip\":\r\n                        self.current.addPoint(self.line[1])\r\n                        self.line[0] = self.current[-1]\r\n                        if int(ev.modifiers()) == QtCore.Qt.ControlModifier:\r\n                            self.finalise()\r\n                    elif self.createMode in [\"ai_polygon\", \"ai_mask\"]:\r\n                        self.current.addPoint(\r\n                            self.line.points[1],\r\n                            label=self.line.point_labels[1],\r\n                        )\r\n                        self.line.points[0] = self.current.points[-1]\r\n                        self.line.point_labels[0] = self.current.point_labels[-1]\r\n                        if ev.modifiers() & QtCore.Qt.ControlModifier:\r\n                            self.finalise()\r\n                elif not self.outOfPixmap(pos):\r\n                    # Create new shape.\r\n                    self.current = Shape(\r\n                        shape_type=\"points\"\r\n                        if self.createMode in [\"ai_polygon\", \"ai_mask\"]\r\n"}
{"image_path": "data\\train\\00366.png", "code": "                        else self.createMode\r\n                    )\r\n                    self.current.addPoint(pos, label=0 if is_shift_pressed else 1)\r\n                    if self.createMode == \"point\":\r\n                        self.finalise()\r\n                    elif (\r\n                        self.createMode in [\"ai_polygon\", \"ai_mask\"]\r\n                        and ev.modifiers() & QtCore.Qt.ControlModifier\r\n                    ):\r\n                        self.finalise()\r\n                    else:\r\n                        if self.createMode == \"circle\":\r\n                            self.current.shape_type = \"circle\"\r\n                        self.line.points = [pos, pos]\r\n                        if (\r\n                            self.createMode in [\"ai_polygon\", \"ai_mask\"]\r\n                            and is_shift_pressed\r\n                        ):\r\n                            self.line.point_labels = [0, 0]\r\n                        else:\r\n                            self.line.point_labels = [1, 1]\r\n                        self.setHiding()\r\n                        self.drawingPolygon.emit(True)\r\n                        self.update()\r\n            elif self.editing():\r\n                if self.selectedEdge():\r\n                    self.addPointToEdge()\r\n                elif (\r\n                    self.selectedVertex()\r\n                    and int(ev.modifiers()) == QtCore.Qt.ShiftModifier\r\n                ):\r\n                    # Delete point if: left-click + SHIFT on a point\r\n                    self.removeSelectedPoint()\r\n\r\n                group_mode = int(ev.modifiers()) == QtCore.Qt.ControlModifier\r\n                self.selectShapePoint(pos, multiple_selection_mode=group_mode)\r\n                self.prevPoint = pos\r\n                self.repaint()\r\n        elif ev.button() == QtCore.Qt.RightButton and self.editing():\r\n            group_mode = int(ev.modifiers()) == QtCore.Qt.ControlModifier\r\n"}
{"image_path": "data\\train\\00367.png", "code": "            if not self.selectedShapes or (\r\n                self.hShape is not None and self.hShape not in self.selectedShapes\r\n            ):\r\n                self.selectShapePoint(pos, multiple_selection_mode=group_mode)\r\n                self.repaint()\r\n            self.prevPoint = pos\r\n\r\n    def mouseReleaseEvent(self, ev):\r\n        if ev.button() == QtCore.Qt.RightButton:\r\n            menu = self.menus[len(self.selectedShapesCopy) > 0]\r\n            self.restoreCursor()\r\n            if not menu.exec_(self.mapToGlobal(ev.pos())) and self.selectedShapesCopy:\r\n                # Cancel the move by deleting the shadow copy.\r\n                self.selectedShapesCopy = []\r\n                self.repaint()\r\n        elif ev.button() == QtCore.Qt.LeftButton:\r\n            if self.editing():\r\n                if (\r\n                    self.hShape is not None\r\n                    and self.hShapeIsSelected\r\n                    and not self.movingShape\r\n                ):\r\n                    self.selectionChanged.emit(\r\n                        [x for x in self.selectedShapes if x != self.hShape]\r\n                    )\r\n\r\n        if self.movingShape and self.hShape:\r\n            index = self.shapes.index(self.hShape)\r\n            if self.shapesBackups[-1][index].points != self.shapes[index].points:\r\n                self.storeShapes()\r\n                self.shapeMoved.emit()\r\n\r\n            self.movingShape = False\r\n\r\n    def endMove(self, copy):\r\n        assert self.selectedShapes and self.selectedShapesCopy\r\n        assert len(self.selectedShapesCopy) == len(self.selectedShapes)\r\n        if copy:\r\n            for i, shape in enumerate(self.selectedShapesCopy):\r\n                self.shapes.append(shape)\r\n"}
{"image_path": "data\\train\\00368.png", "code": "                self.selectedShapes[i].selected = False\r\n                self.selectedShapes[i] = shape\r\n        else:\r\n            for i, shape in enumerate(self.selectedShapesCopy):\r\n                self.selectedShapes[i].points = shape.points\r\n        self.selectedShapesCopy = []\r\n        self.repaint()\r\n        self.storeShapes()\r\n        return True\r\n\r\n    def hideBackroundShapes(self, value):\r\n        self.hideBackround = value\r\n        if self.selectedShapes:\r\n            # Only hide other shapes if there is a current selection.\r\n            # Otherwise the user will not be able to select a shape.\r\n            self.setHiding(True)\r\n            self.update()\r\n\r\n    def setHiding(self, enable=True):\r\n        self._hideBackround = self.hideBackround if enable else False\r\n\r\n    def canCloseShape(self):\r\n        return self.drawing() and self.current and len(self.current) > 2\r\n\r\n    def mouseDoubleClickEvent(self, ev):\r\n        if self.double_click != \"close\":\r\n            return\r\n\r\n        if (\r\n            self.createMode == \"polygon\" and self.canCloseShape()\r\n        ) or self.createMode in [\"ai_polygon\", \"ai_mask\"]:\r\n            self.finalise()\r\n\r\n    def selectShapes(self, shapes):\r\n        self.setHiding()\r\n        self.selectionChanged.emit(shapes)\r\n        self.update()\r\n\r\n    def selectShapePoint(self, point, multiple_selection_mode):\r\n        \"\"\"Select the first shape created which contains this point.\"\"\"\r\n"}
{"image_path": "data\\train\\00369.png", "code": "        if self.selectedVertex():  # A vertex is marked for selection.\r\n            index, shape = self.hVertex, self.hShape\r\n            shape.highlightVertex(index, shape.MOVE_VERTEX)\r\n        else:\r\n            for shape in reversed(self.shapes):\r\n                if self.isVisible(shape) and shape.containsPoint(point):\r\n                    self.setHiding()\r\n                    if shape not in self.selectedShapes:\r\n                        if multiple_selection_mode:\r\n                            self.selectionChanged.emit(self.selectedShapes + [shape])\r\n                        else:\r\n                            self.selectionChanged.emit([shape])\r\n                        self.hShapeIsSelected = False\r\n                    else:\r\n                        self.hShapeIsSelected = True\r\n                    self.calculateOffsets(point)\r\n                    return\r\n        self.deSelectShape()\r\n\r\n    def calculateOffsets(self, point):\r\n        left = self.pixmap.width() - 1\r\n        right = 0\r\n        top = self.pixmap.height() - 1\r\n        bottom = 0\r\n        for s in self.selectedShapes:\r\n            rect = s.boundingRect()\r\n            if rect.left() < left:\r\n                left = rect.left()\r\n            if rect.right() > right:\r\n                right = rect.right()\r\n            if rect.top() < top:\r\n                top = rect.top()\r\n            if rect.bottom() > bottom:\r\n                bottom = rect.bottom()\r\n\r\n        x1 = left - point.x()\r\n        y1 = top - point.y()\r\n        x2 = right - point.x()\r\n        y2 = bottom - point.y()\r\n        self.offsets = QtCore.QPointF(x1, y1), QtCore.QPointF(x2, y2)\r\n"}
{"image_path": "data\\train\\00370.png", "code": "\r\n    def boundedMoveVertex(self, pos):\r\n        index, shape = self.hVertex, self.hShape\r\n        point = shape[index]\r\n        if self.outOfPixmap(pos):\r\n            pos = self.intersectionPoint(point, pos)\r\n        shape.moveVertexBy(index, pos - point)\r\n\r\n    def boundedMoveShapes(self, shapes, pos):\r\n        if self.outOfPixmap(pos):\r\n            return False  # No need to move\r\n        o1 = pos + self.offsets[0]\r\n        if self.outOfPixmap(o1):\r\n            pos -= QtCore.QPointF(min(0, o1.x()), min(0, o1.y()))\r\n        o2 = pos + self.offsets[1]\r\n        if self.outOfPixmap(o2):\r\n            pos += QtCore.QPointF(\r\n                min(0, self.pixmap.width() - o2.x()),\r\n                min(0, self.pixmap.height() - o2.y()),\r\n            )\r\n        # XXX: The next line tracks the new position of the cursor\r\n        # relative to the shape, but also results in making it\r\n        # a bit \"shaky\" when nearing the border and allows it to\r\n        # go outside of the shape's area for some reason.\r\n        # self.calculateOffsets(self.selectedShapes, pos)\r\n        dp = pos - self.prevPoint\r\n        if dp:\r\n            for shape in shapes:\r\n                shape.moveBy(dp)\r\n            self.prevPoint = pos\r\n            return True\r\n        return False\r\n\r\n    def deSelectShape(self):\r\n        if self.selectedShapes:\r\n            self.setHiding(False)\r\n            self.selectionChanged.emit([])\r\n            self.hShapeIsSelected = False\r\n            self.update()\r\n\r\n"}
{"image_path": "data\\train\\00371.png", "code": "    def deleteSelected(self):\r\n        deleted_shapes = []\r\n        if self.selectedShapes:\r\n            for shape in self.selectedShapes:\r\n                self.shapes.remove(shape)\r\n                deleted_shapes.append(shape)\r\n            self.storeShapes()\r\n            self.selectedShapes = []\r\n            self.update()\r\n        return deleted_shapes\r\n\r\n    def deleteShape(self, shape):\r\n        if shape in self.selectedShapes:\r\n            self.selectedShapes.remove(shape)\r\n        if shape in self.shapes:\r\n            self.shapes.remove(shape)\r\n        self.storeShapes()\r\n        self.update()\r\n\r\n    def duplicateSelectedShapes(self):\r\n        if self.selectedShapes:\r\n            self.selectedShapesCopy = [s.copy() for s in self.selectedShapes]\r\n            self.boundedShiftShapes(self.selectedShapesCopy)\r\n            self.endMove(copy=True)\r\n        return self.selectedShapes\r\n\r\n    def boundedShiftShapes(self, shapes):\r\n        # Try to move in one direction, and if it fails in another.\r\n        # Give up if both fail.\r\n        point = shapes[0][0]\r\n        offset = QtCore.QPointF(2.0, 2.0)\r\n        self.offsets = QtCore.QPoint(), QtCore.QPoint()\r\n        self.prevPoint = point\r\n        if not self.boundedMoveShapes(shapes, point - offset):\r\n            self.boundedMoveShapes(shapes, point + offset)\r\n\r\n    def paintEvent(self, event):\r\n        if not self.pixmap:\r\n            return super(Canvas, self).paintEvent(event)\r\n\r\n"}
{"image_path": "data\\train\\00372.png", "code": "        p = self._painter\r\n        p.begin(self)\r\n        p.setRenderHint(QtGui.QPainter.Antialiasing)\r\n        p.setRenderHint(QtGui.QPainter.HighQualityAntialiasing)\r\n        p.setRenderHint(QtGui.QPainter.SmoothPixmapTransform)\r\n\r\n        p.scale(self.scale, self.scale)\r\n        p.translate(self.offsetToCenter())\r\n\r\n        p.drawPixmap(0, 0, self.pixmap)\r\n\r\n        # draw crosshair\r\n        if (\r\n            self._crosshair[self._createMode]\r\n            and self.drawing()\r\n            and self.prevMovePoint\r\n            and not self.outOfPixmap(self.prevMovePoint)\r\n        ):\r\n            p.setPen(QtGui.QColor(0, 0, 0))\r\n            p.drawLine(\r\n                0,\r\n                int(self.prevMovePoint.y()),\r\n                self.width() - 1,\r\n                int(self.prevMovePoint.y()),\r\n            )\r\n            p.drawLine(\r\n                int(self.prevMovePoint.x()),\r\n                0,\r\n                int(self.prevMovePoint.x()),\r\n                self.height() - 1,\r\n            )\r\n\r\n        Shape.scale = self.scale\r\n        for shape in self.shapes:\r\n            if (shape.selected or not self._hideBackround) and self.isVisible(shape):\r\n                shape.fill = shape.selected or shape == self.hShape\r\n                shape.paint(p)\r\n        if self.current:\r\n            self.current.paint(p)\r\n            assert len(self.line.points) == len(self.line.point_labels)\r\n"}
{"image_path": "data\\train\\00373.png", "code": "            self.line.paint(p)\r\n        if self.selectedShapesCopy:\r\n            for s in self.selectedShapesCopy:\r\n                s.paint(p)\r\n\r\n        if (\r\n            self.fillDrawing()\r\n            and self.createMode == \"polygon\"\r\n            and self.current is not None\r\n            and len(self.current.points) >= 2\r\n        ):\r\n            drawing_shape = self.current.copy()\r\n            if drawing_shape.fill_color.getRgb()[3] == 0:\r\n                logger.warning(\r\n                    \"fill_drawing=true, but fill_color is transparent,\"\r\n                    \" so forcing to be opaque.\"\r\n                )\r\n                drawing_shape.fill_color.setAlpha(64)\r\n            drawing_shape.addPoint(self.line[1])\r\n            drawing_shape.fill = True\r\n            drawing_shape.paint(p)\r\n        elif self.createMode == \"ai_polygon\" and self.current is not None:\r\n            drawing_shape = self.current.copy()\r\n            drawing_shape.addPoint(\r\n                point=self.line.points[1],\r\n                label=self.line.point_labels[1],\r\n            )\r\n            points = self._ai_model.predict_polygon_from_points(\r\n                points=[[point.x(), point.y()] for point in drawing_shape.points],\r\n                point_labels=drawing_shape.point_labels,\r\n            )\r\n            if len(points) > 2:\r\n                drawing_shape.setShapeRefined(\r\n                    shape_type=\"polygon\",\r\n                    points=[QtCore.QPointF(point[0], point[1]) for point in points],\r\n                    point_labels=[1] * len(points),\r\n                )\r\n                drawing_shape.fill = self.fillDrawing()\r\n                drawing_shape.selected = True\r\n                drawing_shape.paint(p)\r\n"}
{"image_path": "data\\train\\00374.png", "code": "        elif self.createMode == \"ai_mask\" and self.current is not None:\r\n            drawing_shape = self.current.copy()\r\n            drawing_shape.addPoint(\r\n                point=self.line.points[1],\r\n                label=self.line.point_labels[1],\r\n            )\r\n            mask = self._ai_model.predict_mask_from_points(\r\n                points=[[point.x(), point.y()] for point in drawing_shape.points],\r\n                point_labels=drawing_shape.point_labels,\r\n            )\r\n            y1, x1, y2, x2 = imgviz.instances.masks_to_bboxes([mask])[0].astype(int)\r\n            drawing_shape.setShapeRefined(\r\n                shape_type=\"mask\",\r\n                points=[QtCore.QPointF(x1, y1), QtCore.QPointF(x2, y2)],\r\n                point_labels=[1, 1],\r\n                mask=mask[y1 : y2 + 1, x1 : x2 + 1],\r\n            )\r\n            drawing_shape.selected = True\r\n            drawing_shape.paint(p)\r\n\r\n        p.end()\r\n\r\n    def transformPos(self, point):\r\n        \"\"\"Convert from widget-logical coordinates to painter-logical ones.\"\"\"\r\n        return point / self.scale - self.offsetToCenter()\r\n\r\n    def offsetToCenter(self):\r\n        s = self.scale\r\n        area = super(Canvas, self).size()\r\n        w, h = self.pixmap.width() * s, self.pixmap.height() * s\r\n        aw, ah = area.width(), area.height()\r\n        x = (aw - w) / (2 * s) if aw > w else 0\r\n        y = (ah - h) / (2 * s) if ah > h else 0\r\n        return QtCore.QPointF(x, y)\r\n\r\n    def outOfPixmap(self, p):\r\n        w, h = self.pixmap.width(), self.pixmap.height()\r\n        return not (0 <= p.x() <= w - 1 and 0 <= p.y() <= h - 1)\r\n\r\n    def finalise(self):\r\n"}
{"image_path": "data\\train\\00375.png", "code": "        assert self.current\r\n        if self.createMode == \"ai_polygon\":\r\n            # convert points to polygon by an AI model\r\n            assert self.current.shape_type == \"points\"\r\n            points = self._ai_model.predict_polygon_from_points(\r\n                points=[[point.x(), point.y()] for point in self.current.points],\r\n                point_labels=self.current.point_labels,\r\n            )\r\n            self.current.setShapeRefined(\r\n                points=[QtCore.QPointF(point[0], point[1]) for point in points],\r\n                point_labels=[1] * len(points),\r\n                shape_type=\"polygon\",\r\n            )\r\n        elif self.createMode == \"ai_mask\":\r\n            # convert points to mask by an AI model\r\n            assert self.current.shape_type == \"points\"\r\n            mask = self._ai_model.predict_mask_from_points(\r\n                points=[[point.x(), point.y()] for point in self.current.points],\r\n                point_labels=self.current.point_labels,\r\n            )\r\n            y1, x1, y2, x2 = imgviz.instances.masks_to_bboxes([mask])[0].astype(int)\r\n            self.current.setShapeRefined(\r\n                shape_type=\"mask\",\r\n                points=[QtCore.QPointF(x1, y1), QtCore.QPointF(x2, y2)],\r\n                point_labels=[1, 1],\r\n                mask=mask[y1 : y2 + 1, x1 : x2 + 1],\r\n            )\r\n        self.current.close()\r\n\r\n        self.shapes.append(self.current)\r\n        self.storeShapes()\r\n        self.current = None\r\n        self.setHiding(False)\r\n        self.newShape.emit()\r\n        self.update()\r\n\r\n    def closeEnough(self, p1, p2):\r\n        # d = distance(p1 - p2)\r\n        # m = (p1-p2).manhattanLength()\r\n        # print \"d %.2f, m %d, %.2f\" % (d, m, d - m)\r\n"}
{"image_path": "data\\train\\00376.png", "code": "        # divide by scale to allow more precision when zoomed in\r\n        return labelme.utils.distance(p1 - p2) < (self.epsilon / self.scale)\r\n\r\n    def intersectionPoint(self, p1, p2):\r\n        # Cycle through each image edge in clockwise fashion,\r\n        # and find the one intersecting the current line segment.\r\n        # http://paulbourke.net/geometry/lineline2d/\r\n        size = self.pixmap.size()\r\n        points = [\r\n            (0, 0),\r\n            (size.width() - 1, 0),\r\n            (size.width() - 1, size.height() - 1),\r\n            (0, size.height() - 1),\r\n        ]\r\n        # x1, y1 should be in the pixmap, x2, y2 should be out of the pixmap\r\n        x1 = min(max(p1.x(), 0), size.width() - 1)\r\n        y1 = min(max(p1.y(), 0), size.height() - 1)\r\n        x2, y2 = p2.x(), p2.y()\r\n        d, i, (x, y) = min(self.intersectingEdges((x1, y1), (x2, y2), points))\r\n        x3, y3 = points[i]\r\n        x4, y4 = points[(i + 1) % 4]\r\n        if (x, y) == (x1, y1):\r\n            # Handle cases where previous point is on one of the edges.\r\n            if x3 == x4:\r\n                return QtCore.QPointF(x3, min(max(0, y2), max(y3, y4)))\r\n            else:  # y3 == y4\r\n                return QtCore.QPointF(min(max(0, x2), max(x3, x4)), y3)\r\n        return QtCore.QPointF(x, y)\r\n\r\n    def intersectingEdges(self, point1, point2, points):\r\n        \"\"\"Find intersecting edges.\r\n\r\n        For each edge formed by `points', yield the intersection\r\n        with the line segment `(x1,y1) - (x2,y2)`, if it exists.\r\n        Also return the distance of `(x2,y2)' to the middle of the\r\n        edge along with its index, so that the one closest can be chosen.\r\n        \"\"\"\r\n        (x1, y1) = point1\r\n        (x2, y2) = point2\r\n        for i in range(4):\r\n"}
{"image_path": "data\\train\\00377.png", "code": "            x3, y3 = points[i]\r\n            x4, y4 = points[(i + 1) % 4]\r\n            denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\r\n            nua = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)\r\n            nub = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)\r\n            if denom == 0:\r\n                # This covers two cases:\r\n                #   nua == nub == 0: Coincident\r\n                #   otherwise: Parallel\r\n                continue\r\n            ua, ub = nua / denom, nub / denom\r\n            if 0 <= ua <= 1 and 0 <= ub <= 1:\r\n                x = x1 + ua * (x2 - x1)\r\n                y = y1 + ua * (y2 - y1)\r\n                m = QtCore.QPointF((x3 + x4) / 2, (y3 + y4) / 2)\r\n                d = labelme.utils.distance(m - QtCore.QPointF(x2, y2))\r\n                yield d, i, (x, y)\r\n\r\n    # These two, along with a call to adjustSize are required for the\r\n    # scroll area.\r\n    def sizeHint(self):\r\n        return self.minimumSizeHint()\r\n\r\n    def minimumSizeHint(self):\r\n        if self.pixmap:\r\n            return self.scale * self.pixmap.size()\r\n        return super(Canvas, self).minimumSizeHint()\r\n\r\n    def wheelEvent(self, ev):\r\n        if QT5:\r\n            mods = ev.modifiers()\r\n            delta = ev.angleDelta()\r\n            if QtCore.Qt.ControlModifier == int(mods):\r\n                # with Ctrl/Command key\r\n                # zoom\r\n                self.zoomRequest.emit(delta.y(), ev.pos())\r\n            else:\r\n                # scroll\r\n                self.scrollRequest.emit(delta.x(), QtCore.Qt.Horizontal)\r\n                self.scrollRequest.emit(delta.y(), QtCore.Qt.Vertical)\r\n"}
{"image_path": "data\\train\\00378.png", "code": "        else:\r\n            if ev.orientation() == QtCore.Qt.Vertical:\r\n                mods = ev.modifiers()\r\n                if QtCore.Qt.ControlModifier == int(mods):\r\n                    # with Ctrl/Command key\r\n                    self.zoomRequest.emit(ev.delta(), ev.pos())\r\n                else:\r\n                    self.scrollRequest.emit(\r\n                        ev.delta(),\r\n                        QtCore.Qt.Horizontal\r\n                        if (QtCore.Qt.ShiftModifier == int(mods))\r\n                        else QtCore.Qt.Vertical,\r\n                    )\r\n            else:\r\n                self.scrollRequest.emit(ev.delta(), QtCore.Qt.Horizontal)\r\n        ev.accept()\r\n\r\n    def moveByKeyboard(self, offset):\r\n        if self.selectedShapes:\r\n            self.boundedMoveShapes(self.selectedShapes, self.prevPoint + offset)\r\n            self.repaint()\r\n            self.movingShape = True\r\n\r\n    def keyPressEvent(self, ev):\r\n        modifiers = ev.modifiers()\r\n        key = ev.key()\r\n        if self.drawing():\r\n            if key == QtCore.Qt.Key_Escape and self.current:\r\n                self.current = None\r\n                self.drawingPolygon.emit(False)\r\n                self.update()\r\n            elif key == QtCore.Qt.Key_Return and self.canCloseShape():\r\n                self.finalise()\r\n            elif modifiers == QtCore.Qt.AltModifier:\r\n                self.snapping = False\r\n        elif self.editing():\r\n            if key == QtCore.Qt.Key_Up:\r\n                self.moveByKeyboard(QtCore.QPointF(0.0, -MOVE_SPEED))\r\n            elif key == QtCore.Qt.Key_Down:\r\n                self.moveByKeyboard(QtCore.QPointF(0.0, MOVE_SPEED))\r\n"}
{"image_path": "data\\train\\00379.png", "code": "            elif key == QtCore.Qt.Key_Left:\r\n                self.moveByKeyboard(QtCore.QPointF(-MOVE_SPEED, 0.0))\r\n            elif key == QtCore.Qt.Key_Right:\r\n                self.moveByKeyboard(QtCore.QPointF(MOVE_SPEED, 0.0))\r\n\r\n    def keyReleaseEvent(self, ev):\r\n        modifiers = ev.modifiers()\r\n        if self.drawing():\r\n            if int(modifiers) == 0:\r\n                self.snapping = True\r\n        elif self.editing():\r\n            if self.movingShape and self.selectedShapes:\r\n                index = self.shapes.index(self.selectedShapes[0])\r\n                if self.shapesBackups[-1][index].points != self.shapes[index].points:\r\n                    self.storeShapes()\r\n                    self.shapeMoved.emit()\r\n\r\n                self.movingShape = False\r\n\r\n    def setLastLabel(self, text, flags):\r\n        assert text\r\n        self.shapes[-1].label = text\r\n        self.shapes[-1].flags = flags\r\n        self.shapesBackups.pop()\r\n        self.storeShapes()\r\n        return self.shapes[-1]\r\n\r\n    def undoLastLine(self):\r\n        assert self.shapes\r\n        self.current = self.shapes.pop()\r\n        self.current.setOpen()\r\n        self.current.restoreShapeRaw()\r\n        if self.createMode in [\"polygon\", \"linestrip\"]:\r\n            self.line.points = [self.current[-1], self.current[0]]\r\n        elif self.createMode in [\"rectangle\", \"line\", \"circle\"]:\r\n            self.current.points = self.current.points[0:1]\r\n        elif self.createMode == \"point\":\r\n            self.current = None\r\n        self.drawingPolygon.emit(True)\r\n\r\n"}
{"image_path": "data\\train\\00380.png", "code": "    def undoLastPoint(self):\r\n        if not self.current or self.current.isClosed():\r\n            return\r\n        self.current.popPoint()\r\n        if len(self.current) > 0:\r\n            self.line[0] = self.current[-1]\r\n        else:\r\n            self.current = None\r\n            self.drawingPolygon.emit(False)\r\n        self.update()\r\n\r\n    def loadPixmap(self, pixmap, clear_shapes=True):\r\n        self.pixmap = pixmap\r\n        if self._ai_model:\r\n            self._ai_model.set_image(\r\n                image=labelme.utils.img_qt_to_arr(self.pixmap.toImage())\r\n            )\r\n        if clear_shapes:\r\n            self.shapes = []\r\n        self.update()\r\n\r\n    def loadShapes(self, shapes, replace=True):\r\n        if replace:\r\n            self.shapes = list(shapes)\r\n        else:\r\n            self.shapes.extend(shapes)\r\n        self.storeShapes()\r\n        self.current = None\r\n        self.hShape = None\r\n        self.hVertex = None\r\n        self.hEdge = None\r\n        self.update()\r\n\r\n    def setShapeVisible(self, shape, value):\r\n        self.visible[shape] = value\r\n        self.update()\r\n\r\n    def overrideCursor(self, cursor):\r\n        self.restoreCursor()\r\n        self._cursor = cursor\r\n"}
{"image_path": "data\\train\\00381.png", "code": "        QtWidgets.QApplication.setOverrideCursor(cursor)\r\n\r\n    def restoreCursor(self):\r\n        QtWidgets.QApplication.restoreOverrideCursor()\r\n\r\n    def resetState(self):\r\n        self.restoreCursor()\r\n        self.pixmap = None\r\n        self.shapesBackups = []\r\n        self.update()\r\n"}
{"image_path": "data\\train\\00382.png", "code": "import json\r\n\r\nfrom qtpy import QtCore\r\nfrom qtpy import QtGui\r\nfrom qtpy import QtWidgets\r\n\r\n\r\nclass ScrollAreaPreview(QtWidgets.QScrollArea):\r\n    def __init__(self, *args, **kwargs):\r\n        super(ScrollAreaPreview, self).__init__(*args, **kwargs)\r\n\r\n        self.setWidgetResizable(True)\r\n\r\n        content = QtWidgets.QWidget(self)\r\n        self.setWidget(content)\r\n\r\n        lay = QtWidgets.QVBoxLayout(content)\r\n\r\n        self.label = QtWidgets.QLabel(content)\r\n        self.label.setWordWrap(True)\r\n\r\n        lay.addWidget(self.label)\r\n\r\n    def setText(self, text):\r\n        self.label.setText(text)\r\n\r\n    def setPixmap(self, pixmap):\r\n        self.label.setPixmap(pixmap)\r\n\r\n    def clear(self):\r\n        self.label.clear()\r\n\r\n\r\nclass FileDialogPreview(QtWidgets.QFileDialog):\r\n    def __init__(self, *args, **kwargs):\r\n        super(FileDialogPreview, self).__init__(*args, **kwargs)\r\n        self.setOption(self.DontUseNativeDialog, True)\r\n\r\n        self.labelPreview = ScrollAreaPreview(self)\r\n        self.labelPreview.setFixedSize(300, 300)\r\n"}
{"image_path": "data\\train\\00383.png", "code": "        self.labelPreview.setHidden(True)\r\n\r\n        box = QtWidgets.QVBoxLayout()\r\n        box.addWidget(self.labelPreview)\r\n        box.addStretch()\r\n\r\n        self.setFixedSize(self.width() + 300, self.height())\r\n        self.layout().addLayout(box, 1, 3, 1, 1)\r\n        self.currentChanged.connect(self.onChange)\r\n\r\n    def onChange(self, path):\r\n        if path.lower().endswith(\".json\"):\r\n            with open(path, \"r\") as f:\r\n                data = json.load(f)\r\n                self.labelPreview.setText(json.dumps(data, indent=4, sort_keys=False))\r\n            self.labelPreview.label.setAlignment(\r\n                QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop\r\n            )\r\n            self.labelPreview.setHidden(False)\r\n        else:\r\n            pixmap = QtGui.QPixmap(path)\r\n            if pixmap.isNull():\r\n                self.labelPreview.clear()\r\n                self.labelPreview.setHidden(True)\r\n            else:\r\n                self.labelPreview.setPixmap(\r\n                    pixmap.scaled(\r\n                        self.labelPreview.width() - 30,\r\n                        self.labelPreview.height() - 30,\r\n                        QtCore.Qt.KeepAspectRatio,\r\n                        QtCore.Qt.SmoothTransformation,\r\n                    )\r\n                )\r\n                self.labelPreview.label.setAlignment(QtCore.Qt.AlignCenter)\r\n                self.labelPreview.setHidden(False)\r\n"}
{"image_path": "data\\train\\00384.png", "code": "from qtpy import QtCore\r\nfrom qtpy import QtGui\r\nfrom qtpy import QtWidgets\r\n\r\n\r\nclass ZoomWidget(QtWidgets.QSpinBox):\r\n    def __init__(self, value=100):\r\n        super(ZoomWidget, self).__init__()\r\n        self.setButtonSymbols(QtWidgets.QAbstractSpinBox.NoButtons)\r\n        self.setRange(1, 1000)\r\n        self.setSuffix(\" %\")\r\n        self.setValue(value)\r\n        self.setToolTip(\"Zoom Level\")\r\n        self.setStatusTip(self.toolTip())\r\n        self.setAlignment(QtCore.Qt.AlignCenter)\r\n\r\n    def minimumSizeHint(self):\r\n        height = super(ZoomWidget, self).minimumSizeHint().height()\r\n        fm = QtGui.QFontMetrics(self.font())\r\n        width = fm.width(str(self.maximum()))\r\n        return QtCore.QSize(width, height)\r\n"}
{"image_path": "data\\train\\00385.png", "code": "import PIL.Image\r\nimport PIL.ImageEnhance\r\nfrom qtpy import QtGui\r\nfrom qtpy import QtWidgets\r\nfrom qtpy.QtCore import Qt\r\n\r\nfrom .. import utils\r\n\r\n\r\nclass BrightnessContrastDialog(QtWidgets.QDialog):\r\n    def __init__(self, img, callback, parent=None):\r\n        super(BrightnessContrastDialog, self).__init__(parent)\r\n        self.setModal(True)\r\n        self.setWindowTitle(\"Brightness/Contrast\")\r\n\r\n        self.slider_brightness = self._create_slider()\r\n        self.slider_contrast = self._create_slider()\r\n\r\n        formLayout = QtWidgets.QFormLayout()\r\n        formLayout.addRow(self.tr(\"Brightness\"), self.slider_brightness)\r\n        formLayout.addRow(self.tr(\"Contrast\"), self.slider_contrast)\r\n        self.setLayout(formLayout)\r\n\r\n        assert isinstance(img, PIL.Image.Image)\r\n        self.img = img\r\n        self.callback = callback\r\n\r\n    def onNewValue(self, value):\r\n        brightness = self.slider_brightness.value() / 50.0\r\n        contrast = self.slider_contrast.value() / 50.0\r\n\r\n        img = self.img\r\n        img = PIL.ImageEnhance.Brightness(img).enhance(brightness)\r\n        img = PIL.ImageEnhance.Contrast(img).enhance(contrast)\r\n\r\n        img_data = utils.img_pil_to_data(img)\r\n        qimage = QtGui.QImage.fromData(img_data)\r\n        self.callback(qimage)\r\n\r\n    def _create_slider(self):\r\n"}
{"image_path": "data\\train\\00386.png", "code": "        slider = QtWidgets.QSlider(Qt.Horizontal)\r\n        slider.setRange(0, 150)\r\n        slider.setValue(50)\r\n        slider.valueChanged.connect(self.onNewValue)\r\n        return slider\r\n"}
{"image_path": "data\\train\\00387.png", "code": "from qtpy import QtCore\r\nfrom qtpy import QtGui\r\nfrom qtpy import QtWidgets\r\nfrom qtpy.QtCore import Qt\r\nfrom qtpy.QtGui import QPalette\r\nfrom qtpy.QtWidgets import QStyle\r\n\r\n\r\n# https://stackoverflow.com/a/2039745/4158863\r\nclass HTMLDelegate(QtWidgets.QStyledItemDelegate):\r\n    def __init__(self, parent=None):\r\n        super(HTMLDelegate, self).__init__()\r\n        self.doc = QtGui.QTextDocument(self)\r\n\r\n    def paint(self, painter, option, index):\r\n        painter.save()\r\n\r\n        options = QtWidgets.QStyleOptionViewItem(option)\r\n\r\n        self.initStyleOption(options, index)\r\n        self.doc.setHtml(options.text)\r\n        options.text = \"\"\r\n\r\n        style = (\r\n            QtWidgets.QApplication.style()\r\n            if options.widget is None\r\n            else options.widget.style()\r\n        )\r\n        style.drawControl(QStyle.CE_ItemViewItem, options, painter)\r\n\r\n        ctx = QtGui.QAbstractTextDocumentLayout.PaintContext()\r\n\r\n        if option.state & QStyle.State_Selected:\r\n            ctx.palette.setColor(\r\n                QPalette.Text,\r\n                option.palette.color(QPalette.Active, QPalette.HighlightedText),\r\n            )\r\n        else:\r\n            ctx.palette.setColor(\r\n                QPalette.Text,\r\n"}
{"image_path": "data\\train\\00388.png", "code": "                option.palette.color(QPalette.Active, QPalette.Text),\r\n            )\r\n\r\n        textRect = style.subElementRect(QStyle.SE_ItemViewItemText, options)\r\n\r\n        if index.column() != 0:\r\n            textRect.adjust(5, 0, 0, 0)\r\n\r\n        thefuckyourshitup_constant = 4\r\n        margin = (option.rect.height() - options.fontMetrics.height()) // 2\r\n        margin = margin - thefuckyourshitup_constant\r\n        textRect.setTop(textRect.top() + margin)\r\n\r\n        painter.translate(textRect.topLeft())\r\n        painter.setClipRect(textRect.translated(-textRect.topLeft()))\r\n        self.doc.documentLayout().draw(painter, ctx)\r\n\r\n        painter.restore()\r\n\r\n    def sizeHint(self, option, index):\r\n        thefuckyourshitup_constant = 4\r\n        return QtCore.QSize(\r\n            int(self.doc.idealWidth()),\r\n            int(self.doc.size().height() - thefuckyourshitup_constant),\r\n        )\r\n\r\n\r\nclass LabelListWidgetItem(QtGui.QStandardItem):\r\n    def __init__(self, text=None, shape=None):\r\n        super(LabelListWidgetItem, self).__init__()\r\n        self.setText(text or \"\")\r\n        self.setShape(shape)\r\n\r\n        self.setCheckable(True)\r\n        self.setCheckState(Qt.Checked)\r\n        self.setEditable(False)\r\n        self.setTextAlignment(Qt.AlignBottom)\r\n\r\n    def clone(self):\r\n        return LabelListWidgetItem(self.text(), self.shape())\r\n"}
{"image_path": "data\\train\\00389.png", "code": "\r\n    def setShape(self, shape):\r\n        self.setData(shape, Qt.UserRole)\r\n\r\n    def shape(self):\r\n        return self.data(Qt.UserRole)\r\n\r\n    def __hash__(self):\r\n        return id(self)\r\n\r\n    def __repr__(self):\r\n        return '{}(\"{}\")'.format(self.__class__.__name__, self.text())\r\n\r\n\r\nclass StandardItemModel(QtGui.QStandardItemModel):\r\n    itemDropped = QtCore.Signal()\r\n\r\n    def removeRows(self, *args, **kwargs):\r\n        ret = super().removeRows(*args, **kwargs)\r\n        self.itemDropped.emit()\r\n        return ret\r\n\r\n\r\nclass LabelListWidget(QtWidgets.QListView):\r\n    itemDoubleClicked = QtCore.Signal(LabelListWidgetItem)\r\n    itemSelectionChanged = QtCore.Signal(list, list)\r\n\r\n    def __init__(self):\r\n        super(LabelListWidget, self).__init__()\r\n        self._selectedItems = []\r\n\r\n        self.setWindowFlags(Qt.Window)\r\n        self.setModel(StandardItemModel())\r\n        self.model().setItemPrototype(LabelListWidgetItem())\r\n        self.setItemDelegate(HTMLDelegate())\r\n        self.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)\r\n        self.setDragDropMode(QtWidgets.QAbstractItemView.InternalMove)\r\n        self.setDefaultDropAction(Qt.MoveAction)\r\n\r\n        self.doubleClicked.connect(self.itemDoubleClickedEvent)\r\n"}
{"image_path": "data\\train\\00390.png", "code": "        self.selectionModel().selectionChanged.connect(self.itemSelectionChangedEvent)\r\n\r\n    def __len__(self):\r\n        return self.model().rowCount()\r\n\r\n    def __getitem__(self, i):\r\n        return self.model().item(i)\r\n\r\n    def __iter__(self):\r\n        for i in range(len(self)):\r\n            yield self[i]\r\n\r\n    @property\r\n    def itemDropped(self):\r\n        return self.model().itemDropped\r\n\r\n    @property\r\n    def itemChanged(self):\r\n        return self.model().itemChanged\r\n\r\n    def itemSelectionChangedEvent(self, selected, deselected):\r\n        selected = [self.model().itemFromIndex(i) for i in selected.indexes()]\r\n        deselected = [self.model().itemFromIndex(i) for i in deselected.indexes()]\r\n        self.itemSelectionChanged.emit(selected, deselected)\r\n\r\n    def itemDoubleClickedEvent(self, index):\r\n        self.itemDoubleClicked.emit(self.model().itemFromIndex(index))\r\n\r\n    def selectedItems(self):\r\n        return [self.model().itemFromIndex(i) for i in self.selectedIndexes()]\r\n\r\n    def scrollToItem(self, item):\r\n        self.scrollTo(self.model().indexFromItem(item))\r\n\r\n    def addItem(self, item):\r\n        if not isinstance(item, LabelListWidgetItem):\r\n            raise TypeError(\"item must be LabelListWidgetItem\")\r\n        self.model().setItem(self.model().rowCount(), 0, item)\r\n        item.setSizeHint(self.itemDelegate().sizeHint(None, None))\r\n\r\n"}
{"image_path": "data\\train\\00391.png", "code": "    def removeItem(self, item):\r\n        index = self.model().indexFromItem(item)\r\n        self.model().removeRows(index.row(), 1)\r\n\r\n    def selectItem(self, item):\r\n        index = self.model().indexFromItem(item)\r\n        self.selectionModel().select(index, QtCore.QItemSelectionModel.Select)\r\n\r\n    def findItemByShape(self, shape):\r\n        for row in range(self.model().rowCount()):\r\n            item = self.model().item(row, 0)\r\n            if item.shape() == shape:\r\n                return item\r\n        raise ValueError(\"cannot find shape: {}\".format(shape))\r\n\r\n    def clear(self):\r\n        self.model().clear()\r\n"}
{"image_path": "data\\train\\00392.png", "code": "from qtpy import QtWidgets\r\n\r\n\r\nclass ColorDialog(QtWidgets.QColorDialog):\r\n    def __init__(self, parent=None):\r\n        super(ColorDialog, self).__init__(parent)\r\n        self.setOption(QtWidgets.QColorDialog.ShowAlphaChannel)\r\n        # The Mac native dialog does not support our restore button.\r\n        self.setOption(QtWidgets.QColorDialog.DontUseNativeDialog)\r\n        # Add a restore defaults button.\r\n        # The default is set at invocation time, so that it\r\n        # works across dialogs for different elements.\r\n        self.default = None\r\n        self.bb = self.layout().itemAt(1).widget()\r\n        self.bb.addButton(QtWidgets.QDialogButtonBox.RestoreDefaults)\r\n        self.bb.clicked.connect(self.checkRestore)\r\n\r\n    def getColor(self, value=None, title=None, default=None):\r\n        self.default = default\r\n        if title:\r\n            self.setWindowTitle(title)\r\n        if value:\r\n            self.setCurrentColor(value)\r\n        return self.currentColor() if self.exec_() else None\r\n\r\n    def checkRestore(self, button):\r\n        if (\r\n            self.bb.buttonRole(button) & QtWidgets.QDialogButtonBox.ResetRole\r\n            and self.default\r\n        ):\r\n            self.setCurrentColor(self.default)\r\n"}
{"image_path": "data\\train\\00393.png", "code": "#!/usr/bin/env python\r\n\r\nfrom __future__ import print_function\r\n\r\nimport argparse\r\nimport distutils.spawn\r\nimport json\r\nimport os\r\nimport os.path as osp\r\nimport platform\r\nimport shlex\r\nimport subprocess\r\nimport sys\r\n\r\n\r\ndef get_ip():\r\n    dist = platform.platform().split(\"-\")[0]\r\n    if dist == \"Linux\":\r\n        return \"\"\r\n    elif dist == \"Darwin\":\r\n        cmd = \"ifconfig en0\"\r\n        output = subprocess.check_output(shlex.split(cmd))\r\n        if str != bytes:  # Python3\r\n            output = output.decode(\"utf-8\")\r\n        for row in output.splitlines():\r\n            cols = row.strip().split(\" \")\r\n            if cols[0] == \"inet\":\r\n                ip = cols[1]\r\n                return ip\r\n        else:\r\n            raise RuntimeError(\"No ip is found.\")\r\n    else:\r\n        raise RuntimeError(\"Unsupported platform.\")\r\n\r\n\r\ndef labelme_on_docker(in_file, out_file):\r\n    ip = get_ip()\r\n    cmd = \"xhost + %s\" % ip\r\n    subprocess.check_output(shlex.split(cmd))\r\n\r\n"}
{"image_path": "data\\train\\00394.png", "code": "    if out_file:\r\n        out_file = osp.abspath(out_file)\r\n        if osp.exists(out_file):\r\n            raise RuntimeError(\"File exists: %s\" % out_file)\r\n        else:\r\n            open(osp.abspath(out_file), \"w\")\r\n\r\n    cmd = (\r\n        \"docker run -it --rm\"\r\n        \" -e DISPLAY={0}:0\"\r\n        \" -e QT_X11_NO_MITSHM=1\"\r\n        \" -v /tmp/.X11-unix:/tmp/.X11-unix\"\r\n        \" -v {1}:{2}\"\r\n        \" -w /home/developer\"\r\n    )\r\n    in_file_a = osp.abspath(in_file)\r\n    in_file_b = osp.join(\"/home/developer\", osp.basename(in_file))\r\n    cmd = cmd.format(\r\n        ip,\r\n        in_file_a,\r\n        in_file_b,\r\n    )\r\n    if out_file:\r\n        out_file_a = osp.abspath(out_file)\r\n        out_file_b = osp.join(\"/home/developer\", osp.basename(out_file))\r\n        cmd += \" -v {0}:{1}\".format(out_file_a, out_file_b)\r\n    cmd += \" wkentaro/labelme labelme {0}\".format(in_file_b)\r\n    if out_file:\r\n        cmd += \" -O {0}\".format(out_file_b)\r\n    subprocess.call(shlex.split(cmd))\r\n\r\n    if out_file:\r\n        try:\r\n            json.load(open(out_file))\r\n            return out_file\r\n        except Exception:\r\n            if open(out_file).read() == \"\":\r\n                os.remove(out_file)\r\n            raise RuntimeError(\"Annotation is cancelled.\")\r\n\r\n"}
{"image_path": "data\\train\\00395.png", "code": "\r\ndef main():\r\n    parser = argparse.ArgumentParser()\r\n    parser.add_argument(\"in_file\", help=\"Input file or directory.\")\r\n    parser.add_argument(\"-O\", \"--output\")\r\n    args = parser.parse_args()\r\n\r\n    if not distutils.spawn.find_executable(\"docker\"):\r\n        print(\"Please install docker\", file=sys.stderr)\r\n        sys.exit(1)\r\n\r\n    try:\r\n        out_file = labelme_on_docker(args.in_file, args.output)\r\n        if out_file:\r\n            print(\"Saved to: %s\" % out_file)\r\n    except RuntimeError as e:\r\n        sys.stderr.write(e.__str__() + \"\\n\")\r\n        sys.exit(1)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"}
{"image_path": "data\\train\\00396.png", "code": "import argparse\r\nimport base64\r\nimport json\r\nimport os\r\nimport os.path as osp\r\n\r\nimport imgviz\r\nimport PIL.Image\r\n\r\nfrom labelme import utils\r\nfrom labelme.logger import logger\r\n\r\n\r\ndef main():\r\n    logger.warning(\r\n        \"DEPRECATED: This script will be removed in the near future. \"\r\n        \"Please use `labelme_export_json` instead.\"\r\n    )\r\n    logger.warning(\r\n        \"NOTE: This script is aimed to demonstrate how to convert a JSON file \"\r\n        \"to a single image dataset. so it won't handle multiple JSON files to \"\r\n        \"generate a real-use dataset.\"\r\n    )\r\n\r\n    parser = argparse.ArgumentParser()\r\n    parser.add_argument(\"json_file\")\r\n    parser.add_argument(\"-o\", \"--out\", default=None)\r\n    args = parser.parse_args()\r\n\r\n    json_file = args.json_file\r\n\r\n    if args.out is None:\r\n        out_dir = osp.basename(json_file).replace(\".\", \"_\")\r\n        out_dir = osp.join(osp.dirname(json_file), out_dir)\r\n    else:\r\n        out_dir = args.out\r\n    if not osp.exists(out_dir):\r\n        os.mkdir(out_dir)\r\n\r\n    data = json.load(open(json_file))\r\n"}
{"image_path": "data\\train\\00397.png", "code": "    imageData = data.get(\"imageData\")\r\n\r\n    if not imageData:\r\n        imagePath = os.path.join(os.path.dirname(json_file), data[\"imagePath\"])\r\n        with open(imagePath, \"rb\") as f:\r\n            imageData = f.read()\r\n            imageData = base64.b64encode(imageData).decode(\"utf-8\")\r\n    img = utils.img_b64_to_arr(imageData)\r\n\r\n    label_name_to_value = {\"_background_\": 0}\r\n    for shape in sorted(data[\"shapes\"], key=lambda x: x[\"label\"]):\r\n        label_name = shape[\"label\"]\r\n        if label_name in label_name_to_value:\r\n            label_value = label_name_to_value[label_name]\r\n        else:\r\n            label_value = len(label_name_to_value)\r\n            label_name_to_value[label_name] = label_value\r\n    lbl, _ = utils.shapes_to_label(img.shape, data[\"shapes\"], label_name_to_value)\r\n\r\n    label_names = [None] * (max(label_name_to_value.values()) + 1)\r\n    for name, value in label_name_to_value.items():\r\n        label_names[value] = name\r\n\r\n    lbl_viz = imgviz.label2rgb(\r\n        lbl, imgviz.asgray(img), label_names=label_names, loc=\"rb\"\r\n    )\r\n\r\n    PIL.Image.fromarray(img).save(osp.join(out_dir, \"img.png\"))\r\n    utils.lblsave(osp.join(out_dir, \"label.png\"), lbl)\r\n    PIL.Image.fromarray(lbl_viz).save(osp.join(out_dir, \"label_viz.png\"))\r\n\r\n    with open(osp.join(out_dir, \"label_names.txt\"), \"w\") as f:\r\n        for lbl_name in label_names:\r\n            f.write(lbl_name + \"\\n\")\r\n\r\n    logger.info(\"Saved to: {}\".format(out_dir))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"}
{"image_path": "data\\train\\00398.png", "code": "#!/usr/bin/env python\r\n\r\nimport argparse\r\nimport sys\r\n\r\nimport imgviz\r\nimport matplotlib.pyplot as plt\r\n\r\nfrom labelme import utils\r\nfrom labelme.label_file import LabelFile\r\n\r\nPY2 = sys.version_info[0] == 2\r\n\r\n\r\ndef main():\r\n    parser = argparse.ArgumentParser()\r\n    parser.add_argument(\"json_file\")\r\n    args = parser.parse_args()\r\n\r\n    label_file = LabelFile(args.json_file)\r\n    img = utils.img_data_to_arr(label_file.imageData)\r\n\r\n    label_name_to_value = {\"_background_\": 0}\r\n    for shape in sorted(label_file.shapes, key=lambda x: x[\"label\"]):\r\n        label_name = shape[\"label\"]\r\n        if label_name in label_name_to_value:\r\n            label_value = label_name_to_value[label_name]\r\n        else:\r\n            label_value = len(label_name_to_value)\r\n            label_name_to_value[label_name] = label_value\r\n    lbl, _ = utils.shapes_to_label(img.shape, label_file.shapes, label_name_to_value)\r\n\r\n    label_names = [None] * (max(label_name_to_value.values()) + 1)\r\n    for name, value in label_name_to_value.items():\r\n        label_names[value] = name\r\n    lbl_viz = imgviz.label2rgb(\r\n        lbl,\r\n        imgviz.asgray(img),\r\n        label_names=label_names,\r\n        font_size=30,\r\n"}
{"image_path": "data\\train\\00399.png", "code": "        loc=\"rb\",\r\n    )\r\n\r\n    plt.subplot(121)\r\n    plt.imshow(img)\r\n    plt.subplot(122)\r\n    plt.imshow(lbl_viz)\r\n    plt.show()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"}
{"image_path": "data\\train\\00400.png", "code": "# flake8: noqa\r\n\r\nfrom . import draw_json\r\nfrom . import draw_label_png\r\nfrom . import export_json\r\nfrom . import on_docker\r\n"}
{"image_path": "data\\train\\00401.png", "code": "import argparse\r\nimport os\r\n\r\nimport imgviz\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\n\r\nfrom labelme.logger import logger\r\n\r\n\r\ndef main():\r\n    parser = argparse.ArgumentParser(\r\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\r\n    )\r\n    parser.add_argument(\"label_png\", help=\"label PNG file\")\r\n    parser.add_argument(\r\n        \"--labels\",\r\n        help=\"labels list (comma separated text or file)\",\r\n        default=None,\r\n    )\r\n    parser.add_argument(\"--image\", help=\"image file\", default=None)\r\n    args = parser.parse_args()\r\n\r\n    if args.labels is not None:\r\n        if os.path.exists(args.labels):\r\n            with open(args.labels) as f:\r\n                label_names = [label.strip() for label in f]\r\n        else:\r\n            label_names = args.labels.split(\",\")\r\n    else:\r\n        label_names = None\r\n\r\n    if args.image is not None:\r\n        image = imgviz.io.imread(args.image)\r\n    else:\r\n        image = None\r\n\r\n    label = imgviz.io.imread(args.label_png)\r\n    label = label.astype(np.int32)\r\n    label[label == 255] = -1\r\n"}
{"image_path": "data\\train\\00402.png", "code": "\r\n    unique_label_values = np.unique(label)\r\n\r\n    logger.info(\"Label image shape: {}\".format(label.shape))\r\n    logger.info(\"Label values: {}\".format(unique_label_values.tolist()))\r\n    if label_names is not None:\r\n        logger.info(\r\n            \"Label names: {}\".format(\r\n                [\r\n                    \"{}:{}\".format(label_value, label_names[label_value])\r\n                    for label_value in unique_label_values\r\n                ]\r\n            )\r\n        )\r\n\r\n    if args.image:\r\n        num_cols = 2\r\n    else:\r\n        num_cols = 1\r\n\r\n    plt.figure(figsize=(num_cols * 6, 5))\r\n\r\n    plt.subplot(1, num_cols, 1)\r\n    plt.title(args.label_png)\r\n    label_viz = imgviz.label2rgb(\r\n        label=label, label_names=label_names, font_size=label.shape[1] // 30\r\n    )\r\n    plt.imshow(label_viz)\r\n\r\n    if image is not None:\r\n        plt.subplot(1, num_cols, 2)\r\n        label_viz_with_overlay = imgviz.label2rgb(\r\n            label=label,\r\n            image=image,\r\n            label_names=label_names,\r\n            font_size=label.shape[1] // 30,\r\n        )\r\n        plt.title(\"{}\\n{}\".format(args.label_png, args.image))\r\n        plt.imshow(label_viz_with_overlay)\r\n\r\n"}
{"image_path": "data\\train\\00403.png", "code": "    plt.tight_layout()\r\n    plt.show()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"}
{"image_path": "data\\train\\00404.png", "code": "import argparse\r\nimport base64\r\nimport json\r\nimport os\r\nimport os.path as osp\r\n\r\nimport imgviz\r\nimport PIL.Image\r\n\r\nfrom labelme import utils\r\nfrom labelme.logger import logger\r\n\r\n\r\ndef main():\r\n    parser = argparse.ArgumentParser()\r\n    parser.add_argument(\"json_file\")\r\n    parser.add_argument(\"-o\", \"--out\", default=None)\r\n    args = parser.parse_args()\r\n\r\n    json_file = args.json_file\r\n\r\n    if args.out is None:\r\n        out_dir = osp.splitext(osp.basename(json_file))[0]\r\n        out_dir = osp.join(osp.dirname(json_file), out_dir)\r\n    else:\r\n        out_dir = args.out\r\n    if not osp.exists(out_dir):\r\n        os.mkdir(out_dir)\r\n\r\n    data = json.load(open(json_file))\r\n    imageData = data.get(\"imageData\")\r\n\r\n    if not imageData:\r\n        imagePath = os.path.join(os.path.dirname(json_file), data[\"imagePath\"])\r\n        with open(imagePath, \"rb\") as f:\r\n            imageData = f.read()\r\n            imageData = base64.b64encode(imageData).decode(\"utf-8\")\r\n    img = utils.img_b64_to_arr(imageData)\r\n\r\n    label_name_to_value = {\"_background_\": 0}\r\n"}
{"image_path": "data\\train\\00405.png", "code": "    for shape in sorted(data[\"shapes\"], key=lambda x: x[\"label\"]):\r\n        label_name = shape[\"label\"]\r\n        if label_name in label_name_to_value:\r\n            label_value = label_name_to_value[label_name]\r\n        else:\r\n            label_value = len(label_name_to_value)\r\n            label_name_to_value[label_name] = label_value\r\n    lbl, _ = utils.shapes_to_label(img.shape, data[\"shapes\"], label_name_to_value)\r\n\r\n    label_names = [None] * (max(label_name_to_value.values()) + 1)\r\n    for name, value in label_name_to_value.items():\r\n        label_names[value] = name\r\n\r\n    lbl_viz = imgviz.label2rgb(\r\n        lbl, imgviz.asgray(img), label_names=label_names, loc=\"rb\"\r\n    )\r\n\r\n    PIL.Image.fromarray(img).save(osp.join(out_dir, \"img.png\"))\r\n    utils.lblsave(osp.join(out_dir, \"label.png\"), lbl)\r\n    PIL.Image.fromarray(lbl_viz).save(osp.join(out_dir, \"label_viz.png\"))\r\n\r\n    with open(osp.join(out_dir, \"label_names.txt\"), \"w\") as f:\r\n        for lbl_name in label_names:\r\n            f.write(lbl_name + \"\\n\")\r\n\r\n    logger.info(\"Saved to: {}\".format(out_dir))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"}
{"image_path": "data\\train\\00406.png", "code": "# MIT License\r\n# Copyright (c) Kentaro Wada\r\n\r\nimport os.path as osp\r\n\r\nimport numpy as np\r\nimport PIL.Image\r\n\r\n\r\ndef lblsave(filename, lbl):\r\n    import imgviz\r\n\r\n    if osp.splitext(filename)[1] != \".png\":\r\n        filename += \".png\"\r\n    # Assume label ranses [-1, 254] for int32,\r\n    # and [0, 255] for uint8 as VOC.\r\n    if lbl.min() >= -1 and lbl.max() < 255:\r\n        lbl_pil = PIL.Image.fromarray(lbl.astype(np.uint8), mode=\"P\")\r\n        colormap = imgviz.label_colormap()\r\n        lbl_pil.putpalette(colormap.flatten())\r\n        lbl_pil.save(filename)\r\n    else:\r\n        raise ValueError(\r\n            \"[%s] Cannot save the pixel-wise class label as PNG. \"\r\n            \"Please consider using the .npy format.\" % filename\r\n        )\r\n"}
{"image_path": "data\\train\\00407.png", "code": "# flake8: noqa\r\n\r\nfrom ._io import lblsave\r\n\r\nfrom .image import apply_exif_orientation\r\nfrom .image import img_arr_to_b64\r\nfrom .image import img_arr_to_data\r\nfrom .image import img_b64_to_arr\r\nfrom .image import img_data_to_arr\r\nfrom .image import img_data_to_pil\r\nfrom .image import img_data_to_png_data\r\nfrom .image import img_pil_to_data\r\nfrom .image import img_qt_to_arr\r\n\r\nfrom .shape import labelme_shapes_to_label\r\nfrom .shape import masks_to_bboxes\r\nfrom .shape import polygons_to_mask\r\nfrom .shape import shape_to_mask\r\nfrom .shape import shapes_to_label\r\n\r\nfrom .qt import newIcon\r\nfrom .qt import newButton\r\nfrom .qt import newAction\r\nfrom .qt import addActions\r\nfrom .qt import labelValidator\r\nfrom .qt import struct\r\nfrom .qt import distance\r\nfrom .qt import distancetoline\r\nfrom .qt import fmtShortcut\r\n"}
{"image_path": "data\\train\\00408.png", "code": "# MIT License\r\n# Copyright (c) Kentaro Wada\r\n\r\nimport math\r\nimport uuid\r\n\r\nimport numpy as np\r\nimport PIL.Image\r\nimport PIL.ImageDraw\r\n\r\nfrom labelme.logger import logger\r\n\r\n\r\ndef polygons_to_mask(img_shape, polygons, shape_type=None):\r\n    logger.warning(\r\n        \"The 'polygons_to_mask' function is deprecated, \" \"use 'shape_to_mask' instead.\"\r\n    )\r\n    return shape_to_mask(img_shape, points=polygons, shape_type=shape_type)\r\n\r\n\r\ndef shape_to_mask(img_shape, points, shape_type=None, line_width=10, point_size=5):\r\n    mask = np.zeros(img_shape[:2], dtype=np.uint8)\r\n    mask = PIL.Image.fromarray(mask)\r\n    draw = PIL.ImageDraw.Draw(mask)\r\n    xy = [tuple(point) for point in points]\r\n    if shape_type == \"circle\":\r\n        assert len(xy) == 2, \"Shape of shape_type=circle must have 2 points\"\r\n        (cx, cy), (px, py) = xy\r\n        d = math.sqrt((cx - px) ** 2 + (cy - py) ** 2)\r\n        draw.ellipse([cx - d, cy - d, cx + d, cy + d], outline=1, fill=1)\r\n    elif shape_type == \"rectangle\":\r\n        assert len(xy) == 2, \"Shape of shape_type=rectangle must have 2 points\"\r\n        draw.rectangle(xy, outline=1, fill=1)\r\n    elif shape_type == \"line\":\r\n        assert len(xy) == 2, \"Shape of shape_type=line must have 2 points\"\r\n        draw.line(xy=xy, fill=1, width=line_width)\r\n    elif shape_type == \"linestrip\":\r\n        draw.line(xy=xy, fill=1, width=line_width)\r\n    elif shape_type == \"point\":\r\n        assert len(xy) == 1, \"Shape of shape_type=point must have 1 points\"\r\n"}
{"image_path": "data\\train\\00409.png", "code": "        cx, cy = xy[0]\r\n        r = point_size\r\n        draw.ellipse([cx - r, cy - r, cx + r, cy + r], outline=1, fill=1)\r\n    else:\r\n        assert len(xy) > 2, \"Polygon must have points more than 2\"\r\n        draw.polygon(xy=xy, outline=1, fill=1)\r\n    mask = np.array(mask, dtype=bool)\r\n    return mask\r\n\r\n\r\ndef shapes_to_label(img_shape, shapes, label_name_to_value):\r\n    cls = np.zeros(img_shape[:2], dtype=np.int32)\r\n    ins = np.zeros_like(cls)\r\n    instances = []\r\n    for shape in shapes:\r\n        points = shape[\"points\"]\r\n        label = shape[\"label\"]\r\n        group_id = shape.get(\"group_id\")\r\n        if group_id is None:\r\n            group_id = uuid.uuid1()\r\n        shape_type = shape.get(\"shape_type\", None)\r\n\r\n        cls_name = label\r\n        instance = (cls_name, group_id)\r\n\r\n        if instance not in instances:\r\n            instances.append(instance)\r\n        ins_id = instances.index(instance) + 1\r\n        cls_id = label_name_to_value[cls_name]\r\n\r\n        mask = shape_to_mask(img_shape[:2], points, shape_type)\r\n        cls[mask] = cls_id\r\n        ins[mask] = ins_id\r\n\r\n    return cls, ins\r\n\r\n\r\ndef labelme_shapes_to_label(img_shape, shapes):\r\n    logger.warn(\r\n        \"labelme_shapes_to_label is deprecated, so please use \" \"shapes_to_label.\"\r\n"}
{"image_path": "data\\train\\00410.png", "code": "    )\r\n\r\n    label_name_to_value = {\"_background_\": 0}\r\n    for shape in shapes:\r\n        label_name = shape[\"label\"]\r\n        if label_name in label_name_to_value:\r\n            label_value = label_name_to_value[label_name]\r\n        else:\r\n            label_value = len(label_name_to_value)\r\n            label_name_to_value[label_name] = label_value\r\n\r\n    lbl, _ = shapes_to_label(img_shape, shapes, label_name_to_value)\r\n    return lbl, label_name_to_value\r\n\r\n\r\ndef masks_to_bboxes(masks):\r\n    if masks.ndim != 3:\r\n        raise ValueError(\"masks.ndim must be 3, but it is {}\".format(masks.ndim))\r\n    if masks.dtype != bool:\r\n        raise ValueError(\r\n            \"masks.dtype must be bool type, but it is {}\".format(masks.dtype)\r\n        )\r\n    bboxes = []\r\n    for mask in masks:\r\n        where = np.argwhere(mask)\r\n        (y1, x1), (y2, x2) = where.min(0), where.max(0) + 1\r\n        bboxes.append((y1, x1, y2, x2))\r\n    bboxes = np.asarray(bboxes, dtype=np.float32)\r\n    return bboxes\r\n"}
{"image_path": "data\\train\\00411.png", "code": "# MIT License\r\n# Copyright (c) Kentaro Wada\r\n\r\nimport base64\r\nimport io\r\n\r\nimport numpy as np\r\nimport PIL.ExifTags\r\nimport PIL.Image\r\nimport PIL.ImageOps\r\n\r\n\r\ndef img_data_to_pil(img_data):\r\n    f = io.BytesIO()\r\n    f.write(img_data)\r\n    img_pil = PIL.Image.open(f)\r\n    return img_pil\r\n\r\n\r\ndef img_data_to_arr(img_data):\r\n    img_pil = img_data_to_pil(img_data)\r\n    img_arr = np.array(img_pil)\r\n    return img_arr\r\n\r\n\r\ndef img_b64_to_arr(img_b64):\r\n    img_data = base64.b64decode(img_b64)\r\n    img_arr = img_data_to_arr(img_data)\r\n    return img_arr\r\n\r\n\r\ndef img_pil_to_data(img_pil):\r\n    f = io.BytesIO()\r\n    img_pil.save(f, format=\"PNG\")\r\n    img_data = f.getvalue()\r\n    return img_data\r\n\r\n\r\ndef img_arr_to_b64(img_arr):\r\n    img_data = img_arr_to_data(img_arr)\r\n"}
{"image_path": "data\\train\\00412.png", "code": "    img_b64 = base64.b64encode(img_data).decode(\"utf-8\")\r\n    return img_b64\r\n\r\n\r\ndef img_arr_to_data(img_arr):\r\n    img_pil = PIL.Image.fromarray(img_arr)\r\n    img_data = img_pil_to_data(img_pil)\r\n    return img_data\r\n\r\n\r\ndef img_data_to_png_data(img_data):\r\n    with io.BytesIO() as f:\r\n        f.write(img_data)\r\n        img = PIL.Image.open(f)\r\n\r\n        with io.BytesIO() as f:\r\n            img.save(f, \"PNG\")\r\n            f.seek(0)\r\n            return f.read()\r\n\r\n\r\ndef img_qt_to_arr(img_qt):\r\n    w, h, d = img_qt.size().width(), img_qt.size().height(), img_qt.depth()\r\n    bytes_ = img_qt.bits().asstring(w * h * d // 8)\r\n    img_arr = np.frombuffer(bytes_, dtype=np.uint8).reshape((h, w, d // 8))\r\n    return img_arr\r\n\r\n\r\ndef apply_exif_orientation(image):\r\n    try:\r\n        exif = image._getexif()\r\n    except AttributeError:\r\n        exif = None\r\n\r\n    if exif is None:\r\n        return image\r\n\r\n    exif = {PIL.ExifTags.TAGS[k]: v for k, v in exif.items() if k in PIL.ExifTags.TAGS}\r\n\r\n    orientation = exif.get(\"Orientation\", None)\r\n"}
{"image_path": "data\\train\\00413.png", "code": "\r\n    if orientation == 1:\r\n        # do nothing\r\n        return image\r\n    elif orientation == 2:\r\n        # left-to-right mirror\r\n        return PIL.ImageOps.mirror(image)\r\n    elif orientation == 3:\r\n        # rotate 180\r\n        return image.transpose(PIL.Image.ROTATE_180)\r\n    elif orientation == 4:\r\n        # top-to-bottom mirror\r\n        return PIL.ImageOps.flip(image)\r\n    elif orientation == 5:\r\n        # top-to-left mirror\r\n        return PIL.ImageOps.mirror(image.transpose(PIL.Image.ROTATE_270))\r\n    elif orientation == 6:\r\n        # rotate 270\r\n        return image.transpose(PIL.Image.ROTATE_270)\r\n    elif orientation == 7:\r\n        # top-to-right mirror\r\n        return PIL.ImageOps.mirror(image.transpose(PIL.Image.ROTATE_90))\r\n    elif orientation == 8:\r\n        # rotate 90\r\n        return image.transpose(PIL.Image.ROTATE_90)\r\n    else:\r\n        return image\r\n"}
{"image_path": "data\\train\\00414.png", "code": "import os.path as osp\r\nfrom math import sqrt\r\n\r\nimport numpy as np\r\nfrom qtpy import QtCore\r\nfrom qtpy import QtGui\r\nfrom qtpy import QtWidgets\r\n\r\nhere = osp.dirname(osp.abspath(__file__))\r\n\r\n\r\ndef newIcon(icon):\r\n    icons_dir = osp.join(here, \"../icons\")\r\n    return QtGui.QIcon(osp.join(\":/\", icons_dir, \"%s.png\" % icon))\r\n\r\n\r\ndef newButton(text, icon=None, slot=None):\r\n    b = QtWidgets.QPushButton(text)\r\n    if icon is not None:\r\n        b.setIcon(newIcon(icon))\r\n    if slot is not None:\r\n        b.clicked.connect(slot)\r\n    return b\r\n\r\n\r\ndef newAction(\r\n    parent,\r\n    text,\r\n    slot=None,\r\n    shortcut=None,\r\n    icon=None,\r\n    tip=None,\r\n    checkable=False,\r\n    enabled=True,\r\n    checked=False,\r\n):\r\n    \"\"\"Create a new action and assign callbacks, shortcuts, etc.\"\"\"\r\n    a = QtWidgets.QAction(text, parent)\r\n    if icon is not None:\r\n        a.setIconText(text.replace(\" \", \"\\n\"))\r\n"}
{"image_path": "data\\train\\00415.png", "code": "        a.setIcon(newIcon(icon))\r\n    if shortcut is not None:\r\n        if isinstance(shortcut, (list, tuple)):\r\n            a.setShortcuts(shortcut)\r\n        else:\r\n            a.setShortcut(shortcut)\r\n    if tip is not None:\r\n        a.setToolTip(tip)\r\n        a.setStatusTip(tip)\r\n    if slot is not None:\r\n        a.triggered.connect(slot)\r\n    if checkable:\r\n        a.setCheckable(True)\r\n    a.setEnabled(enabled)\r\n    a.setChecked(checked)\r\n    return a\r\n\r\n\r\ndef addActions(widget, actions):\r\n    for action in actions:\r\n        if action is None:\r\n            widget.addSeparator()\r\n        elif isinstance(action, QtWidgets.QMenu):\r\n            widget.addMenu(action)\r\n        else:\r\n            widget.addAction(action)\r\n\r\n\r\ndef labelValidator():\r\n    return QtGui.QRegExpValidator(QtCore.QRegExp(r\"^[^ \\t].+\"), None)\r\n\r\n\r\nclass struct(object):\r\n    def __init__(self, **kwargs):\r\n        self.__dict__.update(kwargs)\r\n\r\n\r\ndef distance(p):\r\n    return sqrt(p.x() * p.x() + p.y() * p.y())\r\n\r\n"}
{"image_path": "data\\train\\00416.png", "code": "\r\ndef distancetoline(point, line):\r\n    p1, p2 = line\r\n    p1 = np.array([p1.x(), p1.y()])\r\n    p2 = np.array([p2.x(), p2.y()])\r\n    p3 = np.array([point.x(), point.y()])\r\n    if np.dot((p3 - p1), (p2 - p1)) < 0:\r\n        return np.linalg.norm(p3 - p1)\r\n    if np.dot((p3 - p2), (p1 - p2)) < 0:\r\n        return np.linalg.norm(p3 - p2)\r\n    if np.linalg.norm(p2 - p1) == 0:\r\n        return np.linalg.norm(p3 - p1)\r\n    return np.linalg.norm(np.cross(p2 - p1, p1 - p3)) / np.linalg.norm(p2 - p1)\r\n\r\n\r\ndef fmtShortcut(text):\r\n    mod, key = text.split(\"+\", 1)\r\n    return \"<b>%s</b>+<b>%s</b>\" % (mod, key)\r\n"}
{"image_path": "data\\train\\00417.png", "code": "import os.path as osp\r\nimport shutil\r\nimport tempfile\r\n\r\nimport pytest\r\n\r\nimport labelme.app\r\nimport labelme.config\r\nimport labelme.testing\r\n\r\nhere = osp.dirname(osp.abspath(__file__))\r\ndata_dir = osp.join(here, \"data\")\r\n\r\n\r\ndef _win_show_and_wait_imageData(qtbot, win):\r\n    win.show()\r\n\r\n    def check_imageData():\r\n        assert hasattr(win, \"imageData\")\r\n        assert win.imageData is not None\r\n\r\n    qtbot.waitUntil(check_imageData)  # wait for loadFile\r\n\r\n\r\n@pytest.mark.gui\r\ndef test_MainWindow_open(qtbot):\r\n    win = labelme.app.MainWindow()\r\n    qtbot.addWidget(win)\r\n    win.show()\r\n    win.close()\r\n\r\n\r\n@pytest.mark.gui\r\ndef test_MainWindow_open_img(qtbot):\r\n    img_file = osp.join(data_dir, \"raw/2011_000003.jpg\")\r\n    win = labelme.app.MainWindow(filename=img_file)\r\n    qtbot.addWidget(win)\r\n    _win_show_and_wait_imageData(qtbot, win)\r\n    win.close()\r\n\r\n"}
{"image_path": "data\\train\\00418.png", "code": "\r\n@pytest.mark.gui\r\ndef test_MainWindow_open_json(qtbot):\r\n    json_files = [\r\n        osp.join(data_dir, \"annotated_with_data/apc2016_obj3.json\"),\r\n        osp.join(data_dir, \"annotated/2011_000003.json\"),\r\n    ]\r\n    for json_file in json_files:\r\n        labelme.testing.assert_labelfile_sanity(json_file)\r\n\r\n        win = labelme.app.MainWindow(filename=json_file)\r\n        qtbot.addWidget(win)\r\n        _win_show_and_wait_imageData(qtbot, win)\r\n        win.close()\r\n\r\n\r\ndef create_MainWindow_with_directory(qtbot):\r\n    directory = osp.join(data_dir, \"raw\")\r\n    win = labelme.app.MainWindow(filename=directory)\r\n    qtbot.addWidget(win)\r\n    _win_show_and_wait_imageData(qtbot, win)\r\n    return win\r\n\r\n\r\n@pytest.mark.gui\r\ndef test_MainWindow_openNextImg(qtbot):\r\n    win = create_MainWindow_with_directory(qtbot)\r\n    win.openNextImg()\r\n\r\n\r\n@pytest.mark.gui\r\ndef test_MainWindow_openPrevImg(qtbot):\r\n    win = create_MainWindow_with_directory(qtbot)\r\n    win.openNextImg()\r\n\r\n\r\n@pytest.mark.gui\r\ndef test_MainWindow_annotate_jpg(qtbot):\r\n    tmp_dir = tempfile.mkdtemp()\r\n    input_file = osp.join(data_dir, \"raw/2011_000003.jpg\")\r\n"}
{"image_path": "data\\train\\00419.png", "code": "    out_file = osp.join(tmp_dir, \"2011_000003.json\")\r\n\r\n    config = labelme.config.get_default_config()\r\n    win = labelme.app.MainWindow(\r\n        config=config,\r\n        filename=input_file,\r\n        output_file=out_file,\r\n    )\r\n    qtbot.addWidget(win)\r\n    _win_show_and_wait_imageData(qtbot, win)\r\n\r\n    label = \"whole\"\r\n    points = [\r\n        (100, 100),\r\n        (100, 238),\r\n        (400, 238),\r\n        (400, 100),\r\n    ]\r\n    shapes = [\r\n        dict(\r\n            label=label,\r\n            group_id=None,\r\n            points=points,\r\n            shape_type=\"polygon\",\r\n            mask=None,\r\n            flags={},\r\n            other_data={},\r\n        )\r\n    ]\r\n    win.loadLabels(shapes)\r\n    win.saveFile()\r\n\r\n    labelme.testing.assert_labelfile_sanity(out_file)\r\n    shutil.rmtree(tmp_dir)\r\n"}
{"image_path": "data\\train\\00420.png", "code": "#!/usr/bin/env python\r\n\r\nimport argparse\r\nimport collections\r\nimport datetime\r\nimport glob\r\nimport json\r\nimport os\r\nimport os.path as osp\r\nimport sys\r\nimport uuid\r\n\r\nimport imgviz\r\nimport numpy as np\r\n\r\nimport labelme\r\n\r\ntry:\r\n    import pycocotools.mask\r\nexcept ImportError:\r\n    print(\"Please install pycocotools:\\n\\n    pip install pycocotools\\n\")\r\n    sys.exit(1)\r\n\r\n\r\ndef main():\r\n    parser = argparse.ArgumentParser(\r\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\r\n    )\r\n    parser.add_argument(\"input_dir\", help=\"input annotated directory\")\r\n    parser.add_argument(\"output_dir\", help=\"output dataset directory\")\r\n    parser.add_argument(\"--labels\", help=\"labels file\", required=True)\r\n    parser.add_argument(\"--noviz\", help=\"no visualization\", action=\"store_true\")\r\n    args = parser.parse_args()\r\n\r\n    if osp.exists(args.output_dir):\r\n        print(\"Output directory already exists:\", args.output_dir)\r\n        sys.exit(1)\r\n    os.makedirs(args.output_dir)\r\n    os.makedirs(osp.join(args.output_dir, \"JPEGImages\"))\r\n    if not args.noviz:\r\n"}
{"image_path": "data\\train\\00421.png", "code": "        os.makedirs(osp.join(args.output_dir, \"Visualization\"))\r\n    print(\"Creating dataset:\", args.output_dir)\r\n\r\n    now = datetime.datetime.now()\r\n\r\n    data = dict(\r\n        info=dict(\r\n            description=None,\r\n            url=None,\r\n            version=None,\r\n            year=now.year,\r\n            contributor=None,\r\n            date_created=now.strftime(\"%Y-%m-%d %H:%M:%S.%f\"),\r\n        ),\r\n        licenses=[\r\n            dict(\r\n                url=None,\r\n                id=0,\r\n                name=None,\r\n            )\r\n        ],\r\n        images=[\r\n            # license, url, file_name, height, width, date_captured, id\r\n        ],\r\n        type=\"instances\",\r\n        annotations=[\r\n            # segmentation, area, iscrowd, image_id, bbox, category_id, id\r\n        ],\r\n        categories=[\r\n            # supercategory, id, name\r\n        ],\r\n    )\r\n\r\n    class_name_to_id = {}\r\n    for i, line in enumerate(open(args.labels).readlines()):\r\n        class_id = i - 1  # starts with -1\r\n        class_name = line.strip()\r\n        if class_id == -1:\r\n            assert class_name == \"__ignore__\"\r\n            continue\r\n"}
{"image_path": "data\\train\\00422.png", "code": "        class_name_to_id[class_name] = class_id\r\n        data[\"categories\"].append(\r\n            dict(\r\n                supercategory=None,\r\n                id=class_id,\r\n                name=class_name,\r\n            )\r\n        )\r\n\r\n    out_ann_file = osp.join(args.output_dir, \"annotations.json\")\r\n    label_files = glob.glob(osp.join(args.input_dir, \"*.json\"))\r\n    for image_id, filename in enumerate(label_files):\r\n        print(\"Generating dataset from:\", filename)\r\n\r\n        label_file = labelme.LabelFile(filename=filename)\r\n\r\n        base = osp.splitext(osp.basename(filename))[0]\r\n        out_img_file = osp.join(args.output_dir, \"JPEGImages\", base + \".jpg\")\r\n\r\n        img = labelme.utils.img_data_to_arr(label_file.imageData)\r\n        imgviz.io.imsave(out_img_file, img)\r\n        data[\"images\"].append(\r\n            dict(\r\n                license=0,\r\n                url=None,\r\n                file_name=osp.relpath(out_img_file, osp.dirname(out_ann_file)),\r\n                height=img.shape[0],\r\n                width=img.shape[1],\r\n                date_captured=None,\r\n                id=image_id,\r\n            )\r\n        )\r\n\r\n        masks = {}  # for area\r\n        segmentations = collections.defaultdict(list)  # for segmentation\r\n        for shape in label_file.shapes:\r\n            points = shape[\"points\"]\r\n            label = shape[\"label\"]\r\n            group_id = shape.get(\"group_id\")\r\n            shape_type = shape.get(\"shape_type\", \"polygon\")\r\n"}
{"image_path": "data\\train\\00423.png", "code": "            mask = labelme.utils.shape_to_mask(img.shape[:2], points, shape_type)\r\n\r\n            if group_id is None:\r\n                group_id = uuid.uuid1()\r\n\r\n            instance = (label, group_id)\r\n\r\n            if instance in masks:\r\n                masks[instance] = masks[instance] | mask\r\n            else:\r\n                masks[instance] = mask\r\n\r\n            if shape_type == \"rectangle\":\r\n                (x1, y1), (x2, y2) = points\r\n                x1, x2 = sorted([x1, x2])\r\n                y1, y2 = sorted([y1, y2])\r\n                points = [x1, y1, x2, y1, x2, y2, x1, y2]\r\n            if shape_type == \"circle\":\r\n                (x1, y1), (x2, y2) = points\r\n                r = np.linalg.norm([x2 - x1, y2 - y1])\r\n                # r(1-cos(a/2))<x, a=2*pi/N => N>pi/arccos(1-x/r)\r\n                # x: tolerance of the gap between the arc and the line segment\r\n                n_points_circle = max(int(np.pi / np.arccos(1 - 1 / r)), 12)\r\n                i = np.arange(n_points_circle)\r\n                x = x1 + r * np.sin(2 * np.pi / n_points_circle * i)\r\n                y = y1 + r * np.cos(2 * np.pi / n_points_circle * i)\r\n                points = np.stack((x, y), axis=1).flatten().tolist()\r\n            else:\r\n                points = np.asarray(points).flatten().tolist()\r\n\r\n            segmentations[instance].append(points)\r\n        segmentations = dict(segmentations)\r\n\r\n        for instance, mask in masks.items():\r\n            cls_name, group_id = instance\r\n            if cls_name not in class_name_to_id:\r\n                continue\r\n            cls_id = class_name_to_id[cls_name]\r\n\r\n            mask = np.asfortranarray(mask.astype(np.uint8))\r\n"}
{"image_path": "data\\train\\00424.png", "code": "            mask = pycocotools.mask.encode(mask)\r\n            area = float(pycocotools.mask.area(mask))\r\n            bbox = pycocotools.mask.toBbox(mask).flatten().tolist()\r\n\r\n            data[\"annotations\"].append(\r\n                dict(\r\n                    id=len(data[\"annotations\"]),\r\n                    image_id=image_id,\r\n                    category_id=cls_id,\r\n                    segmentation=segmentations[instance],\r\n                    area=area,\r\n                    bbox=bbox,\r\n                    iscrowd=0,\r\n                )\r\n            )\r\n\r\n        if not args.noviz:\r\n            viz = img\r\n            if masks:\r\n                labels, captions, masks = zip(\r\n                    *[\r\n                        (class_name_to_id[cnm], cnm, msk)\r\n                        for (cnm, gid), msk in masks.items()\r\n                        if cnm in class_name_to_id\r\n                    ]\r\n                )\r\n                viz = imgviz.instances2rgb(\r\n                    image=img,\r\n                    labels=labels,\r\n                    masks=masks,\r\n                    captions=captions,\r\n                    font_size=15,\r\n                    line_width=2,\r\n                )\r\n            out_viz_file = osp.join(args.output_dir, \"Visualization\", base + \".jpg\")\r\n            imgviz.io.imsave(out_viz_file, viz)\r\n\r\n    with open(out_ann_file, \"w\") as f:\r\n        json.dump(data, f)\r\n\r\n"}
{"image_path": "data\\train\\00425.png", "code": "\r\nif __name__ == \"__main__\":\r\n    main()\r\n"}
{"image_path": "data\\train\\00426.png", "code": "#!/usr/bin/env python\r\n\r\nfrom __future__ import print_function\r\n\r\nimport argparse\r\nimport glob\r\nimport os\r\nimport os.path as osp\r\nimport sys\r\n\r\nimport imgviz\r\nimport numpy as np\r\n\r\nimport labelme\r\n\r\n\r\ndef main():\r\n    parser = argparse.ArgumentParser(\r\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\r\n    )\r\n    parser.add_argument(\"input_dir\", help=\"Input annotated directory\")\r\n    parser.add_argument(\"output_dir\", help=\"Output dataset directory\")\r\n    parser.add_argument(\r\n        \"--labels\", help=\"Labels file or comma separated text\", required=True\r\n    )\r\n    parser.add_argument(\r\n        \"--noobject\", help=\"Flag not to generate object label\", action=\"store_true\"\r\n    )\r\n    parser.add_argument(\r\n        \"--nonpy\", help=\"Flag not to generate .npy files\", action=\"store_true\"\r\n    )\r\n    parser.add_argument(\r\n        \"--noviz\", help=\"Flag to disable visualization\", action=\"store_true\"\r\n    )\r\n    args = parser.parse_args()\r\n\r\n    if osp.exists(args.output_dir):\r\n        print(\"Output directory already exists:\", args.output_dir)\r\n        sys.exit(1)\r\n    os.makedirs(args.output_dir)\r\n"}
{"image_path": "data\\train\\00427.png", "code": "    os.makedirs(osp.join(args.output_dir, \"JPEGImages\"))\r\n    os.makedirs(osp.join(args.output_dir, \"SegmentationClass\"))\r\n    if not args.nonpy:\r\n        os.makedirs(osp.join(args.output_dir, \"SegmentationClassNpy\"))\r\n    if not args.noviz:\r\n        os.makedirs(osp.join(args.output_dir, \"SegmentationClassVisualization\"))\r\n    if not args.noobject:\r\n        os.makedirs(osp.join(args.output_dir, \"SegmentationObject\"))\r\n        if not args.nonpy:\r\n            os.makedirs(osp.join(args.output_dir, \"SegmentationObjectNpy\"))\r\n        if not args.noviz:\r\n            os.makedirs(osp.join(args.output_dir, \"SegmentationObjectVisualization\"))\r\n    print(\"Creating dataset:\", args.output_dir)\r\n\r\n    if osp.exists(args.labels):\r\n        with open(args.labels) as f:\r\n            labels = [label.strip() for label in f if label]\r\n    else:\r\n        labels = [label.strip() for label in args.labels.split(\",\")]\r\n\r\n    class_names = []\r\n    class_name_to_id = {}\r\n    for i, label in enumerate(labels):\r\n        class_id = i - 1  # starts with -1\r\n        class_name = label.strip()\r\n        class_name_to_id[class_name] = class_id\r\n        if class_id == -1:\r\n            assert class_name == \"__ignore__\"\r\n            continue\r\n        elif class_id == 0:\r\n            assert class_name == \"_background_\"\r\n        class_names.append(class_name)\r\n    class_names = tuple(class_names)\r\n    print(\"class_names:\", class_names)\r\n    out_class_names_file = osp.join(args.output_dir, \"class_names.txt\")\r\n    with open(out_class_names_file, \"w\") as f:\r\n        f.writelines(\"\\n\".join(class_names))\r\n    print(\"Saved class_names:\", out_class_names_file)\r\n\r\n    for filename in sorted(glob.glob(osp.join(args.input_dir, \"*.json\"))):\r\n"}
{"image_path": "data\\train\\00428.png", "code": "        print(\"Generating dataset from:\", filename)\r\n\r\n        label_file = labelme.LabelFile(filename=filename)\r\n\r\n        base = osp.splitext(osp.basename(filename))[0]\r\n        out_img_file = osp.join(args.output_dir, \"JPEGImages\", base + \".jpg\")\r\n        out_clsp_file = osp.join(args.output_dir, \"SegmentationClass\", base + \".png\")\r\n        if not args.nonpy:\r\n            out_cls_file = osp.join(\r\n                args.output_dir, \"SegmentationClassNpy\", base + \".npy\"\r\n            )\r\n        if not args.noviz:\r\n            out_clsv_file = osp.join(\r\n                args.output_dir,\r\n                \"SegmentationClassVisualization\",\r\n                base + \".jpg\",\r\n            )\r\n        if not args.noobject:\r\n            out_insp_file = osp.join(\r\n                args.output_dir, \"SegmentationObject\", base + \".png\"\r\n            )\r\n            if not args.nonpy:\r\n                out_ins_file = osp.join(\r\n                    args.output_dir, \"SegmentationObjectNpy\", base + \".npy\"\r\n                )\r\n            if not args.noviz:\r\n                out_insv_file = osp.join(\r\n                    args.output_dir,\r\n                    \"SegmentationObjectVisualization\",\r\n                    base + \".jpg\",\r\n                )\r\n\r\n        img = labelme.utils.img_data_to_arr(label_file.imageData)\r\n        imgviz.io.imsave(out_img_file, img)\r\n\r\n        cls, ins = labelme.utils.shapes_to_label(\r\n            img_shape=img.shape,\r\n            shapes=label_file.shapes,\r\n            label_name_to_value=class_name_to_id,\r\n        )\r\n"}
{"image_path": "data\\train\\00429.png", "code": "        ins[cls == -1] = 0  # ignore it.\r\n\r\n        # class label\r\n        labelme.utils.lblsave(out_clsp_file, cls)\r\n        if not args.nonpy:\r\n            np.save(out_cls_file, cls)\r\n        if not args.noviz:\r\n            clsv = imgviz.label2rgb(\r\n                cls,\r\n                imgviz.rgb2gray(img),\r\n                label_names=class_names,\r\n                font_size=15,\r\n                loc=\"rb\",\r\n            )\r\n            imgviz.io.imsave(out_clsv_file, clsv)\r\n\r\n        if not args.noobject:\r\n            # instance label\r\n            labelme.utils.lblsave(out_insp_file, ins)\r\n            if not args.nonpy:\r\n                np.save(out_ins_file, ins)\r\n            if not args.noviz:\r\n                instance_ids = np.unique(ins)\r\n                instance_names = [str(i) for i in range(max(instance_ids) + 1)]\r\n                insv = imgviz.label2rgb(\r\n                    ins,\r\n                    imgviz.rgb2gray(img),\r\n                    label_names=instance_names,\r\n                    font_size=15,\r\n                    loc=\"rb\",\r\n                )\r\n                imgviz.io.imsave(out_insv_file, insv)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"}
{"image_path": "data\\train\\00430.png", "code": "#!/usr/bin/env python\r\n\r\nfrom __future__ import print_function\r\n\r\nimport argparse\r\nimport glob\r\nimport os\r\nimport os.path as osp\r\nimport sys\r\n\r\nimport imgviz\r\nimport numpy as np\r\n\r\nimport labelme\r\n\r\n\r\ndef main():\r\n    parser = argparse.ArgumentParser(\r\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\r\n    )\r\n    parser.add_argument(\"input_dir\", help=\"Input annotated directory\")\r\n    parser.add_argument(\"output_dir\", help=\"Output dataset directory\")\r\n    parser.add_argument(\r\n        \"--labels\", help=\"Labels file or comma separated text\", required=True\r\n    )\r\n    parser.add_argument(\r\n        \"--noobject\", help=\"Flag not to generate object label\", action=\"store_true\"\r\n    )\r\n    parser.add_argument(\r\n        \"--nonpy\", help=\"Flag not to generate .npy files\", action=\"store_true\"\r\n    )\r\n    parser.add_argument(\r\n        \"--noviz\", help=\"Flag to disable visualization\", action=\"store_true\"\r\n    )\r\n    args = parser.parse_args()\r\n\r\n    if osp.exists(args.output_dir):\r\n        print(\"Output directory already exists:\", args.output_dir)\r\n        sys.exit(1)\r\n    os.makedirs(args.output_dir)\r\n"}
{"image_path": "data\\train\\00431.png", "code": "    os.makedirs(osp.join(args.output_dir, \"JPEGImages\"))\r\n    os.makedirs(osp.join(args.output_dir, \"SegmentationClass\"))\r\n    if not args.nonpy:\r\n        os.makedirs(osp.join(args.output_dir, \"SegmentationClassNpy\"))\r\n    if not args.noviz:\r\n        os.makedirs(osp.join(args.output_dir, \"SegmentationClassVisualization\"))\r\n    if not args.noobject:\r\n        os.makedirs(osp.join(args.output_dir, \"SegmentationObject\"))\r\n        if not args.nonpy:\r\n            os.makedirs(osp.join(args.output_dir, \"SegmentationObjectNpy\"))\r\n        if not args.noviz:\r\n            os.makedirs(osp.join(args.output_dir, \"SegmentationObjectVisualization\"))\r\n    print(\"Creating dataset:\", args.output_dir)\r\n\r\n    if osp.exists(args.labels):\r\n        with open(args.labels) as f:\r\n            labels = [label.strip() for label in f if label]\r\n    else:\r\n        labels = [label.strip() for label in args.labels.split(\",\")]\r\n\r\n    class_names = []\r\n    class_name_to_id = {}\r\n    for i, label in enumerate(labels):\r\n        class_id = i - 1  # starts with -1\r\n        class_name = label.strip()\r\n        class_name_to_id[class_name] = class_id\r\n        if class_id == -1:\r\n            assert class_name == \"__ignore__\"\r\n            continue\r\n        elif class_id == 0:\r\n            assert class_name == \"_background_\"\r\n        class_names.append(class_name)\r\n    class_names = tuple(class_names)\r\n    print(\"class_names:\", class_names)\r\n    out_class_names_file = osp.join(args.output_dir, \"class_names.txt\")\r\n    with open(out_class_names_file, \"w\") as f:\r\n        f.writelines(\"\\n\".join(class_names))\r\n    print(\"Saved class_names:\", out_class_names_file)\r\n\r\n    for filename in sorted(glob.glob(osp.join(args.input_dir, \"*.json\"))):\r\n"}
{"image_path": "data\\train\\00432.png", "code": "        print(\"Generating dataset from:\", filename)\r\n\r\n        label_file = labelme.LabelFile(filename=filename)\r\n\r\n        base = osp.splitext(osp.basename(filename))[0]\r\n        out_img_file = osp.join(args.output_dir, \"JPEGImages\", base + \".jpg\")\r\n        out_clsp_file = osp.join(args.output_dir, \"SegmentationClass\", base + \".png\")\r\n        if not args.nonpy:\r\n            out_cls_file = osp.join(\r\n                args.output_dir, \"SegmentationClassNpy\", base + \".npy\"\r\n            )\r\n        if not args.noviz:\r\n            out_clsv_file = osp.join(\r\n                args.output_dir,\r\n                \"SegmentationClassVisualization\",\r\n                base + \".jpg\",\r\n            )\r\n        if not args.noobject:\r\n            out_insp_file = osp.join(\r\n                args.output_dir, \"SegmentationObject\", base + \".png\"\r\n            )\r\n            if not args.nonpy:\r\n                out_ins_file = osp.join(\r\n                    args.output_dir, \"SegmentationObjectNpy\", base + \".npy\"\r\n                )\r\n            if not args.noviz:\r\n                out_insv_file = osp.join(\r\n                    args.output_dir,\r\n                    \"SegmentationObjectVisualization\",\r\n                    base + \".jpg\",\r\n                )\r\n\r\n        img = labelme.utils.img_data_to_arr(label_file.imageData)\r\n        imgviz.io.imsave(out_img_file, img)\r\n\r\n        cls, ins = labelme.utils.shapes_to_label(\r\n            img_shape=img.shape,\r\n            shapes=label_file.shapes,\r\n            label_name_to_value=class_name_to_id,\r\n        )\r\n"}
{"image_path": "data\\train\\00433.png", "code": "        ins[cls == -1] = 0  # ignore it.\r\n\r\n        # class label\r\n        labelme.utils.lblsave(out_clsp_file, cls)\r\n        if not args.nonpy:\r\n            np.save(out_cls_file, cls)\r\n        if not args.noviz:\r\n            clsv = imgviz.label2rgb(\r\n                cls,\r\n                imgviz.rgb2gray(img),\r\n                label_names=class_names,\r\n                font_size=15,\r\n                loc=\"rb\",\r\n            )\r\n            imgviz.io.imsave(out_clsv_file, clsv)\r\n\r\n        if not args.noobject:\r\n            # instance label\r\n            labelme.utils.lblsave(out_insp_file, ins)\r\n            if not args.nonpy:\r\n                np.save(out_ins_file, ins)\r\n            if not args.noviz:\r\n                instance_ids = np.unique(ins)\r\n                instance_names = [str(i) for i in range(max(instance_ids) + 1)]\r\n                insv = imgviz.label2rgb(\r\n                    ins,\r\n                    imgviz.rgb2gray(img),\r\n                    label_names=instance_names,\r\n                    font_size=15,\r\n                    loc=\"rb\",\r\n                )\r\n                imgviz.io.imsave(out_insv_file, insv)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"}
{"image_path": "data\\train\\00434.png", "code": "#!/usr/bin/env python\r\n\r\nfrom __future__ import print_function\r\n\r\nimport argparse\r\nimport glob\r\nimport os\r\nimport os.path as osp\r\nimport sys\r\n\r\nimport imgviz\r\nimport numpy as np\r\n\r\nimport labelme\r\n\r\n\r\ndef main():\r\n    parser = argparse.ArgumentParser(\r\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\r\n    )\r\n    parser.add_argument(\"input_dir\", help=\"Input annotated directory\")\r\n    parser.add_argument(\"output_dir\", help=\"Output dataset directory\")\r\n    parser.add_argument(\r\n        \"--labels\", help=\"Labels file or comma separated text\", required=True\r\n    )\r\n    parser.add_argument(\r\n        \"--noobject\", help=\"Flag not to generate object label\", action=\"store_true\"\r\n    )\r\n    parser.add_argument(\r\n        \"--nonpy\", help=\"Flag not to generate .npy files\", action=\"store_true\"\r\n    )\r\n    parser.add_argument(\r\n        \"--noviz\", help=\"Flag to disable visualization\", action=\"store_true\"\r\n    )\r\n    args = parser.parse_args()\r\n\r\n    if osp.exists(args.output_dir):\r\n        print(\"Output directory already exists:\", args.output_dir)\r\n        sys.exit(1)\r\n    os.makedirs(args.output_dir)\r\n"}
{"image_path": "data\\train\\00435.png", "code": "    os.makedirs(osp.join(args.output_dir, \"JPEGImages\"))\r\n    os.makedirs(osp.join(args.output_dir, \"SegmentationClass\"))\r\n    if not args.nonpy:\r\n        os.makedirs(osp.join(args.output_dir, \"SegmentationClassNpy\"))\r\n    if not args.noviz:\r\n        os.makedirs(osp.join(args.output_dir, \"SegmentationClassVisualization\"))\r\n    if not args.noobject:\r\n        os.makedirs(osp.join(args.output_dir, \"SegmentationObject\"))\r\n        if not args.nonpy:\r\n            os.makedirs(osp.join(args.output_dir, \"SegmentationObjectNpy\"))\r\n        if not args.noviz:\r\n            os.makedirs(osp.join(args.output_dir, \"SegmentationObjectVisualization\"))\r\n    print(\"Creating dataset:\", args.output_dir)\r\n\r\n    if osp.exists(args.labels):\r\n        with open(args.labels) as f:\r\n            labels = [label.strip() for label in f if label]\r\n    else:\r\n        labels = [label.strip() for label in args.labels.split(\",\")]\r\n\r\n    class_names = []\r\n    class_name_to_id = {}\r\n    for i, label in enumerate(labels):\r\n        class_id = i - 1  # starts with -1\r\n        class_name = label.strip()\r\n        class_name_to_id[class_name] = class_id\r\n        if class_id == -1:\r\n            assert class_name == \"__ignore__\"\r\n            continue\r\n        elif class_id == 0:\r\n            assert class_name == \"_background_\"\r\n        class_names.append(class_name)\r\n    class_names = tuple(class_names)\r\n    print(\"class_names:\", class_names)\r\n    out_class_names_file = osp.join(args.output_dir, \"class_names.txt\")\r\n    with open(out_class_names_file, \"w\") as f:\r\n        f.writelines(\"\\n\".join(class_names))\r\n    print(\"Saved class_names:\", out_class_names_file)\r\n\r\n    for filename in sorted(glob.glob(osp.join(args.input_dir, \"*.json\"))):\r\n"}
{"image_path": "data\\train\\00436.png", "code": "        print(\"Generating dataset from:\", filename)\r\n\r\n        label_file = labelme.LabelFile(filename=filename)\r\n\r\n        base = osp.splitext(osp.basename(filename))[0]\r\n        out_img_file = osp.join(args.output_dir, \"JPEGImages\", base + \".jpg\")\r\n        out_clsp_file = osp.join(args.output_dir, \"SegmentationClass\", base + \".png\")\r\n        if not args.nonpy:\r\n            out_cls_file = osp.join(\r\n                args.output_dir, \"SegmentationClassNpy\", base + \".npy\"\r\n            )\r\n        if not args.noviz:\r\n            out_clsv_file = osp.join(\r\n                args.output_dir,\r\n                \"SegmentationClassVisualization\",\r\n                base + \".jpg\",\r\n            )\r\n        if not args.noobject:\r\n            out_insp_file = osp.join(\r\n                args.output_dir, \"SegmentationObject\", base + \".png\"\r\n            )\r\n            if not args.nonpy:\r\n                out_ins_file = osp.join(\r\n                    args.output_dir, \"SegmentationObjectNpy\", base + \".npy\"\r\n                )\r\n            if not args.noviz:\r\n                out_insv_file = osp.join(\r\n                    args.output_dir,\r\n                    \"SegmentationObjectVisualization\",\r\n                    base + \".jpg\",\r\n                )\r\n\r\n        img = labelme.utils.img_data_to_arr(label_file.imageData)\r\n        imgviz.io.imsave(out_img_file, img)\r\n\r\n        cls, ins = labelme.utils.shapes_to_label(\r\n            img_shape=img.shape,\r\n            shapes=label_file.shapes,\r\n            label_name_to_value=class_name_to_id,\r\n        )\r\n"}
{"image_path": "data\\train\\00437.png", "code": "        ins[cls == -1] = 0  # ignore it.\r\n\r\n        # class label\r\n        labelme.utils.lblsave(out_clsp_file, cls)\r\n        if not args.nonpy:\r\n            np.save(out_cls_file, cls)\r\n        if not args.noviz:\r\n            clsv = imgviz.label2rgb(\r\n                cls,\r\n                imgviz.rgb2gray(img),\r\n                label_names=class_names,\r\n                font_size=15,\r\n                loc=\"rb\",\r\n            )\r\n            imgviz.io.imsave(out_clsv_file, clsv)\r\n\r\n        if not args.noobject:\r\n            # instance label\r\n            labelme.utils.lblsave(out_insp_file, ins)\r\n            if not args.nonpy:\r\n                np.save(out_ins_file, ins)\r\n            if not args.noviz:\r\n                instance_ids = np.unique(ins)\r\n                instance_names = [str(i) for i in range(max(instance_ids) + 1)]\r\n                insv = imgviz.label2rgb(\r\n                    ins,\r\n                    imgviz.rgb2gray(img),\r\n                    label_names=instance_names,\r\n                    font_size=15,\r\n                    loc=\"rb\",\r\n                )\r\n                imgviz.io.imsave(out_insv_file, insv)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"}
{"image_path": "data\\train\\00438.png", "code": "#!/usr/bin/env python\r\n\r\nfrom __future__ import print_function\r\n\r\nimport os.path as osp\r\n\r\nimport numpy as np\r\nimport PIL.Image\r\n\r\nhere = osp.dirname(osp.abspath(__file__))\r\n\r\n\r\ndef main():\r\n    label_png = osp.join(here, \"apc2016_obj3_json/label.png\")\r\n    print(\"Loading:\", label_png)\r\n    print()\r\n\r\n    lbl = np.asarray(PIL.Image.open(label_png))\r\n    labels = np.unique(lbl)\r\n\r\n    label_names_txt = osp.join(here, \"apc2016_obj3_json/label_names.txt\")\r\n    label_names = [name.strip() for name in open(label_names_txt)]\r\n    print(\"# of labels:\", len(labels))\r\n    print(\"# of label_names:\", len(label_names))\r\n    if len(labels) != len(label_names):\r\n        print(\"Number of unique labels and label_names must be same.\")\r\n        quit(1)\r\n    print()\r\n\r\n    print(\"label: label_name\")\r\n    for label, label_name in zip(labels, label_names):\r\n        print(\"%d: %s\" % (label, label_name))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"}
{"image_path": "data\\train\\00439.png", "code": "#!/usr/bin/env python\r\n\r\nfrom __future__ import print_function\r\n\r\nimport argparse\r\nimport glob\r\nimport os\r\nimport os.path as osp\r\nimport sys\r\n\r\nimport imgviz\r\n\r\nimport labelme\r\n\r\ntry:\r\n    import lxml.builder\r\n    import lxml.etree\r\nexcept ImportError:\r\n    print(\"Please install lxml:\\n\\n    pip install lxml\\n\")\r\n    sys.exit(1)\r\n\r\n\r\ndef main():\r\n    parser = argparse.ArgumentParser(\r\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter\r\n    )\r\n    parser.add_argument(\"input_dir\", help=\"input annotated directory\")\r\n    parser.add_argument(\"output_dir\", help=\"output dataset directory\")\r\n    parser.add_argument(\"--labels\", help=\"labels file\", required=True)\r\n    parser.add_argument(\"--noviz\", help=\"no visualization\", action=\"store_true\")\r\n    args = parser.parse_args()\r\n\r\n    if osp.exists(args.output_dir):\r\n        print(\"Output directory already exists:\", args.output_dir)\r\n        sys.exit(1)\r\n    os.makedirs(args.output_dir)\r\n    os.makedirs(osp.join(args.output_dir, \"JPEGImages\"))\r\n    os.makedirs(osp.join(args.output_dir, \"Annotations\"))\r\n    if not args.noviz:\r\n        os.makedirs(osp.join(args.output_dir, \"AnnotationsVisualization\"))\r\n"}
{"image_path": "data\\train\\00440.png", "code": "    print(\"Creating dataset:\", args.output_dir)\r\n\r\n    class_names = []\r\n    class_name_to_id = {}\r\n    for i, line in enumerate(open(args.labels).readlines()):\r\n        class_id = i - 1  # starts with -1\r\n        class_name = line.strip()\r\n        class_name_to_id[class_name] = class_id\r\n        if class_id == -1:\r\n            assert class_name == \"__ignore__\"\r\n            continue\r\n        elif class_id == 0:\r\n            assert class_name == \"_background_\"\r\n        class_names.append(class_name)\r\n    class_names = tuple(class_names)\r\n    print(\"class_names:\", class_names)\r\n    out_class_names_file = osp.join(args.output_dir, \"class_names.txt\")\r\n    with open(out_class_names_file, \"w\") as f:\r\n        f.writelines(\"\\n\".join(class_names))\r\n    print(\"Saved class_names:\", out_class_names_file)\r\n\r\n    for filename in glob.glob(osp.join(args.input_dir, \"*.json\")):\r\n        print(\"Generating dataset from:\", filename)\r\n\r\n        label_file = labelme.LabelFile(filename=filename)\r\n\r\n        base = osp.splitext(osp.basename(filename))[0]\r\n        out_img_file = osp.join(args.output_dir, \"JPEGImages\", base + \".jpg\")\r\n        out_xml_file = osp.join(args.output_dir, \"Annotations\", base + \".xml\")\r\n        if not args.noviz:\r\n            out_viz_file = osp.join(\r\n                args.output_dir, \"AnnotationsVisualization\", base + \".jpg\"\r\n            )\r\n\r\n        img = labelme.utils.img_data_to_arr(label_file.imageData)\r\n        imgviz.io.imsave(out_img_file, img)\r\n\r\n        maker = lxml.builder.ElementMaker()\r\n        xml = maker.annotation(\r\n            maker.folder(),\r\n"}
{"image_path": "data\\train\\00441.png", "code": "            maker.filename(base + \".jpg\"),\r\n            maker.database(),  # e.g., The VOC2007 Database\r\n            maker.annotation(),  # e.g., Pascal VOC2007\r\n            maker.image(),  # e.g., flickr\r\n            maker.size(\r\n                maker.height(str(img.shape[0])),\r\n                maker.width(str(img.shape[1])),\r\n                maker.depth(str(img.shape[2])),\r\n            ),\r\n            maker.segmented(),\r\n        )\r\n\r\n        bboxes = []\r\n        labels = []\r\n        for shape in label_file.shapes:\r\n            if shape[\"shape_type\"] != \"rectangle\":\r\n                print(\r\n                    \"Skipping shape: label={label}, \" \"shape_type={shape_type}\".format(\r\n                        **shape\r\n                    )\r\n                )\r\n                continue\r\n\r\n            class_name = shape[\"label\"]\r\n            class_id = class_names.index(class_name)\r\n\r\n            (xmin, ymin), (xmax, ymax) = shape[\"points\"]\r\n            # swap if min is larger than max.\r\n            xmin, xmax = sorted([xmin, xmax])\r\n            ymin, ymax = sorted([ymin, ymax])\r\n\r\n            bboxes.append([ymin, xmin, ymax, xmax])\r\n            labels.append(class_id)\r\n\r\n            xml.append(\r\n                maker.object(\r\n                    maker.name(shape[\"label\"]),\r\n                    maker.pose(),\r\n                    maker.truncated(),\r\n                    maker.difficult(),\r\n"}
{"image_path": "data\\train\\00442.png", "code": "                    maker.bndbox(\r\n                        maker.xmin(str(xmin)),\r\n                        maker.ymin(str(ymin)),\r\n                        maker.xmax(str(xmax)),\r\n                        maker.ymax(str(ymax)),\r\n                    ),\r\n                )\r\n            )\r\n\r\n        if not args.noviz:\r\n            captions = [class_names[label] for label in labels]\r\n            viz = imgviz.instances2rgb(\r\n                image=img,\r\n                labels=labels,\r\n                bboxes=bboxes,\r\n                captions=captions,\r\n                font_size=15,\r\n            )\r\n            imgviz.io.imsave(out_viz_file, viz)\r\n\r\n        with open(out_xml_file, \"wb\") as f:\r\n            f.write(lxml.etree.tostring(xml, pretty_print=True))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"}
{"image_path": "data\\train\\00443.png", "code": "import os.path as osp\r\n\r\nimport numpy as np\r\nimport PIL.Image\r\n\r\nfrom labelme.utils import image as image_module\r\n\r\nfrom .util import data_dir\r\nfrom .util import get_img_and_data\r\n\r\n\r\ndef test_img_b64_to_arr():\r\n    img, _ = get_img_and_data()\r\n    assert img.dtype == np.uint8\r\n    assert img.shape == (907, 1210, 3)\r\n\r\n\r\ndef test_img_arr_to_b64():\r\n    img_file = osp.join(data_dir, \"annotated_with_data/apc2016_obj3.jpg\")\r\n    img_arr = np.asarray(PIL.Image.open(img_file))\r\n    img_b64 = image_module.img_arr_to_b64(img_arr)\r\n    img_arr2 = image_module.img_b64_to_arr(img_b64)\r\n    np.testing.assert_allclose(img_arr, img_arr2)\r\n\r\n\r\ndef test_img_data_to_png_data():\r\n    img_file = osp.join(data_dir, \"annotated_with_data/apc2016_obj3.jpg\")\r\n    with open(img_file, \"rb\") as f:\r\n        img_data = f.read()\r\n    png_data = image_module.img_data_to_png_data(img_data)\r\n    assert isinstance(png_data, bytes)\r\n"}
{"image_path": "data\\train\\00444.png", "code": "from labelme.utils import shape as shape_module\r\n\r\nfrom .util import get_img_and_data\r\n\r\n\r\ndef test_shapes_to_label():\r\n    img, data = get_img_and_data()\r\n    label_name_to_value = {}\r\n    for shape in data[\"shapes\"]:\r\n        label_name = shape[\"label\"]\r\n        label_value = len(label_name_to_value)\r\n        label_name_to_value[label_name] = label_value\r\n    cls, _ = shape_module.shapes_to_label(\r\n        img.shape, data[\"shapes\"], label_name_to_value\r\n    )\r\n    assert cls.shape == img.shape[:2]\r\n\r\n\r\ndef test_shape_to_mask():\r\n    img, data = get_img_and_data()\r\n    for shape in data[\"shapes\"]:\r\n        points = shape[\"points\"]\r\n        mask = shape_module.shape_to_mask(img.shape[:2], points)\r\n        assert mask.shape == img.shape[:2]\r\n"}
{"image_path": "data\\train\\00445.png", "code": "import json\r\nimport os.path as osp\r\n\r\nfrom labelme.utils import image as image_module\r\nfrom labelme.utils import shape as shape_module\r\n\r\nhere = osp.dirname(osp.abspath(__file__))\r\ndata_dir = osp.join(here, \"../data\")\r\n\r\n\r\ndef get_img_and_data():\r\n    json_file = osp.join(data_dir, \"annotated_with_data/apc2016_obj3.json\")\r\n    with open(json_file) as f:\r\n        data = json.load(f)\r\n    img_b64 = data[\"imageData\"]\r\n    img = image_module.img_b64_to_arr(img_b64)\r\n    return img, data\r\n\r\n\r\ndef get_img_and_lbl():\r\n    img, data = get_img_and_data()\r\n\r\n    label_name_to_value = {\"__background__\": 0}\r\n    for shape in data[\"shapes\"]:\r\n        label_name = shape[\"label\"]\r\n        label_value = len(label_name_to_value)\r\n        label_name_to_value[label_name] = label_value\r\n\r\n    n_labels = max(label_name_to_value.values()) + 1\r\n    label_names = [None] * n_labels\r\n    for label_name, label_value in label_name_to_value.items():\r\n        label_names[label_value] = label_name\r\n\r\n    lbl, _ = shape_module.shapes_to_label(\r\n        img.shape, data[\"shapes\"], label_name_to_value\r\n    )\r\n    return img, lbl, label_names\r\n"}
{"image_path": "data\\train\\00446.png", "code": "# -*- encoding: utf-8 -*-\r\n\r\nimport pytest\r\n\r\nfrom labelme.widgets import LabelListWidget\r\nfrom labelme.widgets import LabelListWidgetItem\r\n\r\n\r\n@pytest.mark.gui\r\ndef test_LabelListWidget(qtbot):\r\n    widget = LabelListWidget()\r\n\r\n    item = LabelListWidgetItem(text=\"person <font color='red'>\u25cf</fon>\")\r\n    widget.addItem(item)\r\n    item = LabelListWidgetItem(text=\"dog <font color='blue'>\u25cf</fon>\")\r\n    widget.addItem(item)\r\n\r\n    widget.show()\r\n    qtbot.addWidget(widget)\r\n    qtbot.waitExposed(widget)\r\n"}
{"image_path": "data\\train\\00447.png", "code": "import pytest\r\nfrom qtpy import QtCore\r\nfrom qtpy import QtWidgets\r\n\r\nfrom labelme.widgets import LabelDialog\r\nfrom labelme.widgets import LabelQLineEdit\r\n\r\n\r\n@pytest.mark.gui\r\ndef test_LabelQLineEdit(qtbot):\r\n    list_widget = QtWidgets.QListWidget()\r\n    list_widget.addItems([\"cat\", \"dog\", \"person\"])\r\n    widget = LabelQLineEdit()\r\n    widget.setListWidget(list_widget)\r\n    qtbot.addWidget(widget)\r\n\r\n    # key press to navigate in label list\r\n    item = widget.list_widget.findItems(\"cat\", QtCore.Qt.MatchExactly)[0]\r\n    widget.list_widget.setCurrentItem(item)\r\n    assert widget.list_widget.currentItem().text() == \"cat\"\r\n    qtbot.keyPress(widget, QtCore.Qt.Key_Down)\r\n    assert widget.list_widget.currentItem().text() == \"dog\"\r\n\r\n    # key press to enter label\r\n    qtbot.keyPress(widget, QtCore.Qt.Key_P)\r\n    qtbot.keyPress(widget, QtCore.Qt.Key_E)\r\n    qtbot.keyPress(widget, QtCore.Qt.Key_R)\r\n    qtbot.keyPress(widget, QtCore.Qt.Key_S)\r\n    qtbot.keyPress(widget, QtCore.Qt.Key_O)\r\n    qtbot.keyPress(widget, QtCore.Qt.Key_N)\r\n    assert widget.text() == \"person\"\r\n\r\n\r\n@pytest.mark.gui\r\ndef test_LabelDialog_addLabelHistory(qtbot):\r\n    labels = [\"cat\", \"dog\", \"person\"]\r\n    widget = LabelDialog(labels=labels, sort_labels=True)\r\n    qtbot.addWidget(widget)\r\n\r\n    widget.addLabelHistory(\"bicycle\")\r\n"}
{"image_path": "data\\train\\00448.png", "code": "    assert widget.labelList.count() == 4\r\n    widget.addLabelHistory(\"bicycle\")\r\n    assert widget.labelList.count() == 4\r\n    item = widget.labelList.item(0)\r\n    assert item.text() == \"bicycle\"\r\n\r\n\r\n@pytest.mark.gui\r\ndef test_LabelDialog_popUp(qtbot):\r\n    labels = [\"cat\", \"dog\", \"person\"]\r\n    widget = LabelDialog(labels=labels, sort_labels=True)\r\n    qtbot.addWidget(widget)\r\n\r\n    # popUp(text='cat')\r\n\r\n    def interact():\r\n        qtbot.keyClick(widget.edit, QtCore.Qt.Key_P)  # enter 'p' for 'person'  # NOQA\r\n        qtbot.keyClick(widget.edit, QtCore.Qt.Key_Enter)  # NOQA\r\n        qtbot.keyClick(widget.edit, QtCore.Qt.Key_Enter)  # NOQA\r\n\r\n    QtCore.QTimer.singleShot(500, interact)\r\n    label, flags, group_id, description = widget.popUp(\"cat\")\r\n    assert label == \"person\"\r\n    assert flags == {}\r\n    assert group_id is None\r\n    assert description == \"\"\r\n\r\n    # popUp()\r\n\r\n    def interact():\r\n        qtbot.keyClick(widget.edit, QtCore.Qt.Key_Enter)  # NOQA\r\n        qtbot.keyClick(widget.edit, QtCore.Qt.Key_Enter)  # NOQA\r\n\r\n    QtCore.QTimer.singleShot(500, interact)\r\n    label, flags, group_id, description = widget.popUp()\r\n    assert label == \"person\"\r\n    assert flags == {}\r\n    assert group_id is None\r\n    assert description == \"\"\r\n\r\n"}
{"image_path": "data\\train\\00449.png", "code": "    # popUp() + key_Up\r\n\r\n    def interact():\r\n        qtbot.keyClick(widget.edit, QtCore.Qt.Key_Up)  # 'person' -> 'dog'  # NOQA\r\n        qtbot.keyClick(widget.edit, QtCore.Qt.Key_Enter)  # NOQA\r\n        qtbot.keyClick(widget.edit, QtCore.Qt.Key_Enter)  # NOQA\r\n\r\n    QtCore.QTimer.singleShot(500, interact)\r\n    label, flags, group_id, description = widget.popUp()\r\n    assert label == \"dog\"\r\n    assert flags == {}\r\n    assert group_id is None\r\n    assert description == \"\"\r\n"}
{"image_path": "data\\train\\00450.png", "code": "from setuptools import find_packages, setup\r\nfrom pip._vendor import tomli\r\n\r\n# For consistent encoding\r\nfrom codecs import open\r\nfrom os import path\r\n\r\n# The directory containing this file\r\nHERE = path.abspath(path.dirname(__file__))\r\n\r\n# Get the long description from the README file\r\nwith open(path.join(HERE, 'README.md'), encoding='utf-8') as f:\r\n    LONG_DESCRIPTION = f.read()\r\n\r\nwith open('pyproject.toml', 'r') as f:\r\n    VERSION = tomli.load(f)['tool']['commitizen']['version']\r\n\r\nDESCRIPTION = 'A python library for working with Google Drive.'\r\n\r\nkey_words = [\r\n    'drive', 'google-drive', 'google-drive-api', 'upload files to Google Drive',\r\n]\r\n\r\ninstall_requires = [\r\n    'oryks-google-oauth',\r\n    'pydantic',\r\n    'pydantic-settings'\r\n]\r\n\r\nsetup(\r\n    name='oryks-google-drive',\r\n    packages=find_packages(\r\n        include=[\r\n            'google_drive',\r\n            'google_drive.exceptions',\r\n            'google_drive.models',\r\n            'google_drive.schemas',\r\n            'google_drive.resources'\r\n        ]\r\n    ),\r\n"}
{"image_path": "data\\train\\00451.png", "code": "    version=VERSION,\r\n    description=DESCRIPTION,\r\n    long_description_content_type='text/markdown',\r\n    long_description=LONG_DESCRIPTION,\r\n    url='https://youtube-wrapper.readthedocs.io/en/latest/index.html',\r\n    author='Lyle Okoth',\r\n    author_email='lyceokoth@gmail.com',\r\n    license='MIT',\r\n    install_requires=install_requires,\r\n    keywords=key_words,\r\n    classifiers=[\r\n        'Intended Audience :: Developers',\r\n        'License :: OSI Approved :: MIT License',\r\n        'Programming Language :: Python',\r\n        'Programming Language :: Python :: 3',\r\n        'Programming Language :: Python :: 3.11',\r\n        'Programming Language :: Python :: 3.12',\r\n        'Operating System :: OS Independent'\r\n    ],\r\n)\r\n"}
{"image_path": "data\\train\\00452.png", "code": "from google_drive import GoogleDrive\r\n\r\n\r\nclient_secrets_file = 'drive.json'\r\ndrive = GoogleDrive(client_secret_file=client_secrets_file)\r\ndrive.authenticate()\r\n"}
{"image_path": "data\\train\\00453.png", "code": "from dotenv import load_dotenv\r\nload_dotenv()\r\nfrom assistant.agents import default_agent\r\nimport chainlit as cl\r\n\r\n\r\n@cl.on_chat_start\r\nasync def start():\r\n    cl.user_session.set('agent', default_agent)\r\n\r\n\r\n@cl.on_message\r\nasync def main(message: cl.Message):\r\n    agent = cl.user_session.get('agent')\r\n    msg = cl.Message(content='')\r\n    await msg.send()\r\n    await cl.sleep(1)\r\n    msg.content = agent.invoke({'input': message.content})['output']\r\n    await msg.update()\r\n"}
{"image_path": "data\\train\\00454.png", "code": "from setuptools import find_packages, setup\r\nfrom pip._vendor import tomli\r\n\r\n# For consistent encoding\r\nfrom codecs import open\r\nfrom os import path\r\n\r\n# The directory containing this file\r\nHERE = path.abspath(path.dirname(__file__))\r\n\r\n# Get the long description from the README file\r\nwith open(path.join(HERE, 'README.md'), encoding='utf-8') as f:\r\n    LONG_DESCRIPTION = f.read()\r\n\r\nwith open('pyproject.toml', 'r') as f:\r\n    VERSION = tomli.load(f)['tool']['commitizen']['version']\r\n\r\nDESCRIPTION = 'A chatbot that enables the user interact with youtube over chat.'\r\n\r\nkey_words = [\r\n    'youtube', 'youtube-api', 'youtube comments', 'youtube videos', 'chat with youtube',\r\n    'youtube channels', 'youtube comment thread', 'create youtube playlist'\r\n]\r\n\r\ninstall_requires = [\r\n    'oryks-youtube',\r\n    'pydantic',\r\n    'pydantic-settings'\r\n]\r\n\r\nsetup(\r\n    name='youtube-assistant',\r\n    packages=find_packages(\r\n        include=[\r\n            'assistant',\r\n        ]\r\n    ),\r\n    version=VERSION,\r\n    description=DESCRIPTION,\r\n    long_description_content_type='text/markdown',\r\n"}
{"image_path": "data\\train\\00455.png", "code": "    long_description=LONG_DESCRIPTION,\r\n    url='https://youtube-assistant.readthedocs.io/en/latest/',\r\n    author='Lyle Okoth',\r\n    author_email='lyceokoth@gmail.com',\r\n    license='MIT',\r\n    install_requires=install_requires,\r\n    keywords=key_words,\r\n    classifiers=[\r\n        'Intended Audience :: Developers',\r\n        'License :: OSI Approved :: MIT License',\r\n        'Programming Language :: Python',\r\n        'Programming Language :: Python :: 3',\r\n        'Programming Language :: Python :: 3.11',\r\n        'Programming Language :: Python :: 3.12',\r\n        'Operating System :: OS Independent'\r\n    ],\r\n)\r\n"}
{"image_path": "data\\train\\00456.png", "code": "from setuptools import find_packages, setup\r\nfrom pip._vendor import tomli\r\nfrom codecs import open\r\nfrom os import path\r\n\r\nHERE = path.abspath(path.dirname(__file__))\r\nwith open(path.join(HERE, 'README.md'), encoding='utf-8') as f:\r\n    LONG_DESCRIPTION = f.read()\r\nwith open('pyproject.toml', 'r') as f:\r\n    VERSION = tomli.load(f)['tool']['commitizen']['version']\r\nDESCRIPTION = 'A python library for generating documentation for python projects.'\r\nkey_words = ['dosctrings', 'documentation']\r\ninstall_requires = [\r\n    'langchain',\r\n    'langchain-openai',\r\n    'black',\r\n    'pydantic',\r\n    'pydantic-settings',\r\n]\r\nsetup(\r\n    name='oryks-docstring-generator',\r\n    packages=find_packages(include=['docstring_generator']),\r\n    version=VERSION,\r\n    description=DESCRIPTION,\r\n    long_description_content_type='text/markdown',\r\n    long_description=LONG_DESCRIPTION,\r\n    url='https://youtube-wrapper.readthedocs.io/en/latest/index.html',\r\n    author='Lyle Okoth',\r\n    author_email='lyceokoth@gmail.com',\r\n    license='MIT',\r\n    install_requires=install_requires,\r\n    keywords=key_words,\r\n    classifiers=[\r\n        'Intended Audience :: Developers',\r\n        'License :: OSI Approved :: MIT License',\r\n        'Programming Language :: Python',\r\n        'Programming Language :: Python :: 3',\r\n        'Programming Language :: Python :: 3.11',\r\n        'Programming Language :: Python :: 3.12',\r\n        'Operating System :: OS Independent',\r\n"}
{"image_path": "data\\train\\00457.png", "code": "    ],\r\n)\r\n"}
{"image_path": "data\\train\\00458.png", "code": "from setuptools import find_packages, setup\r\nfrom pip._vendor import tomli\r\n\r\n# For consistent encoding\r\nfrom codecs import open\r\nfrom os import path\r\n\r\n# The directory containing this file\r\nHERE = path.abspath(path.dirname(__file__))\r\n\r\n# Get the long description from the README file\r\nwith open(path.join(HERE, 'README.md'), encoding='utf-8') as f:\r\n    LONG_DESCRIPTION = f.read()\r\n\r\nwith open('pyproject.toml', 'r') as f:\r\n    VERSION = tomli.load(f)['tool']['commitizen']['version']\r\n\r\nDESCRIPTION = 'A python library that wraps around the Google calendar API. You can use it to schedule events using google calendar.'\r\n\r\nkey_words = [\r\n    'calendar', 'google-calendar', 'schedule events'\r\n]\r\n\r\ninstall_requires = [\r\n    'oryks-google-oauth',\r\n    'pydantic',\r\n    'pydantic-settings',\r\n    'pytz'\r\n]\r\n\r\nsetup(\r\n    name='oryks-google-calendar',\r\n    packages=find_packages(\r\n        include=[\r\n            'google_calendar',\r\n            'google_calendar.models',\r\n            'google_calendar.schemas',\r\n            'google_calendar.resources',\r\n        ]\r\n    ),\r\n"}
{"image_path": "data\\train\\00459.png", "code": "    version=VERSION,\r\n    description=DESCRIPTION,\r\n    long_description_content_type='text/markdown',\r\n    long_description=LONG_DESCRIPTION,\r\n    url='https://youtube-wrapper.readthedocs.io/en/latest/index.html',\r\n    author='Lyle Okoth',\r\n    author_email='lyceokoth@gmail.com',\r\n    license='MIT',\r\n    install_requires=install_requires,\r\n    keywords=key_words,\r\n    classifiers=[\r\n        'Intended Audience :: Developers',\r\n        'License :: OSI Approved :: MIT License',\r\n        'Programming Language :: Python',\r\n        'Programming Language :: Python :: 3',\r\n        'Programming Language :: Python :: 3.11',\r\n        'Programming Language :: Python :: 3.12',\r\n        'Operating System :: OS Independent'\r\n    ],\r\n)\r\n"}
{"image_path": "data\\train\\00460.png", "code": "from google_calendar import GoogleCalendar\r\nfrom google_calendar.schemas import (\r\n    ListCalendarEvents, CreateEvent, AttendeeSchema, ReminderSchema, RemindersSchema, \r\n    EventTimeSchema\r\n)\r\nfrom google_calendar.models import Event\r\nfrom datetime import datetime, timedelta, date as d\r\nimport pytz\r\n\r\nclient_secret: str = 'client_secret.json'\r\ngoogle_calendar: GoogleCalendar = GoogleCalendar(secret_file=client_secret)\r\ngoogle_calendar.authenticate()\r\n\r\n# req = ListCalendarEvents()\r\n# events = google_calendar.list_calendar_events(req)\r\n# items = events.items\r\n# print(len(items))\r\n# print(items[0])\r\n# print(items[-1])\r\n# import json\r\n# import random\r\n# from google_calendar.resources import EventResource\r\n# with open('events.json', 'r') as f:\r\n#     data = json.load(f)\r\n# event_resource: EventResource = EventResource(calendar_client=google_calendar.calendar_client)\r\n# events = event_resource.parse_items(data)\r\n# print(random.choice(events))\r\n# print(google_calendar.get_event(event_id='_6tlnaqrle5p6cpb4dhmj4phpegp68s9o6lnm6q3b75gj6sr3d5i6sqbb6go6gs3le9r34dj4ddlmmq3f6ks64sb5epq3apri75jj2tjmcss6e'))\r\n# print(google_calendar.quick_add('Meeting with emmanuel at 10.00 am tommorrow.'))\r\n# now = datetime.astimezone()\r\n# start = str(now.strftime(\"%Y-%m-%dT%H:%M:%S.%fZ\"))\r\n# end = str((now + timedelta(hours=2)).strftime(\"%Y-%m-%dT%H:%M:%S.%fZ\"))\r\n# create_event = CreateEvent(\r\n#     start=EventTimeSchema(dateTime=start),\r\n#     end=EventTimeSchema(dateTime=end),\r\n#     summary='Meeting Travis',\r\n#     description='Meet with Travis for launch of his new startup.',\r\n#     location='Weston Hotel, Nairobi',\r\n#     attendees=[\r\n#         AttendeeSchema(email='lpage@example.com'),\r\n"}
{"image_path": "data\\train\\00461.png", "code": "#         AttendeeSchema(email='sbrin@example.com')\r\n#     ],\r\n#     reminders=RemindersSchema(\r\n#         useDefault=False,\r\n#         overrides=[\r\n#             ReminderSchema(method='email', minutes=10),\r\n#             ReminderSchema(method='popup', minutes=20)\r\n#         ]\r\n#     )\r\n# )\r\n# created_event = google_calendar.create_event(create_event)\r\n# print(created_event)\r\ntoday = d.today()\r\nyear = today.year\r\nmonth = today.month\r\nday = today.day\r\ntime_min: datetime = datetime(year=year, month=month, day=25, hour=0, minute=1)\r\ntime_min: datetime = datetime.astimezone(time_min, pytz.timezone('Africa/Nairobi'))\r\ntime_min: str = str(time_min.strftime(\"%Y-%m-%dT%H:%M:%S.%fZ\"))\r\ntime_max: datetime = datetime(year=year, month=month, day=day, hour=23, minute=59)\r\ntime_max: datetime = datetime.astimezone(time_max, pytz.timezone('Africa/Nairobi'))\r\ntime_max: str = str(time_max.strftime(\"%Y-%m-%dT%H:%M:%S.%fZ\"))\r\nreq = ListCalendarEvents(\r\n    timeMin=time_min\r\n)\r\nevents = google_calendar.list_calendar_events(req)\r\nprint(events.items)\r\ndef parse_events(events: list[Event]) -> str:\r\n    event_str: str = \"\"\r\n    for i, event in enumerate(events, start=1):\r\n        event_str: str = f\"\\n{i}. \"\r\n        start_time: str = event.start.date_time.time()\r\n        end_time: str = event.end.date_time.time()\r\n        title: str = event.summary\r\n        location: str = event.location\r\n        event_str += f'From {start_time} to {end_time} you will {title} at {location}.'\r\n    return event_str\r\n# print(time_min)\r\n# print(time_max)\r\n# print(datetime.astimezone(datetime.now(), pytz.timezone('Africa/Nairobi')))\r\n"}
{"image_path": "data\\train\\00462.png", "code": "print(parse_events(events.items))"}
{"image_path": "data\\train\\00463.png", "code": "from oryks_google_oauth import GoogleOAuth, YouTubeScopes\r\n\r\n\r\nclient_secret_file: str = '/home/lyle/Professional Projects/youtube/client_secret.json'\r\napi_service_name: str = 'youtube'\r\napi_version: str = 'v3'\r\ncredentials_dir: str = '.youtube'\r\nscopes: list[str] = [YouTubeScopes.youtube.value]\r\noauth: GoogleOAuth = GoogleOAuth(\r\n    secrets_file=client_secret_file,\r\n    scopes=scopes,\r\n    api_service_name=api_service_name,\r\n    api_version=api_version,\r\n    credentials_dir=credentials_dir\r\n)\r\nyoutube_client = oauth.authenticate_google_server()\r\nyoutube_find_request = youtube_client.search().list(q='python programming videos', part='id, snippet')\r\nprint(youtube_find_request.execute())\r\n"}
{"image_path": "data\\train\\00464.png", "code": "from setuptools import find_packages, setup\r\nfrom pip._vendor import tomli\r\n\r\n# For consistent encoding\r\nfrom codecs import open\r\nfrom os import path\r\n\r\n# The directory containing this file\r\nHERE = path.abspath(path.dirname(__file__))\r\n\r\n# Get the long description from the README file\r\nwith open(path.join(HERE, 'README.md'), encoding='utf-8') as f:\r\n    LONG_DESCRIPTION = f.read()\r\n\r\nwith open('pyproject.toml', 'r') as f:\r\n    VERSION = tomli.load(f)['tool']['commitizen']['version']\r\n\r\nDESCRIPTION = 'A python library for authenticating requests for various google services including ``gmail``, ``youtube``, ``drive`` and ``calendar``.'\r\n\r\nkey_words = [\r\n    'google-auth',\r\n]\r\n\r\ninstall_requires = [\r\n    'google-api-python-client',\r\n    'google-auth-oauthlib',\r\n    'pydantic',\r\n    'pydantic-settings'\r\n]\r\n\r\nsetup(\r\n    name='oryks-google-oauth',\r\n    packages=find_packages(\r\n        include=[\r\n            'oryks_google_oauth',\r\n        ]\r\n    ),\r\n    version=VERSION,\r\n    description=DESCRIPTION,\r\n    long_description_content_type='text/markdown',\r\n"}
{"image_path": "data\\train\\00465.png", "code": "    long_description=LONG_DESCRIPTION,\r\n    url='https://youtube-wrapper.readthedocs.io/en/latest/index.html',\r\n    author='Lyle Okoth',\r\n    author_email='lyceokoth@gmail.com',\r\n    license='MIT',\r\n    install_requires=install_requires,\r\n    keywords=key_words,\r\n    classifiers=[\r\n        'Intended Audience :: Developers',\r\n        'License :: OSI Approved :: MIT License',\r\n        'Programming Language :: Python',\r\n        'Programming Language :: Python :: 3',\r\n        'Programming Language :: Python :: 3.10',\r\n        'Programming Language :: Python :: 3.11',\r\n        'Operating System :: OS Independent'\r\n    ],\r\n)\r\n"}
{"image_path": "data\\train\\00466.png", "code": "from setuptools import find_packages, setup\r\nfrom pip._vendor import tomli\r\n\r\n# For consistent encoding\r\nfrom codecs import open\r\nfrom os import path\r\n\r\n# The directory containing this file\r\nHERE = path.abspath(path.dirname(__file__))\r\n\r\n# Get the long description from the README file\r\nwith open(path.join(HERE, 'README.md'), encoding='utf-8') as f:\r\n    LONG_DESCRIPTION = f.read()\r\n\r\nwith open('pyproject.toml', 'r') as f:\r\n    VERSION = tomli.load(f)['tool']['commitizen']['version']\r\n\r\nDESCRIPTION = 'A python library that wraps around the YouTube V3 API. You can use it find and manage YouTube resources including Videos, Playlists, Channels and Comments.'\r\n\r\nkey_words = [\r\n    'youtube', 'youtube-api', 'youtube comments', 'youtube videos',\r\n    'youtube channels', 'youtube comment thread', 'create youtube playlist'\r\n]\r\n\r\ninstall_requires = [\r\n    'oryks-google-oauth',\r\n    'pydantic',\r\n    'pydantic-settings'\r\n]\r\n\r\nsetup(\r\n    name='oryks-youtube',\r\n    packages=find_packages(\r\n        include=[\r\n            'youtube',\r\n            'youtube.models',\r\n            'youtube.schemas',\r\n            'youtube.resources',\r\n            'youtube.resources.search',\r\n            'youtube.resources.video',\r\n"}
{"image_path": "data\\train\\00467.png", "code": "            'youtube.resources.playlist',\r\n            'youtube.resources.playlist_item',\r\n            'youtube.resources.comment_thread',\r\n            'youtube.resources.channel',\r\n            'youtube.resources.activity',\r\n            'youtube.resources.subscription',\r\n            'youtube.exceptions',\r\n        ]\r\n    ),\r\n    version=VERSION,\r\n    description=DESCRIPTION,\r\n    long_description_content_type='text/markdown',\r\n    long_description=LONG_DESCRIPTION,\r\n    url='https://youtube-wrapper.readthedocs.io/en/latest/index.html',\r\n    author='Lyle Okoth',\r\n    author_email='lyceokoth@gmail.com',\r\n    license='MIT',\r\n    install_requires=install_requires,\r\n    keywords=key_words,\r\n    classifiers=[\r\n        'Intended Audience :: Developers',\r\n        'License :: OSI Approved :: MIT License',\r\n        'Programming Language :: Python',\r\n        'Programming Language :: Python :: 3',\r\n        'Programming Language :: Python :: 3.11',\r\n        'Programming Language :: Python :: 3.12',\r\n        'Operating System :: OS Independent'\r\n    ],\r\n)\r\n"}
{"image_path": "data\\train\\00468.png", "code": "from youtube import YouTube\r\nfrom youtube.schemas import (\r\n    SearchFilter, SearchOptionalParameters, SearchPart, YouTubeResponse, YouTubeRequest,\r\n    CommentThreadFilter, CommentThreadOptionalParameters, CommentThreadPart, CreatePlaylist, \r\n    CreatePlaylistSnippet, CreatePlaylistItem, VideoResourceId, CreatePlaylistItemSnippet\r\n)\r\nfrom typing import Iterator\r\nfrom datetime import datetime\r\nfrom youtube.models import Comment\r\n\r\n\r\nclient_secrets_file = '/home/lyle/Downloads/search.json'\r\nyoutube = YouTube(client_secret_file=client_secrets_file)\r\nyoutube_client = youtube.authenticate()\r\nyoutube.youtube_client = youtube_client\r\n\r\n# query: str = 'Python programming videos'\r\n# max_results: int = 10\r\n# part: SearchPart = SearchPart()\r\n# optional_parameters: SearchOptionalParameters = SearchOptionalParameters(\r\n#     q=query,\r\n#     maxResults=max_results,\r\n#     type=['video', 'playlist', 'channel']\r\n# )\r\n# search_request: YouTubeRequest = YouTubeRequest(\r\n#     part=part, \r\n#     optional_parameters=optional_parameters\r\n# )\r\n# search_results: YouTubeResponse = youtube.search(search_request)\r\n# search_iterator: Iterator = youtube.get_search_iterator(search_request)\r\n# video = youtube.find_video_by_id('nDXsVhFG7TE')\r\n# videos = youtube.find_videos_by_ids(['nDXsVhFG7TE', 'aQXD-Wr6h64', 'AIqxfBhlwx0'])\r\n# ratings = youtube.get_video_ratings(['nDXsVhFG7TE', 'aQXD-Wr6h64', 'AIqxfBhlwx0'])\r\n# categories = youtube.get_video_categories()\r\n# video_abuse_reasons = youtube.list_video_abuse_report_reasons()\r\n# languages = youtube.list_languages()\r\n# regions = youtube.list_regions()\r\n# popular_video = youtube.find_most_popular_video_by_region()\r\n# channel = youtube.find_channel_by_id('UCRijo3ddMTht_IHyNSNXpNQ')\r\n# channels = youtube.find_channels_by_ids(['UCRijo3ddMTht_IHyNSNXpNQ'])\r\n"}
{"image_path": "data\\train\\00469.png", "code": "# my_channel = youtube.find_my_channel()\r\n# part: CommentThreadPart = CommentThreadPart()\r\n# filter: CommentThreadFilter = CommentThreadFilter(\r\n#     videoId='-dJPoLm_gtE'\r\n# )\r\n# optional: CommentThreadOptionalParameters = CommentThreadOptionalParameters(\r\n#     maxResults=25\r\n# )\r\n# request:YouTubeRequest = YouTubeRequest(\r\n#     part=part,\r\n#     filter=filter,\r\n#     optional_parameters=optional\r\n# )\r\n# comments = youtube.find_video_comments(request)\r\n# part: CommentThreadPart = CommentThreadPart()\r\n# filter: CommentThreadFilter = CommentThreadFilter(\r\n#     allThreadsRelatedToChannelId='UCRijo3ddMTht_IHyNSNXpNQ'\r\n# )\r\n# optional: CommentThreadOptionalParameters = CommentThreadOptionalParameters(\r\n#     maxResults=25\r\n# )\r\n# request:YouTubeRequest = YouTubeRequest(\r\n#     part=part,\r\n#     filter=filter,\r\n#     optional_parameters=optional\r\n# )\r\n# channel_comments = youtube.find_all_channel_comments(request)\r\n# comment = youtube.get_comment('UgxAQ5xm0pH2NQcwokx4AaABAg')\r\n# replies = youtube.get_comment_replies('UgxwXLTWugMg7IEoKgR4AaABAg')\r\n# comment_text = 'Sample comment text'\r\n# video_id = 'jl3b4eLKiP8'\r\n# comment = youtube.insert_comment(video_id, comment_text)\r\n# comment_id = 'UgxnWN0P4ii1OiIEWft4AaABAg'\r\n# reply = 'Sample comment reply'\r\n# comment_reply = youtube.reply_to_comment(comment_id, reply)\r\n# channel_playlists = youtube.find_channel_playlists('UCRijo3ddMTht_IHyNSNXpNQ')\r\n# my_playlists = youtube.find_my_playlists()\r\n# print(my_playlists)\r\n# playlist_snippet = CreatePlaylistSnippet(\r\n#     title='sample title',\r\n"}
{"image_path": "data\\train\\00470.png", "code": "#     description='sample description',\r\n#     defaultLanguage='en'\r\n# )\r\n# playlist = youtube.insert_playlist(playlist_schema=CreatePlaylist(snippet=playlist_snippet))\r\n# playlist_snippet = CreatePlaylistSnippet(\r\n#     title='sample title updated',\r\n#     description='sample description',\r\n#     defaultLanguage='en'\r\n# )\r\n# playlist = youtube.update_playlist(playlist_id='PL_26vmg8W_AejZY4OPSqdHrdIaRjoSvTW', \r\n#                                    playlist_schema=CreatePlaylist(snippet=playlist_snippet))\r\n# youtube.delete_playlist(playlist_id='PL_26vmg8W_AejZY4OPSqdHrdIaRjoSvTW')\r\n# my_playlists_iterator = youtube.get_my_playlists_iterator()\r\n# print(next(my_playlists_iterator))\r\n# print(next(my_playlists_iterator))\r\n# playlist_items = youtube.find_playlist_items(playlist_id='PL_26vmg8W_AfD5tzNAbIGbtTLU6ivjorS')\r\n# item_ids = [\r\n#     'UExfMjZ2bWc4V19BZkQ1dHpOQWJJR2J0VExVNml2am9yUy5DMkM0MjQ3OTgwQzBCMEZB',\r\n#     'UExfMjZ2bWc4V19BZkQ1dHpOQWJJR2J0VExVNml2am9yUy5BRjY4NjdBRjA5RTdCMUMx'\r\n# ]\r\n# playlist_items = youtube.find_playlist_items_by_ids(item_ids)\r\n# resource_id = VideoResourceId(videoId='jbcjK0W6U0E')\r\n# item_snippet = CreatePlaylistItemSnippet(playlistId='PL_26vmg8W_AfD5tzNAbIGbtTLU6ivjorS', resourceId=resource_id)\r\n# item = youtube.insert_playlist_item(CreatePlaylistItem(snippet=item_snippet))\r\n# youtube.delete_playlist_item(playlist_item_id='UExfMjZ2bWc4V19BZkQ1dHpOQWJJR2J0VExVNml2am9yUy5CNzAzQzRDMkI3QThEQzZB')\r\n# print(item)\r\n# channel = youtube.find_channel_by_name('Ark Invest')\r\n# print(channel)\r\n# query: str = 'Python programming videos'\r\n# max_results: int = 10\r\n# january_2023 = datetime(year=2023, month=1, day=1)\r\n# january_2023 = str(january_2023.strftime(\"%Y-%m-%dT%H:%M:%S.%fZ\"))\r\n# part: SearchPart = SearchPart()\r\n# optional_parameters: SearchOptionalParameters = SearchOptionalParameters(\r\n#     q=query,\r\n#     maxResults=max_results,\r\n#     type=['video'],\r\n#     publishedAfter=january_2023\r\n# )\r\n# search_request: YouTubeRequest = YouTubeRequest(\r\n"}
{"image_path": "data\\train\\00471.png", "code": "#     part=part, \r\n#     optional_parameters=optional_parameters\r\n# )\r\n# search_results: YouTubeResponse = youtube.search(search_request)\r\n# print(search_results)\r\n# print(youtube.find_my_channel())\r\n# part: CommentThreadPart = CommentThreadPart()\r\n# filter: CommentThreadFilter = CommentThreadFilter(\r\n#     videoId='Tuc-rjJbsXU'\r\n# )\r\n# optional: CommentThreadOptionalParameters = CommentThreadOptionalParameters(\r\n#     maxResults=5\r\n# )\r\n# request:YouTubeRequest = YouTubeRequest(\r\n#     part=part,\r\n#     filter=filter,\r\n#     optional_parameters=optional\r\n# )\r\n# comment_iterator: Iterator = youtube.get_comments_iterator(request)\r\n# video_comments: list[Comment] = list()\r\n# for comment_threads in comment_iterator:\r\n#     for comment_thread in comment_threads:\r\n#         comment: Comment = comment_thread.snippet.top_level_comment\r\n#         video_comments.append(comment)\r\n# print(video_comments)\r\n# comment_id: str = 'UgzdXi_vWhXLkBA_Pwt4AaABAg'\r\n# response = youtube.get_comment(comment_id)\r\n# print(response)\r\n# import json\r\n\r\n# with open('comment.json', 'w') as f:\r\n#     json.dump(response, f, indent=4)\r\n# from youtube.resources.comment_thread.comment import CommentResource\r\n# import json\r\n# comment_res = CommentResource(youtube_client)\r\n# with open('comment.json', 'r') as f:\r\n#     comments = json.load(f)\r\n# print(comment_res.parse_youtube_list_response(comments))\r\n# replies = youtube.get_comment_replies('UgxwXLTWugMg7IEoKgR4AaABAg')\r\n# import json\r\n"}
{"image_path": "data\\train\\00472.png", "code": "# with open('replies.json', 'w') as f:\r\n#     json.dump(replies, f, indent=4)\r\n# from youtube.resources.comment_thread.comment import CommentResource\r\n# import json\r\n# comment_res = CommentResource(youtube_client)\r\n# with open('replies.json', 'r') as f:\r\n#     comments = json.load(f)\r\n# print(comment_res.parse_youtube_response(comments))\r\n# print(len(comment_res.parse_youtube_response(comments).items))\r\n\r\n# comment_text = 'Sample comment text'\r\n# video_id = 'jl3b4eLKiP8'\r\n# comment = youtube.insert_comment(video_id, comment_text)\r\n# print(comment)\r\n\r\n# comment_id = 'UgyblK9NGskUXp91WIt4AaABAg'\r\n# reply = 'Sample comment reply'\r\n# comment_reply = youtube.reply_to_comment(comment_id, reply)\r\n# channel = youtube.find_my_channel()\r\n# print(channel.items[0].snippet.custom_url)\r\n# import json\r\n# my_activities = youtube.list_my_activities()\r\n# with open('my_activities.json', 'w') as f:\r\n#     json.dump(my_activities, f, indent=4)\r\n# print(my_activities)\r\n# print(youtube.find_channel_by_id(channel_id=\"UCj3FYGvdAVNdD3M0dvKr3cA\"))\r\nit = youtube.get_comments_iterator(video_id='cBpGq-vDr2Y')\r\nprint(next(it))"}
{"image_path": "data\\train\\00473.png", "code": "from .google_drive import GoogleDrive\r\n"}
{"image_path": "data\\train\\00474.png", "code": "from typing import Any, Optional\r\n\r\nfrom oryks_google_oauth import GoogleDriveScopes, GoogleOAuth\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass GoogleDrive(BaseModel):\r\n    \"\"\"Provides methods for interacting with the Drive API.\r\n\r\n    This class acts as an interface to the Drive API, providing methods for interacting with\r\n    the Drive API.\r\n\r\n    Attributes\r\n    ----------\r\n    client_secret_file: str\r\n        The path to the json file containing your authentication information.\r\n    \"\"\"\r\n\r\n    client_secret_file: Optional[str] = None\r\n    authenticated: Optional[bool] = False\r\n    drive_client: Optional[Any] = None\r\n\r\n    def authenticate(self, client_secret_file: Optional[str] = None) -> None:\r\n        \"\"\"Authenticate the requests made to drive.\r\n\r\n        Used to generate the credentials that are used when authenticating requests to drive.\r\n\r\n        Parameters\r\n        ----------\r\n        client_secret_file: str\r\n            The path to clients secret json file from Google\r\n\r\n        Raises\r\n        ------\r\n        ValueError:\r\n            When the client secrets file is not provided\r\n        FileNotFoundError:\r\n            When the secrets file path is not found\r\n        \"\"\"\r\n        if client_secret_file:\r\n"}
{"image_path": "data\\train\\00475.png", "code": "            self.client_secret_file = client_secret_file\r\n        if not self.client_secret_file:\r\n            raise ValueError('The client secret file must be provided.')\r\n        api_service_name: str = 'drive'\r\n        api_version: str = 'v3'\r\n        credentials_dir: str = '.drive_credentials'\r\n        scopes: list[str] = [\r\n            GoogleDriveScopes.metadata.value,\r\n            GoogleDriveScopes.drive.value,\r\n            GoogleDriveScopes.files.value,\r\n            GoogleDriveScopes.activity.value,\r\n        ]\r\n        oauth: GoogleOAuth = GoogleOAuth(\r\n            secrets_file=self.client_secret_file,\r\n            scopes=scopes,\r\n            api_service_name=api_service_name,\r\n            api_version=api_version,\r\n            credentials_dir=credentials_dir,\r\n        )\r\n        self.drive_client = oauth.authenticate_google_server()\r\n        return self.drive_client\r\n\r\n    def create_file(self) -> None:\r\n        \"\"\"Creates a new file on drive.\"\"\"\r\n        raise NotImplementedError()\r\n    \r\n    def upload_file(self) -> None:\r\n        \"\"\"Upload a file to drive.\"\"\"\r\n        raise NotImplementedError()\r\n    \r\n    def resumable_upload(self) -> None:\r\n        raise NotImplementedError()\r\n"}
{"image_path": "data\\train\\00476.png", "code": "import ast\r\nfrom ast import AST, FunctionDef, NodeTransformer\r\n\r\nfrom .config import Config\r\nfrom .helpers import generate_doc_string, make_docstring_node\r\nfrom .model_parsers import parse_function_docstr\r\n\r\n\r\nclass FunctionTransformer(NodeTransformer):\r\n    def __init__(self, config: Config, function_src: str) -> None:\r\n        super().__init__()\r\n        self._config: Config = config\r\n        self._function_src = function_src\r\n\r\n    def visit_FunctionDef(self, node: FunctionDef) -> None:\r\n        ast_tree: AST = ast.parse(self._function_src)\r\n        function_node: AST = ast_tree.body[0]\r\n        docstring: str = ast.get_docstring(node=node)\r\n        if function_node.name == node.name:\r\n            if not docstring:\r\n                src_code: str = ast.unparse(node)\r\n                func_docstr: str = generate_doc_string(\r\n                    src_code=src_code, config=self._config\r\n                )\r\n                doc_str: str = parse_function_docstr(func_docstr.strip())\r\n                if doc_str:\r\n                    dcstr_node: AST = make_docstring_node(doc_str)\r\n                    node.body.insert(0, dcstr_node)\r\n            elif self._config.overwrite_function_docstring:\r\n                src_code: str = ast.unparse(node)\r\n                func_docstr: str = generate_doc_string(\r\n                    src_code=src_code, config=self._config\r\n                )\r\n                doc_str: str = parse_function_docstr(func_docstr.strip())\r\n                if doc_str:\r\n                    dcstr_node: AST = make_docstring_node(doc_str)\r\n                    node.body[0] = dcstr_node\r\n        return node\r\n"}
{"image_path": "data\\train\\00477.png", "code": "from argparse import Namespace\r\n\r\nfrom .config import Config\r\nfrom .docstring_generator import generate_project_docstrings\r\nfrom .extensions import function_code_queue, source_code_queue\r\nfrom .ui import create_application_config, parse_arguments\r\n\r\n\r\ndef main():\r\n    args: Namespace = parse_arguments()\r\n    config: Config = create_application_config(args)\r\n    generate_project_docstrings(\r\n        config=config,\r\n        source_code_queue=source_code_queue,\r\n        function_code_queue=function_code_queue,\r\n    )\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"}
{"image_path": "data\\train\\00478.png", "code": "import ast\r\nfrom ast import AST, NodeTransformer\r\nfrom queue import Empty, Queue\r\nfrom openai import RateLimitError\r\n\r\nfrom .config import Config\r\nfrom .helpers import format_file, parse_src, read_src, save_src\r\nfrom .transformers import FunctionTransformer\r\nfrom .walkers import FunctionVisitor\r\n\r\n\r\ndef process_file(source_code_queue: Queue, function_code_queue: Queue):\r\n    while True:\r\n        try:\r\n            file_path: str = source_code_queue.get(timeout=1)\r\n            print(f\"processing the file: {file_path}\")\r\n            file_src: str = read_src(file_path=file_path)\r\n            src_tree: AST = parse_src(file_src)\r\n            visitor: FunctionVisitor = FunctionVisitor(\r\n                function_code_queue=function_code_queue,\r\n                file_path=file_path,\r\n            )\r\n            visitor.visit(src_tree)\r\n            source_code_queue.task_done()\r\n        except Empty:\r\n            print(\"Terminating the file processing..\")\r\n            break\r\n\r\n\r\ndef process_function(config: Config, function_code_queue: Queue) -> None:\r\n    while True:\r\n        try:\r\n            file_path, function_code = function_code_queue.get(timeout=1)\r\n            # print(function_code)\r\n            file_src: str = read_src(file_path=file_path)\r\n            src_tree: AST = parse_src(file_src)\r\n            # print_src(src_tree)\r\n            transformer: NodeTransformer = FunctionTransformer(\r\n                config=config, function_src=function_code\r\n            )\r\n"}
{"image_path": "data\\train\\00479.png", "code": "            new_tree = transformer.visit(src_tree)\r\n            ast.fix_missing_locations(new_tree)\r\n            new_module_code = ast.unparse(new_tree)\r\n            print(new_module_code)\r\n            save_src(file_path=file_path, new_src=new_module_code)\r\n            format_file(file_path=file_path)\r\n            function_code_queue.task_done()\r\n        except Empty:\r\n            print(\"Terminating the function processing..\")\r\n            break\r\n"}
{"image_path": "data\\train\\00480.png", "code": "from collections import deque\r\nfrom collections.abc import Iterator\r\nfrom os import listdir, path\r\nfrom queue import Queue\r\n\r\nfrom .config import Config\r\nfrom .helpers import read_src\r\n\r\n\r\nclass DirectoryIterator(Iterator):\r\n    def __init__(self, config: Config) -> None:\r\n        super().__init__()\r\n        self._folders_ignore = set(config.directories_ignore)\r\n        self._files_ignore = set(config.files_ignore)\r\n        self._queue = deque(config.root_directory)  # adding the individual chars\r\n\r\n    def __iter__(self) -> Iterator:\r\n        return super().__iter__()\r\n\r\n    def __next__(self) -> list[str]:\r\n        if self._queue:\r\n            files: list[str] = list()\r\n            for _ in range(len(self._queue)):\r\n                directory: str = self._queue.popleft()\r\n                for entry in listdir(directory):\r\n                    entry_path: str = path.join(directory, entry)\r\n                    if (\r\n                        path.isfile(entry_path)\r\n                        and self._is_python_file(entry_path)\r\n                        and entry not in self._files_ignore\r\n                    ):\r\n                        files.append(entry_path)\r\n                    elif path.isdir(entry_path) and entry not in self._folders_ignore:\r\n                        self._queue.append(entry_path)\r\n            return files\r\n        else:\r\n            raise StopIteration()\r\n\r\n    def _is_python_file(self, file_path: str) -> bool:\r\n        return file_path.split(\".\")[-1] == \"py\"\r\n"}
{"image_path": "data\\train\\00481.png", "code": "\r\n\r\ndef get_all_modules(config: Config, source_code_queue: Queue) -> None:\r\n    \"\"\"Iterate throug all the directories from the root directory.\"\"\"\r\n    for entry in config.root_directory:\r\n        if path.isfile(entry):\r\n            source_code_queue.put(entry)\r\n        else:\r\n            directory_iterator: DirectoryIterator = DirectoryIterator(config=config)\r\n            for modules in directory_iterator:\r\n                for module in modules:\r\n                    source_code_queue.put(module)\r\n"}
{"image_path": "data\\train\\00482.png", "code": "from typing import Optional\r\n\r\nfrom pydantic import BaseModel, Field\r\n\r\n\r\nclass Config(BaseModel):\r\n    root_directory: list[str] = Field(\r\n        description=\"The path to the source code directory\"\r\n    )\r\n    directories_ignore: set[str] = Field(\r\n        description=\"Directories to ignore\",\r\n        default=set([\"venv\", \".venv\", \"__pycache__\", \".git\", \"build\", \"dist\", \"docs\"]),\r\n    )\r\n    files_ignore: set[str] = Field(\r\n        description=\"Files to ignore\",\r\n        default_factory=set,\r\n    )\r\n    overwrite_function_docstring: Optional[bool] = Field(\r\n        description=\"Whether or not to overwrite the existing function docstring\",\r\n        default=False,\r\n    )\r\n    documentation_style: Optional[str] = Field(\r\n        description=\"The format of documentation to use\",\r\n        default=\"Numpy-Style\",\r\n        enum=[\"Numpy-Style\", \"Google-Style\", \"Sphinx-Style\"],\r\n    )\r\n"}
{"image_path": "data\\train\\00483.png", "code": "from langchain.prompts import PromptTemplate\r\n\r\nfunction_prompt_template: str = \"\"\"\r\nGenerate python docstring for the given python function using the provided documentation style.\r\nMake sure to provide atleast two examples of the function usage only in the docstring as well\r\nas the exceptions that may be raised when using the function. Make sure to return the\r\nfunction and its docstring.\r\nFunction code: {function_code}\r\nDocumentation style: {documentation_style}\r\n\"\"\"\r\nfunction_prompt = PromptTemplate.from_template(template=function_prompt_template)\r\n"}
{"image_path": "data\\train\\00484.png", "code": "import os\r\n\r\nfrom langchain.llms.base import BaseLLM\r\nfrom langchain_openai import OpenAI\r\n\r\napi_key: str = os.environ[\"OPENAI_API_KEY\"]\r\n\r\nchatgpt: BaseLLM = OpenAI(temperature=0, api_key=api_key)\r\n"}
{"image_path": "data\\train\\00485.png", "code": "from queue import Queue\r\n\r\nsource_code_queue: Queue = Queue()\r\nfunction_code_queue: Queue = Queue()\r\n"}
{"image_path": "data\\train\\00486.png", "code": "import ast\r\nfrom ast import FunctionDef\r\nfrom queue import Queue\r\n\r\nfrom .helpers import read_src\r\n\r\n\r\nclass FunctionVisitor(ast.NodeVisitor):\r\n    def __init__(self, function_code_queue: Queue, file_path: str) -> None:\r\n        super().__init__()\r\n        self._function_code_queue = function_code_queue\r\n        self._file_path = file_path\r\n\r\n    def visit_FunctionDef(self, node: FunctionDef) -> None:\r\n        function_code: str = ast.unparse(ast_obj=node)\r\n        self._function_code_queue.put((self._file_path, function_code))\r\n"}
{"image_path": "data\\train\\00487.png", "code": "import os\r\nfrom argparse import ArgumentParser, Namespace\r\nfrom os import path\r\n\r\nfrom .config import Config\r\n\r\n\r\ndef parse_arguments() -> Namespace:\r\n    parser = ArgumentParser(\r\n        prog=\"docstring-generator\",\r\n        description=\"Generate docstrings for your python projects\",\r\n        epilog=\"Thanks for using %(prog)s! :)\",\r\n    )\r\n    parser.add_argument(\"--path\", nargs=\"*\", default=[\".\"], type=str)\r\n    parser.add_argument(\"--config-file\", nargs=\"?\", default=\"\", type=str)\r\n    parser.add_argument(\"--OPENAI_API_KEY\", nargs=\"?\", default=\"\", type=str)\r\n    parser.add_argument(\r\n        \"--overwrite-function-docstring\", nargs=\"?\", default=False, type=bool\r\n    )\r\n    parser.add_argument(\"--directories-ignore\", nargs=\"*\", default=[], type=str)\r\n    parser.add_argument(\"--files-ignore\", nargs=\"*\", default=[], type=str)\r\n    parser.add_argument(\r\n        \"--documentation-style\",\r\n        nargs=\"?\",\r\n        default=\"Numpy-Style\",\r\n        choices=[\"Numpy-Style\", \"Google-Style\", \"Sphinx-Style\"],\r\n        type=str,\r\n    )\r\n    args = parser.parse_args()\r\n    paths: list[str] = args.path\r\n    for entry in paths:\r\n        if not path.exists(entry):\r\n            print(f\"The target path '{entry}' doesn't exist\")\r\n            raise SystemExit(1)\r\n    if args.OPENAI_API_KEY:\r\n        os.environ[\"OPENAI_API_KEY\"] = args.OPENAI_API_KEY\r\n    if not os.environ.get(\"OPENAI_API_KEY\", None):\r\n        print(\"You have not provided the open ai api key.\")\r\n        raise SystemExit(1)\r\n    return args\r\n"}
{"image_path": "data\\train\\00488.png", "code": "\r\n\r\ndef create_application_config(args: Namespace) -> Config:\r\n    config: Config = Config(\r\n        root_directory=set(args.path),\r\n        overwrite_function_docstring=args.overwrite_function_docstring,\r\n        documentation_style=args.documentation_style,\r\n    )\r\n    config.directories_ignore.update(set(args.directories_ignore))\r\n    config.files_ignore.update(set(args.files_ignore))\r\n    return config\r\n"}
{"image_path": "data\\train\\00489.png", "code": "from __future__ import annotations\r\n\r\nimport ast\r\nfrom abc import ABC, abstractmethod\r\nfrom ast import AST, FunctionDef\r\n\r\nfrom .helpers import parse_src\r\n\r\n\r\nclass Parser(ABC):\r\n    @abstractmethod\r\n    def set_next(self, parser: Parser) -> Parser:\r\n        pass\r\n\r\n    @abstractmethod\r\n    def parse(self, docstring: str) -> str:\r\n        pass\r\n\r\n\r\nclass AbstractParser(Parser):\r\n    _next_parser: Parser = None\r\n\r\n    def set_next(self, parser: Parser) -> Parser:\r\n        self._next_parser = parser\r\n        return parser\r\n\r\n    @abstractmethod\r\n    def parse(self, docstring: str) -> str:\r\n        if self._next_parser:\r\n            return self._next_parser.parse(docstring)\r\n        print(\"Unable to parse the docstring generated.\")\r\n        print(\"################################\")\r\n        print(docstring)\r\n        print(\"################################\")\r\n        return None\r\n\r\n\r\nclass DefaultParser(AbstractParser):\r\n    def parse(self, docstring: str) -> str:\r\n        try:\r\n"}
{"image_path": "data\\train\\00490.png", "code": "            src_tree: AST = parse_src(docstring)\r\n            func_node: FunctionDef = src_tree.body[0]\r\n            doc_str: str = ast.get_docstring(func_node)\r\n        except Exception:\r\n            return super().parse(docstring)\r\n        else:\r\n            return doc_str\r\n\r\n\r\nmodel_parser: Parser = DefaultParser()\r\n\r\n\r\ndef parse_function_docstr(func_dcstr: str) -> str:\r\n    return model_parser.parse(docstring=func_dcstr)\r\n"}
{"image_path": "data\\train\\00491.png", "code": "from concurrent.futures import ThreadPoolExecutor\r\nfrom queue import Queue\r\nfrom threading import Lock\r\n\r\nfrom .config import Config\r\nfrom .directory_iterators import get_all_modules\r\nfrom .docstring_writer import process_file, process_function\r\n\r\n\r\ndef generate_project_docstrings(\r\n    config: Config, source_code_queue: Queue, function_code_queue: Queue\r\n) -> None:\r\n    with ThreadPoolExecutor(max_workers=4) as executor:\r\n        executor.submit(get_all_modules, config, source_code_queue)\r\n        executor.submit(process_file, source_code_queue, function_code_queue)\r\n        executor.submit(process_function, config, function_code_queue)\r\n    source_code_queue.join()\r\n    function_code_queue.join()\r\n"}
{"image_path": "data\\train\\00492.png", "code": "import ast\r\nimport subprocess\r\nfrom ast import AST, Constant, Expr\r\nfrom os import path\r\nfrom openai import RateLimitError\r\nimport sys\r\n\r\nfrom .config import Config\r\nfrom .llms import chatgpt\r\nfrom .templates import function_prompt\r\n\r\n\r\ndef read_src(file_path: str) -> str:\r\n    with open(file_path, \"r\", encoding=\"utf-8\") as f:\r\n        return f.read()\r\n\r\n\r\ndef save_src(file_path: str, new_src: str) -> str:\r\n    with open(file_path, \"w\", encoding=\"utf-8\") as f:\r\n        return f.write(new_src)\r\n\r\n\r\ndef parse_src(file_src: str) -> AST:\r\n    return ast.parse(file_src)\r\n\r\n\r\ndef print_src(src_tree: AST) -> None:\r\n    print(ast.dump(src_tree, indent=4))\r\n\r\n\r\nfunction_dcstr: str = '''\r\ndef subtract(a: int | float, b: int | float) -> int | float:\r\n    \"\"\"Subtracts two numbers\r\n\r\n    Parameters\r\n    ----------\r\n    a : int or float\r\n        The first number to subtract.\r\n    b : int or float\r\n        The second number to subtract.\r\n"}
{"image_path": "data\\train\\00493.png", "code": "\r\n    Returns\r\n    -------\r\n    int or float\r\n        The result of subtracting b from a.\r\n    \"\"\"\r\n    return a - b\r\n'''\r\n\r\n\r\ndef generate_doc_string(src_code: str, config: Config) -> str:\r\n    prompt_formatted_str: str = function_prompt.format(\r\n        function_code=src_code, documentation_style=config.documentation_style\r\n    )\r\n    # function_and_docstring: str = chatgpt.invoke(prompt_formatted_str)\r\n    # return function_and_docstring\r\n    return function_dcstr\r\n\r\n\r\ndef make_docstring_node(docstr: str):\r\n    constant_str: Constant = Constant(docstr)\r\n    return Expr(value=constant_str)\r\n\r\n\r\ndef format_file(file_path: str) -> None:\r\n    \"\"\"Format the file using black.\"\"\"\r\n    if path.exists(file_path):\r\n        subprocess.run([\"black\", file_path], capture_output=True)\r\n"}
{"image_path": "data\\train\\00494.png", "code": "from langchain.llms import OpenAI\r\n\r\nfrom langchain_google_genai import ChatGoogleGenerativeAI\r\n\r\nopen_ai = OpenAI(temperature=0)\r\ngoogle = ChatGoogleGenerativeAI(model=\"gemini-pro\")\r\n"}
{"image_path": "data\\train\\00495.png", "code": "import os\r\n\r\nfrom youtube import YouTube\r\n\r\nclient_secrets_file = os.environ['CLIENT_SECRET_FILE']\r\nyoutube_client = YouTube(client_secret_file=client_secrets_file)\r\nyoutube_client.authenticate()\r\n"}
{"image_path": "data\\train\\00496.png", "code": "from argparse import Namespace\r\n\r\nfrom dotenv import load_dotenv\r\n\r\nload_dotenv()\r\nfrom .config import Config\r\nfrom .docstring_generator import generate_docstrings\r\nfrom .extensions import (\r\n    failed_modules_queue,\r\n    functions_source_code_queue,\r\n    modules_path_queue,\r\n    class_source_code_queue,\r\n)\r\nfrom .helpers import create_application_config, parse_arguments\r\n\r\n\r\ndef run():\r\n    \"\"\"Runs the application by parsing arguments, creating a configuration, and generating docstrings.\r\n\r\n    Returns:\r\n        function: The run function.\r\n        docstring: The docstring for the run function.\r\n        exceptions: Any exceptions that may be thrown during execution.\"\"\"\r\n    args: Namespace = parse_arguments()\r\n    config: Config = create_application_config(args)\r\n    generate_docstrings(\r\n        config=config,\r\n        module_path_queue=modules_path_queue,\r\n        functions_source_queue=functions_source_code_queue,\r\n        failed_modules_queue=failed_modules_queue,\r\n        class_source_queue=class_source_code_queue,\r\n    )\r\n\r\n\r\nif __name__ == '__main__':\r\n    run()\r\n"}
{"image_path": "data\\train\\00497.png", "code": "import ast\r\nfrom _ast import ClassDef, FunctionDef\r\nfrom ast import NodeTransformer\r\nfrom typing import Any\r\n\r\nfrom pydantic import BaseModel, Field\r\n\r\nfrom .config import Config\r\nfrom .helpers import (\r\n    generate_class_docstring,\r\n    generate_function_docstring,\r\n    get_class_docstring,\r\n    get_class_methods_docstrings,\r\n    get_function_docstring,\r\n    get_module_source_code,\r\n    make_docstring_node,\r\n)\r\n\r\n\r\nclass FunctionDocStringWriter(NodeTransformer, BaseModel):\r\n    module_path: str = Field(description='The path to this module')\r\n    function_name: str = Field(\r\n        description='The name of the function to generate docstrings'\r\n    )\r\n    function_code: str = Field(description='The source code for this function')\r\n    config: Config = Field(description='The application configurations.')\r\n\r\n    @property\r\n    def module_code(self) -> str:\r\n        return get_module_source_code(self.module_path)\r\n\r\n    def visit_FunctionDef(self, node: FunctionDef) -> Any:\r\n        docstring: str = ast.get_docstring(node=node)\r\n        if node.name == self.function_name and (\r\n            self.config.overwrite_function_docstring or not docstring\r\n        ):\r\n            function_code: str = ast.get_source_segment(\r\n                source=self.module_code, node=node, padded=True\r\n            )\r\n            function_and_docstring: str = generate_function_docstring(\r\n"}
{"image_path": "data\\train\\00498.png", "code": "                function_code=function_code, config=self.config\r\n            )\r\n            try:\r\n                function_docstring: str = get_function_docstring(function_and_docstring)\r\n            except Exception:\r\n                new_docstring_node = make_docstring_node(function_and_docstring)\r\n            else:\r\n                new_docstring_node = make_docstring_node(function_docstring)\r\n            node.body.insert(0, new_docstring_node)\r\n        return node\r\n\r\n\r\nclass ClassDocStringWriter(NodeTransformer, BaseModel):\r\n    module_path: str = Field(description='The path to this module')\r\n    class_name: str = Field(description='The name of the class to generate docstrings')\r\n    class_code: str = Field(description='The source code for this class')\r\n    config: Config = Field(description='The application configurations.')\r\n\r\n    @property\r\n    def module_code(self) -> str:\r\n        return get_module_source_code(self.module_path)\r\n\r\n    def visit_ClassDef(self, node: ClassDef) -> Any:\r\n        docstring: str = ast.get_docstring(node=node)\r\n        if node.name == self.class_name and (\r\n            self.config.overwrite_class_docstring or not docstring\r\n        ):\r\n            class_code: str = ast.get_source_segment(\r\n                source=self.module_code, node=node, padded=True\r\n            )\r\n            class_and_docstring: str = generate_class_docstring(\r\n                class_code=class_code, config=self.config\r\n            )\r\n            try:\r\n                class_docstring: str = get_class_docstring(class_and_docstring)\r\n            except Exception:\r\n                class_docstring = class_and_docstring\r\n                new_docstring_node = make_docstring_node(class_and_docstring)\r\n                class_docstring = class_and_docstring\r\n            else:\r\n"}
{"image_path": "data\\train\\00499.png", "code": "                new_docstring_node = make_docstring_node(class_docstring)\r\n            node.body.insert(0, new_docstring_node)\r\n            methods_docstrings: dict[str, str] = get_class_methods_docstrings(\r\n                class_and_docstring\r\n            )\r\n            for class_node in node.body:\r\n                if isinstance(class_node, FunctionDef):\r\n                    function_doc: str = ast.get_docstring(node=class_node)\r\n                    if (\r\n                        not function_doc\r\n                        or self.config.overwrite_class_methods_docstring\r\n                    ):\r\n                        function_name: str = class_node.name\r\n                        new_docstring_node = make_docstring_node(\r\n                            methods_docstrings[function_name]\r\n                        )\r\n                        class_node.body.insert(0, new_docstring_node)\r\n        return node\r\n\r\n\r\nclass DocstringWriter(NodeTransformer, BaseModel):\r\n    module_code: str = Field(description='The source code for this module')\r\n    config: Config = Field(description='The application configurations.')\r\n\r\n    def visit_classDef(self, node: FunctionDef) -> Any:\r\n        docstring: str = ast.get_docstring(node=node)\r\n        if self.config.overwrite_function_docstring or not docstring:\r\n            function_code: str = ast.get_source_segment(\r\n                source=self.module_code, node=node, padded=True\r\n            )\r\n            function_and_docstring: str = generate_function_docstring(\r\n                function_code, self.config\r\n            )\r\n            function_docstring: str = get_function_docstring(function_and_docstring)\r\n            new_docstring_node = make_docstring_node(function_docstring)\r\n            node.body.insert(0, new_docstring_node)\r\n\r\n        return node\r\n\r\n    def visit_ClassDef(self, node: ClassDef) -> Any:\r\n"}
{"image_path": "data\\train\\00500.png", "code": "        docstring: str = ast.get_docstring(node=node)\r\n        if not docstring or self.config.overwrite_class_docstring:\r\n            class_code: str = ast.get_source_segment(\r\n                source=self.module_code, node=node, padded=True\r\n            )\r\n            class_and_docstring: str = generate_class_docstring(class_code, self.config)\r\n            class_docstring: str = get_class_docstring(class_and_docstring)\r\n            new_docstring_node = make_docstring_node(class_docstring)\r\n            node.body.insert(0, new_docstring_node)\r\n            methods_docstrings: dict[str, str] = get_class_methods_docstrings(\r\n                class_and_docstring\r\n            )\r\n            for class_node in node.body:\r\n                if isinstance(class_node, FunctionDef):\r\n                    function_doc: str = ast.get_docstring(node=class_node)\r\n                    if (\r\n                        not function_doc\r\n                        or self.config.overwrite_class_methods_docstring\r\n                    ):\r\n                        function_name: str = class_node.name\r\n                        new_docstring_node = make_docstring_node(\r\n                            methods_docstrings[function_name]\r\n                        )\r\n                        class_node.body.insert(0, new_docstring_node)\r\n        return node\r\n"}
{"image_path": "data\\train\\00501.png", "code": "from typing import List, Optional\r\n\r\nfrom pydantic import BaseModel, Field\r\n\r\n\r\nclass Config(BaseModel):\r\n    path: set[str] = Field(description='The path to the source code directory')\r\n    overwrite_function_docstring: Optional[bool] = Field(\r\n        description='Whether or not to overwrite the existing function docstring',\r\n        default=False,\r\n    )\r\n    overwrite_class_docstring: Optional[bool] = Field(\r\n        description='Whether or not to overwrite the existing class docstring',\r\n        default=False,\r\n    )\r\n    overwrite_class_methods_docstring: Optional[bool] = Field(\r\n        description='Whether or not to overwrite the existing class methods docstring',\r\n        default=False,\r\n    )\r\n    documentation_style: Optional[str] = Field(\r\n        description='The format of documentation to use',\r\n        default='Numpy-Style',\r\n        enum=['Numpy-Style', 'Google-Style', 'Sphinx-Style'],\r\n    )\r\n    directories_ignore: set[str] = Field(\r\n        description='Directories to ignore',\r\n        default={'venv', '.venv', '__pycache__', '.git', 'build', 'dist', 'docs'},\r\n    )\r\n    files_ignore: set[str] = Field(\r\n        description='Files to ignore',\r\n        default_factory=set,\r\n    )\r\n"}
{"image_path": "data\\train\\00502.png", "code": "import ast\r\nfrom queue import Empty, Queue\r\n\r\nfrom .config import Config\r\nfrom .docstring_writer import ClassDocStringWriter, FunctionDocStringWriter\r\nfrom .helpers import (\r\n    format_file,\r\n    get_class_source,\r\n    get_functions_source,\r\n    get_module_source_code,\r\n    save_processed_file,\r\n)\r\n\r\n\r\ndef queue_unprocessed_functions_methods(\r\n    functions_source_queue: Queue, classes_source_queue: Queue, module_path_queue: Queue\r\n) -> None:\r\n    while True:\r\n        try:\r\n            module_path: str = module_path_queue.get()\r\n            functions: list[str] = get_functions_source(module_path)\r\n            for function_name, function_code in functions:\r\n                functions_source_queue.put((module_path, function_name, function_code))\r\n            classes: list[str] = get_class_source(module_path)\r\n            for class_name, class_code in classes:\r\n                classes_source_queue.put((module_path, class_name, class_code))\r\n        except Empty:\r\n            continue\r\n        else:\r\n            module_path_queue.task_done()\r\n\r\n\r\ndef generate_function_docstrings(functions_source_queue: Queue, config: Config) -> None:\r\n    \"\"\"Generate docstrings for this file.\"\"\"\r\n    while True:\r\n        try:\r\n            module_path, function_name, function_code = functions_source_queue.get()\r\n            module_tree = ast.parse(get_module_source_code(module_path))\r\n            transformer = FunctionDocStringWriter(\r\n                module_path=module_path,\r\n"}
{"image_path": "data\\train\\00503.png", "code": "                function_name=function_name,\r\n                function_code=function_code,\r\n                config=config,\r\n            )\r\n            new_tree = transformer.visit(module_tree)\r\n            ast.fix_missing_locations(new_tree)\r\n            new_module_code = ast.unparse(new_tree)\r\n        except Empty:\r\n            continue\r\n        except Exception as e:\r\n            print(e)\r\n            functions_source_queue.task_done()\r\n            continue\r\n        else:\r\n            save_processed_file(\r\n                file_path=module_path, processed_module_code=new_module_code\r\n            )\r\n            format_file(module_path)\r\n            functions_source_queue.task_done()\r\n\r\ndef generate_class_docstrings(class_source_queue: Queue, config: Config) -> None:\r\n    \"\"\"Generate docstrings for this file.\"\"\"\r\n    while True:\r\n        try:\r\n            module_path, class_name, class_code = class_source_queue.get()\r\n            module_tree = ast.parse(get_module_source_code(module_path))\r\n            transformer = ClassDocStringWriter(\r\n                module_path=module_path,\r\n                class_name=class_name,\r\n                class_code=class_code,\r\n                config=config,\r\n            )\r\n            new_tree = transformer.visit(module_tree)\r\n            ast.fix_missing_locations(new_tree)\r\n            new_module_code = ast.unparse(new_tree)\r\n        except Empty:\r\n            continue\r\n        except Exception as e:\r\n            print(e)\r\n            class_source_queue.task_done()\r\n"}
{"image_path": "data\\train\\00504.png", "code": "            continue\r\n        else:\r\n            save_processed_file(\r\n                file_path=module_path, processed_module_code=new_module_code\r\n            )\r\n            format_file(module_path)\r\n            class_source_queue.task_done()\r\n"}
{"image_path": "data\\train\\00505.png", "code": "from langchain.prompts import PromptTemplate\r\n\r\nfrom .config import Config\r\n\r\n\r\ndef get_function_prompt_template(function_code: str, config: Config) -> str:\r\n    function_prompt_template: str = \"\"\"\r\n    Generate python docstring for the given python function using the provided documentation style:\r\n    Function code: {function_code}\r\n    Documentation style: {documentation_style}\r\n    \"\"\"\r\n    prompt = PromptTemplate.from_template(template=function_prompt_template)\r\n    prompt_formatted_str: str = prompt.format(\r\n        function_code=function_code, documentation_style=config.documentation_style\r\n    )\r\n    return prompt_formatted_str\r\n\r\n\r\ndef get_class_prompt_template(class_code: str, config: Config) -> str:\r\n    function_prompt_template: str = \"\"\"\r\n    Generate python docstring for the given python class using the provided documentation style:\r\n    Class code: {class_code}\r\n    Documentation style: {documentation_style}\r\n    \"\"\"\r\n    prompt = PromptTemplate.from_template(template=function_prompt_template)\r\n    prompt_formatted_str: str = prompt.format(\r\n        class_code=class_code, documentation_style=config.documentation_style\r\n    )\r\n    return prompt_formatted_str\r\n"}
{"image_path": "data\\train\\00506.png", "code": "from queue import Queue\r\n\r\nfrom langchain_openai import OpenAI\r\n\r\nmodules_path_queue: Queue = Queue()\r\nfunctions_source_code_queue: Queue = Queue()\r\nclass_source_code_queue: Queue = Queue()\r\nfailed_modules_queue: Queue = Queue()\r\nllm = OpenAI(temperature=0)\r\n"}
{"image_path": "data\\train\\00507.png", "code": "from queue import Queue\r\nfrom threading import Thread\r\n\r\nfrom .config import Config\r\nfrom .file_processor import (\r\n    generate_function_docstrings,\r\n    queue_unprocessed_functions_methods,\r\n    generate_class_docstrings,\r\n)\r\nfrom .helpers import get_all_modules\r\n\r\n\r\ndef generate_docstrings(\r\n    config: Config,\r\n    module_path_queue: Queue,\r\n    functions_source_queue: Queue,\r\n    class_source_queue: Queue,\r\n    failed_modules_queue: Queue,\r\n) -> None:\r\n    \"\"\"Generate docstrings for classes and methods.\"\"\"\r\n    queue_modules: Thread = Thread(\r\n        target=get_all_modules,\r\n        name='get_all_modules',\r\n        args=(config, module_path_queue),\r\n    )\r\n    queue_modules.start()\r\n\r\n    for _ in range(1):\r\n        get_functions_source_thread: Thread = Thread(\r\n            target=queue_unprocessed_functions_methods,\r\n            args=(functions_source_queue, class_source_queue, module_path_queue),\r\n            daemon=True,\r\n        )\r\n        get_functions_source_thread.start()\r\n\r\n    for _ in range(1):\r\n        generate_functions_docstring_thread: Thread = Thread(\r\n            target=generate_function_docstrings,\r\n            args=(functions_source_queue, config),\r\n            daemon=True,\r\n"}
{"image_path": "data\\train\\00508.png", "code": "        )\r\n        generate_functions_docstring_thread.start()\r\n\r\n    for _ in range(1):\r\n        generate_class_docstring_thread: Thread = Thread(\r\n            target=generate_class_docstrings,\r\n            args=(class_source_queue, config),\r\n            daemon=True,\r\n        )\r\n        generate_class_docstring_thread.start()\r\n\r\n    queue_modules.join()\r\n    module_path_queue.join()\r\n    functions_source_queue.join()\r\n    class_source_queue.join()\r\n"}
{"image_path": "data\\train\\00509.png", "code": "import ast\r\nimport os\r\nimport subprocess\r\nfrom argparse import ArgumentParser, Namespace\r\nfrom ast import AsyncFunctionDef, ClassDef, Constant, Expr, FunctionDef\r\nfrom collections import deque\r\nfrom os import listdir, path\r\nfrom queue import Queue\r\nfrom typing import Iterator\r\n\r\nfrom langchain.prompts import PromptTemplate\r\n\r\nfrom .config import Config\r\nfrom .extensions import llm\r\nfrom .templates import get_function_prompt_template, get_class_prompt_template\r\n\r\n\r\ndef generate_function_docstring(function_code: str, config: Config) -> str:\r\n    prompt_formatted_str: str = get_function_prompt_template(\r\n        function_code=function_code, config=config\r\n    )\r\n    function_and_docstring = llm.invoke(prompt_formatted_str)\r\n    return function_and_docstring\r\n\r\n\r\ndef generate_class_docstring(class_code: str, config: Config) -> str:\r\n    prompt_formatted_str: str = get_class_prompt_template(\r\n        class_code=class_code, config=config\r\n    )\r\n    class_and_docstring = llm.invoke(prompt_formatted_str)\r\n    return class_and_docstring\r\n\r\n\r\ndef get_class_docstring(class_and_docstring: str) -> str:\r\n    \"\"\"Get the class docstring.\"\"\"\r\n    class_tree = ast.parse(class_and_docstring)\r\n    for node in class_tree.body:\r\n        if isinstance(node, ClassDef):\r\n            cls_docstring: str = ast.get_docstring(node)\r\n            return cls_docstring\r\n"}
{"image_path": "data\\train\\00510.png", "code": "\r\n\r\ndef get_class_methods_docstrings(class_and_docstring: str) -> dict[str, str]:\r\n    \"\"\"Get a class methods docstrings.\"\"\"\r\n    class_methods: dict[str, str] = {}\r\n    class_tree = ast.parse(class_and_docstring)\r\n    for node in class_tree.body:\r\n        if isinstance(node, ClassDef):\r\n            for class_node in node.body:\r\n                if isinstance(class_node, FunctionDef):\r\n                    class_methods[class_node.name] = ast.get_docstring(class_node)\r\n    return class_methods\r\n\r\n\r\ndef make_docstring_node(docstr: str):\r\n    constant_str: Constant = Constant(docstr)\r\n    return Expr(value=constant_str)\r\n\r\n\r\ndef get_function_docstring(function_and_docstring: str) -> str:\r\n    \"\"\"Get the function docstring.\"\"\"\r\n    function_tree = ast.parse(function_and_docstring)\r\n    for node in function_tree.body:\r\n        if isinstance(node, (FunctionDef, AsyncFunctionDef)):\r\n            function_docstring: str = ast.get_docstring(node)\r\n            return function_docstring\r\n\r\n\r\ndef get_module_source_code(module_path: str) -> str:\r\n    \"\"\"Get the source code for a given module.\"\"\"\r\n    with open(module_path, 'r') as f:\r\n        return f.read()\r\n\r\n\r\ndef add_module_code_to_queue(module_path: str, module_source_queue: Queue):\r\n    module_src: str = ''\r\n    if module_path:\r\n        module_src = get_module_source_code(module_path)\r\n    module_source_queue.put((module_path, module_src))\r\n\r\n"}
{"image_path": "data\\train\\00511.png", "code": "\r\ndef add_module_to_queue(module_path: str, module_path_queue: Queue):\r\n    module_path_queue.put(module_path)\r\n\r\n\r\ndef get_node_source(node, module_src: str) -> str:\r\n    return ast.get_source_segment(source=module_src, node=node)\r\n\r\n\r\ndef get_functions_source(module_path: str) -> list[str]:\r\n    functions_src: list[str] = []\r\n    module_src = get_module_source_code(module_path)\r\n    module_tree = ast.parse(module_src)\r\n    for node in module_tree.body:\r\n        if isinstance(node, FunctionDef):\r\n            function_src: str = get_node_source(node=node, module_src=module_src)\r\n            functions_src.append((node.name, function_src))\r\n    return functions_src\r\n\r\n\r\ndef get_class_source(module_path: str) -> None:\r\n    class_src: list[str] = []\r\n    module_src = get_module_source_code(module_path)\r\n    module_tree = ast.parse(module_src)\r\n    for node in module_tree.body:\r\n        if isinstance(node, ClassDef):\r\n            classsrc: str = get_node_source(node=node, module_src=module_src)\r\n            class_src.append((node.name, classsrc))\r\n    return class_src\r\n\r\n\r\nclass DirectoryIterator:\r\n    def __init__(self, config: Config):\r\n        self.config: Config = config\r\n        self.queue: deque[str] = deque(self.config.path)\r\n\r\n    def __iter__(self) -> Iterator:\r\n        return self\r\n\r\n    def __next__(self) -> list[str]:\r\n"}
{"image_path": "data\\train\\00512.png", "code": "from dotenv import load_dotenv\r\nload_dotenv()\r\nimport chainlit as cl\r\nfrom farm_agent.agents import agent\r\nfrom farm_agent.utils import load_model, evaluate_image\r\nfrom PIL import Image\r\nimport io\r\n\r\n\r\nuser_location: str = None\r\nuser_name: str = None\r\nwelcome_text: str = \"\"\"\r\nHello there. This is an application that helps farmers monitor the health level of their crops. \r\nStart by giving me your name and location, then upload an image of your crops. I will analyze it to \r\ndetermine the diasease or pest that affects it and then tell you how to deal with the pest or \r\ndisease and where to purchase pesticides or fungicides.\r\n\"\"\"\r\n\r\n@cl.on_chat_start\r\nasync def start():\r\n    cl.user_session.set(\"agent\", agent)\r\n    await cl.Message(content=welcome_text).send()\r\n    user_name = await cl.AskUserMessage(content=\"What is your name?\", timeout=120).send()\r\n    user_location = await cl.AskUserMessage(content=\"Where are you from?\", timeout=120).send()\r\n    res = await cl.AskActionMessage(\r\n        content=\"Would you like to determine if your crops are infected by a disease or by pests?\",\r\n        actions=[\r\n            cl.Action(name=\"Check for diseases\", value=\"diseases\", label=\"\u2705 Check for diseases\"),\r\n            cl.Action(name=\"Check for Pests\", value=\"pests\", label=\"\u274c Check for Pests\")\r\n        ]\r\n    ).send()\r\n    if res and res.get(\"value\") == \"diseases\":\r\n        files = None\r\n        # Wait for the user to upload a file\r\n        while files == None:\r\n            files = await cl.AskFileMessage(\r\n                content=f\"{user_name['content']}, start by uploading an image of your crop.\", \r\n                accept=[\"image/jpeg\", \"image/png\", \"image/jpg\"]\r\n            ).send()\r\n        # Decode the file\r\n"}
{"image_path": "data\\train\\00513.png", "code": "        image_file = files[0]\r\n        image_data = image_file.content # byte values of the image\r\n        image = Image.open(io.BytesIO(image_data))\r\n        model = load_model()\r\n        predicted_label, predictions = evaluate_image(image, model)\r\n        analysis_text: str = f\"\"\"\r\n            After analyzing the image you uploaded, here is what I found:\r\n            Maize Leaf Rust probability: {predictions['Maize Leaf Rust']}%\r\n            Northern Leaf Blight probability: {predictions['Northern Leaf Blight']}%\r\n            Healthy probability: {predictions['Healthy']}%\r\n            Gray Leaf Spot probability: {predictions['Gray Leaf Spot']}%\r\n            Your plant is most likely infected with {predicted_label}.\r\n            \"\"\"\r\n        elements = [\r\n            cl.Image(\r\n                name=\"image2\", display=\"inline\", content=image_data\r\n                ), \r\n            cl.Text(name=\"simple_text\", content=analysis_text, display=\"inline\", size='large')\r\n        ]\r\n        await cl.Message(content=f\"Maize image with {predicted_label}!\", elements=elements).send()\r\n        msg = cl.Message(content=\"\")\r\n        await msg.send()\r\n        await cl.sleep(1)\r\n        msg.content = agent.run('Tell me some facts about the maize disease leaf rust especially in relation to kenya.')\r\n        await msg.update()\r\n        await msg.send()\r\n        await cl.sleep(1)\r\n        msg.content = agent.run(f'Tell me some facts about the maize disease {predicted_label} especially in relation to kenya.')\r\n        await msg.update()\r\n        await msg.send()\r\n        await cl.sleep(1)\r\n        msg.content = agent.run(f'Get me aggrovets in {user_location}, Kenya')\r\n        await msg.update()\r\n        await cl.Message(content='Feel free to ask me more questions about maize plant diseases and how to deal with them.').send()\r\n    else:\r\n        await cl.Message(content='Currently cannot detect pests. Still working on that model.').send()\r\n    \r\n\r\n@cl.on_message\r\nasync def main(message: cl.Message):\r\n"}
{"image_path": "data\\train\\00514.png", "code": "    agent = cl.user_session.get(\"agent\")\r\n    msg = cl.Message(content=\"\")\r\n    await msg.send()\r\n    await cl.sleep(1)\r\n    msg.content = agent.invoke({\"input\": message.content})[\"output\"]\r\n    await msg.update()"}
{"image_path": "data\\train\\00515.png", "code": "from dotenv import load_dotenv\r\nload_dotenv()\r\nimport chainlit as cl\r\n\r\nfrom calendar_assistant.usecases.agent import agent_executor\r\n\r\n\r\n@cl.on_message\r\nasync def main(message: cl.Message):\r\n    msg = cl.Message(content=\"\")\r\n    await msg.send()\r\n    await cl.sleep(1)\r\n    msg.content = agent_executor.invoke({\"input\": message.content})['output']\r\n    await msg.update()"}
{"image_path": "data\\train\\00516.png", "code": "from dotenv import load_dotenv\r\nload_dotenv()\r\nimport chainlit as cl\r\nfrom farm_agent.agents import agent\r\nfrom farm_agent.utils import load_model, evaluate_image\r\nfrom PIL import Image\r\nimport io\r\n\r\n\r\nuser_location: str = None\r\nuser_name: str = None\r\nwelcome_text: str = \"\"\"\r\nHello there. This is an application that helps farmers monitor the health level of their crops. \r\nStart by giving me your name and location, then upload an image of your crops. I will analyze it to \r\ndetermine the diasease or pest that affects it and then tell you how to deal with the pest or \r\ndisease and where to purchase pesticides or fungicides.\r\n\"\"\"\r\n\r\n@cl.on_chat_start\r\nasync def start():\r\n    cl.user_session.set(\"agent\", agent)\r\n    await cl.Message(content=welcome_text).send()\r\n    user_name = await cl.AskUserMessage(content=\"What is your name?\", timeout=120).send()\r\n    user_location = await cl.AskUserMessage(content=\"Where are you from?\", timeout=120).send()\r\n    res = await cl.AskActionMessage(\r\n        content=\"Would you like to determine if your crops are infected by a disease or by pests?\",\r\n        actions=[\r\n            cl.Action(name=\"Check for diseases\", value=\"diseases\", label=\"\u2705 Check for diseases\"),\r\n            cl.Action(name=\"Check for Pests\", value=\"pests\", label=\"\u274c Check for Pests\")\r\n        ]\r\n    ).send()\r\n    if res and res.get(\"value\") == \"diseases\":\r\n        files = None\r\n        # Wait for the user to upload a file\r\n        while files == None:\r\n            files = await cl.AskFileMessage(\r\n                content=f\"{user_name['content']}, start by uploading an image of your crop.\", \r\n                accept=[\"image/jpeg\", \"image/png\", \"image/jpg\"]\r\n            ).send()\r\n        # Decode the file\r\n"}
{"image_path": "data\\train\\00517.png", "code": "        image_file = files[0]\r\n        image_data = image_file.content # byte values of the image\r\n        image = Image.open(io.BytesIO(image_data))\r\n        model = load_model()\r\n        predicted_label, predictions = evaluate_image(image, model)\r\n        analysis_text: str = f\"\"\"\r\n            After analyzing the image you uploaded, here is what I found:\r\n            Maize Leaf Rust probability: {predictions['Maize Leaf Rust']}%\r\n            Northern Leaf Blight probability: {predictions['Northern Leaf Blight']}%\r\n            Healthy probability: {predictions['Healthy']}%\r\n            Gray Leaf Spot probability: {predictions['Gray Leaf Spot']}%\r\n            Your plant is most likely infected with {predicted_label}.\r\n            \"\"\"\r\n        elements = [\r\n            cl.Image(\r\n                name=\"image2\", display=\"inline\", content=image_data\r\n                ), \r\n            cl.Text(name=\"simple_text\", content=analysis_text, display=\"inline\", size='large')\r\n        ]\r\n        await cl.Message(content=f\"Maize image with {predicted_label}!\", elements=elements).send()\r\n        msg = cl.Message(content=\"\")\r\n        await msg.send()\r\n        await cl.sleep(1)\r\n        msg.content = agent.run(f'Tell me some facts about the maize disease {predicted_label} especially in relation to kenya.')\r\n        await msg.update()\r\n        await msg.send()\r\n        await cl.sleep(1)\r\n        msg.content = agent.run(f'What fungicides or pesticides can be used to deal with the maize disease {predicted_label}?')\r\n        await msg.update()\r\n        await msg.send()\r\n        await cl.sleep(1)\r\n        msg.content = agent.run(f'Get me aggrovets in {user_location}, Kenya')\r\n        await msg.update()\r\n        await cl.Message(content='Feel free to ask me more questions about maize plant diseases and how to deal with them.').send()\r\n    else:\r\n        await cl.Message(content='Currently cannot detect pests. Still working on that model.').send()\r\n    \r\n\r\n@cl.on_message\r\nasync def main(message: cl.Message):\r\n"}
{"image_path": "data\\train\\00518.png", "code": "    agent = cl.user_session.get(\"agent\")\r\n    msg = cl.Message(content=\"\")\r\n    await msg.send()\r\n    await cl.sleep(1)\r\n    msg.content = agent.invoke({\"input\": message.content})[\"output\"]\r\n    await msg.update()"}
{"image_path": "data\\train\\00519.png", "code": "import chainlit as cl\r\nfrom assistant.utils.assistant_utils import welcome_user\r\nfrom assistant.agent import get_agent_executor\r\n\r\n\r\n@cl.on_chat_start\r\nasync def start():\r\n    res = await cl.AskUserMessage(content=\"What is your name?\", timeout=30).send()\r\n    if res:\r\n        msg = cl.Message(content=\"\")\r\n        await msg.send()\r\n        msg.content = welcome_user(user_name=res['content'])\r\n        await msg.update()\r\n        \r\n\r\n@cl.on_message\r\nasync def main(message: cl.Message):\r\n    msg = cl.Message(content=\"\")\r\n    await msg.send()\r\n    query: str = message.content\r\n    agent_executor = get_agent_executor(query)\r\n    msg.content = agent_executor.invoke({\"input\": query})['output']\r\n    await msg.update()"}
{"image_path": "data\\train\\00520.png", "code": "from dotenv import load_dotenv\r\nload_dotenv()\r\n# from assistant.utils.channel_utils import get_channel_latest_video, get_favorite_channels_latest_videos\r\n# from assistant.utils.playlist_utils import add_video_to_youtube_playlist\r\nfrom assistant.agent import get_agent_executor\r\n# from assistant.tools.playlist.helpers import list_playlist_videos\r\n# from assistant.tools.comment.helpers import list_video_comments\r\nfrom assistant.agent import get_tools\r\nfrom assistant.tools.comment.helpers import (\r\n    list_video_comments, find_my_comments, find_author_comments, list_comment_replies\r\n)\r\nfrom assistant.tools.channel.helpers import find_my_youtube_username\r\n\r\ntitle: str = 'Real Engineering'\r\n# print(get_favorite_channels_latest_videos())\r\n# title: str = 'How Nebula Works from Real Engineering'\r\n# playlist: str = 'Daily Videos'\r\n# add_video_to_youtube_playlist(title, playlist)\r\n# query = 'When was the youtube channel Ark Invest created?'\r\n# print(agent_executor.invoke({\"input\": query})['output'])\r\n# print(list_playlist_videos(title, title))\r\n#PLx7ERghZ6LoOKkmL4oeLoqWousfkKpdM_\r\n# print(list_video_comments('How Nebula Works', max_results=10))\r\n# query = 'When was my youtube channel created?'\r\n# agent_executor = get_agent_executor()\r\n# print(agent_executor.invoke({\"input\": query})['output'])\r\n# tools = get_tools(query)\r\n# print(len(tools))\r\n# t = [tool.description for tool in tools]\r\n# print(t)\r\n# print(find_author_comments('Trapping Rain Water - Google Interview Question - Leetcode 42', '@NeetCode'))\r\n\r\nquery = \"List all the replies to the comments by neetcode on the video titled 'Trapping Rain Water - Google Interview Question - Leetcode 42'\"\r\nagent_executor = get_agent_executor()\r\nprint(agent_executor.invoke({\"input\": query})['output'])\r\n# print(list_comment_replies('neetcode', 'Trapping Rain Water - Google Interview Question - Leetcode 42'))"}
{"image_path": "data\\train\\00521.png", "code": "from os import path\r\nimport json\r\nfrom random import choices, choice\r\nfrom langchain.docstore.document import Document\r\nimport re\r\nfrom langchain.prompts import PromptTemplate\r\nfrom langchain_openai import OpenAI\r\nfrom langchain.pydantic_v1 import BaseModel, Field\r\nfrom langchain.output_parsers import PydanticOutputParser\r\nfrom langchain_core.runnables import RunnableBranch\r\nfrom langchain_core.output_parsers import StrOutputParser\r\n\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\nllm = OpenAI(temperature=0, api_key=api_key)\r\nfile_path: str = \"comments.json\"\r\n\r\n\r\ndef lower(text: str) -> str:\r\n    return text.lower().strip()\r\n\r\n\r\ndef remove_urls(text: str) -> str:\r\n    url_pattern = r\"https?://\\S+|www\\.\\S+\"\r\n    text = re.sub(url_pattern, \"\", text)\r\n    return text\r\n\r\n\r\ndef remove_punctuations(text: str) -> str:\r\n    punctuation_pattern = r\"[^\\w\\s]\"\r\n    cleaned = re.sub(punctuation_pattern, \"\", text)\r\n    return cleaned\r\n\r\n\r\ndef clean_text(text: str) -> str:\r\n    text = lower(text)\r\n    text = remove_urls(text)\r\n    text = remove_punctuations(text)\r\n    return text\r\n\r\n"}
{"image_path": "data\\train\\00522.png", "code": "\r\ndef is_acceptable_len(text: str, l: int = 20) -> bool:\r\n    return len(text.split()) >= l\r\n\r\n\r\nwith open(file_path, \"r\", encoding=\"utf-8\") as f:\r\n    all_comments: list[str] = json.load(fp=f)\r\n    cleaned_comments: list[str] = list(map(clean_text, all_comments))\r\n    comments: list[str] = choices(population=cleaned_comments, k=10)\r\n    docs: list[Document] = [\r\n        Document(page_content=comment)\r\n        for comment in comments\r\n        if is_acceptable_len(comment)\r\n    ]\r\n    comments: list[dict[str, str | int]] = [\r\n        {\"doc_id\": i + 1, \"comment\": docs[i].page_content} for i in range(len(docs))\r\n    ]\r\n\r\ndata_dir = \"./agent_nelly/data_analysis/data\"\r\nfeatures_dir = \"features\"\r\nsave_features_dir = path.join(data_dir, features_dir, \"features.json\")\r\n\r\nwith open(save_features_dir, 'r') as f:\r\n    topics: list[str] = json.load(f)\r\n\r\ncomment: dict = choice(comments)\r\n\r\n\r\nsentiment_msg: str = \"\"\"\r\nBelow is a customer comment in JSON format with the following keys:\r\n1. doc_id - identifier of the comment\r\n2. comment - the user comment\r\n\r\nPlease analyze the comment and identify the sentiment. The sentiment can be negative, neutral or \r\npositive. Only return a single string, the sentiment.\r\n\r\nComment:\r\n```\r\n{comment}\r\n```\r\n"}
{"image_path": "data\\train\\00523.png", "code": "\"\"\"\r\n\r\nsentiment_template = PromptTemplate(template=sentiment_msg, input_variables=[\"comment\"])\r\n\r\n\r\nclass PositiveComment(BaseModel):\r\n    doc_id: int = Field(description=\"The doc_id from the input\")\r\n    topics: list[str] = Field(\r\n        description=\"List of the relevant topics for the customer review. Include only topics from the list provided.\",\r\n        default_factory=list,\r\n    )\r\n    sentiment: str = Field(\r\n        description=\"Sentiment of the topic\", enum=[\"positive\", \"neutral\", \"negative\"]\r\n    )\r\n\r\n\r\nclass NegativeComment(BaseModel):\r\n    doc_id: int = Field(description=\"The doc_id from the input\")\r\n    topics: list[str] = Field(\r\n        description=\"List of the relevant topics for the customer review. Include only topics from the list provided.\",\r\n        default_factory=list,\r\n    )\r\n    sentiment: str = Field(\r\n        description=\"Sentiment of the topic\", enum=[\"positive\", \"neutral\", \"negative\"]\r\n    )\r\n\r\n\r\npositive_parser = PydanticOutputParser(pydantic_object=PositiveComment)\r\nnegative_parser = PydanticOutputParser(pydantic_object=NegativeComment)\r\n\r\ntopic_assg_msg: str = \"\"\"\r\nBelow is a customer comment in JSON format with the following keys:\r\n1. doc_id - identifier of the comment\r\n2. comment - the user comment\r\n\r\nPlease analyze the provided comments and identify the main topics and sentiment. Include only the \r\ntopics provided below:\r\nTopics with a short description: {topics}\r\n\r\nComment:\r\n"}
{"image_path": "data\\train\\00524.png", "code": "```\r\n{comment}\r\n```\r\n\r\n{format_instructions}\r\n\"\"\"\r\n\r\npositive_tmpl = PromptTemplate(\r\n    template=topic_assg_msg,\r\n    input_variables=[\"comment\", \"topics\"],\r\n    partial_variables={\r\n        \"format_instructions\": positive_parser.get_format_instructions()\r\n    },\r\n)\r\n\r\nnegative_tmpl = PromptTemplate(\r\n    template=topic_assg_msg,\r\n    input_variables=[\"comment\", \"topics\"],\r\n    partial_variables={\r\n        \"format_instructions\": negative_parser.get_format_instructions()\r\n    },\r\n)\r\n\r\nsentiment_chain = sentiment_template | llm | StrOutputParser()\r\npos_chain = positive_tmpl | llm | positive_parser\r\nneg_chain = negative_tmpl | llm | negative_parser\r\n\r\n# res = sentiment_chain.invoke({\"comment\": comment})\r\n# print(res, comment)\r\n# if 'positive' in res.lower():\r\n#     res = pos_chain.invoke({\"comment\": comment, 'topics': topics})\r\n# elif 'negative' in res.lower():\r\n#     res = neg_chain.invoke({\"comment\": comment, 'topics': topics})\r\n# print(res)\r\n\r\nbranch = RunnableBranch(\r\n    (lambda input: 'positive' in input['sentiment'].lower(), pos_chain),\r\n    neg_chain\r\n)\r\n\r\n"}
{"image_path": "data\\train\\00525.png", "code": "full_chain = {\r\n    \"sentiment\": sentiment_chain,\r\n    \"comment\": lambda input: input['comment'],\r\n    \"topics\": lambda input: input['topics']\r\n} | branch\r\n\r\nres = full_chain.invoke({'comment': comment, \"topics\": topics})\r\nprint(comment)\r\nprint(res)\r\n"}
{"image_path": "data\\train\\00526.png", "code": "from langchain.chains import RetrievalQA\r\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\r\nfrom langchain.vectorstores.faiss import FAISS\r\nfrom langchain.vectorstores.chroma import Chroma\r\nfrom langchain_openai import ChatOpenAI, OpenAIEmbeddings\r\nfrom langchain.docstore.document import Document\r\nfrom langchain.prompts import PromptTemplate\r\nfrom os import path\r\nimport json\r\nfrom random import choices\r\n\r\ndata_dir = \"data\"\r\nvideo_data_dir = \"data\"\r\ntranscribed_data = \"transcriptions\"\r\nvideo_title = \"iphone_15_marques_review\"\r\nsave_video_dir = path.join(data_dir, video_data_dir, video_title)\r\nsave_transcript_dir = path.join(data_dir, transcribed_data, video_title + \".txt\")\r\npersist_directory = path.join(data_dir, \"vectore_store\")\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\nfile_path: str = \"comments.json\"\r\n\r\nwith open(file_path, \"r\", encoding=\"utf-8\") as f:\r\n    all_comments: list[str] = json.load(fp=f)\r\n    comments: list[str] = choices(population=all_comments, k=50)\r\n    comments: list[Document] = [Document(page_content=comment) for comment in all_comments]\r\n\r\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=200, chunk_overlap=30)\r\nsplit_docs = text_splitter.split_documents(comments)\r\n\r\nembeddings = OpenAIEmbeddings(api_key=api_key)\r\n# vectordb = FAISS.from_texts(splits, embeddings)\r\n# vectordb = FAISS.from_documents(documents=comments, embedding=embeddings)\r\n# vectordb = Chroma.from_documents(\r\n#     documents=split_docs,\r\n#     embedding=embeddings,\r\n#     persist_directory=persist_directory\r\n# )\r\n\r\ntemplate_str: str = \"\"\"\r\n"}
{"image_path": "data\\train\\00527.png", "code": "You are given the comments by various users on the review of {product}. Use the comments to answer \r\nthe questions that follow. When answering questions, try to list out your answer, with each answer \r\non its own separate line. If you do not know the answer, just say that you do not know. DO NOT MAKE \r\nSTUFF UP.\r\n---------\r\n{context}\r\nQuestion: {question}\r\nHelpful answer: \r\n\"\"\"\r\n\r\nproduct: str = \"iphone 15 pro max\"\r\ntemplate = PromptTemplate.from_template(template_str)\r\ntemplate = template.partial(product=product)\r\n\r\nvectordb = Chroma(\r\n    persist_directory=persist_directory,\r\n    embedding_function=embeddings\r\n)\r\n\r\nqa_chain = RetrievalQA.from_chain_type(\r\n    llm=ChatOpenAI(model_name=\"gpt-3.5-turbo\", temperature=0, api_key=api_key),\r\n    chain_type=\"stuff\",\r\n    return_source_documents=True,\r\n    retriever=vectordb.as_retriever(search_kwargs={\"k\": 10}),\r\n    chain_type_kwargs={\"prompt\": template}\r\n)\r\n\r\nwhile True:\r\n    query = input(\"User: \")\r\n    res = qa_chain.invoke(query)\r\n    print(res[\"result\"])"}
{"image_path": "data\\train\\00528.png", "code": "from langchain.output_parsers import PydanticOutputParser\r\nfrom langchain.pydantic_v1 import Field, BaseModel\r\nfrom langchain.prompts import PromptTemplate\r\nfrom langchain_openai import OpenAI\r\nimport re\r\nimport json\r\nfrom langchain.docstore.document import Document\r\nfrom random import choices\r\nfrom langchain.base_language import BaseLanguageModel\r\n\r\nfile_path: str = \"comments.json\"\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\n\r\n\r\ndef lower(text: str) -> str:\r\n    return text.lower().strip()\r\n\r\n\r\ndef remove_urls(text: str) -> str:\r\n    url_pattern = r\"https?://\\S+|www\\.\\S+\"\r\n    text = re.sub(url_pattern, \"\", text)\r\n    return text\r\n\r\n\r\ndef remove_punctuations(text: str) -> str:\r\n    punctuation_pattern = r\"[^\\w\\s]\"\r\n    cleaned = re.sub(punctuation_pattern, \"\", text)\r\n    return cleaned\r\n\r\n\r\ndef clean_text(text: str) -> str:\r\n    text = lower(text)\r\n    text = remove_urls(text)\r\n    text = remove_punctuations(text)\r\n    return text\r\n\r\n\r\ndef is_acceptable_len(text: str, l=15) -> bool:\r\n    return len(text.split()) >= l\r\n\r\n"}
{"image_path": "data\\train\\00529.png", "code": "from dotenv import load_dotenv\r\nload_dotenv()\r\nimport chainlit as cl\r\nfrom farm_agent.agents import agent\r\nfrom farm_agent.utils import load_model, evaluate_image\r\nfrom PIL import Image\r\nimport io\r\n\r\n\r\nuser_location: str = None\r\nuser_name: str = None\r\nwelcome_text: str = \"\"\"\r\nHello there. This is an application that helps farmers monitor the health level of their crops. \r\nStart by giving me your name and location, then upload an image of your crops. I will analyze it to \r\ndetermine the diasease or pest that affects it and then tell you how to deal with the pest or \r\ndisease and where to purchase pesticides or fungicides.\r\n\"\"\"\r\n\r\n@cl.on_chat_start\r\nasync def start():\r\n    cl.user_session.set(\"agent\", agent)\r\n    await cl.Message(content=welcome_text).send()\r\n    user_name = await cl.AskUserMessage(content=\"What is your name?\", timeout=120).send()\r\n    user_location = await cl.AskUserMessage(content=\"Where are you from?\", timeout=120).send()\r\n    res = await cl.AskActionMessage(\r\n        content=\"Would you like to determine if your crops are infected by a disease or by pests?\",\r\n        actions=[\r\n            cl.Action(name=\"Check for diseases\", value=\"diseases\", label=\"\u2705 Check for diseases\"),\r\n            cl.Action(name=\"Check for Pests\", value=\"pests\", label=\"\u274c Check for Pests\")\r\n        ]\r\n    ).send()\r\n    if res and res.get(\"value\") == \"diseases\":\r\n        files = None\r\n        # Wait for the user to upload a file\r\n        while files == None:\r\n            files = await cl.AskFileMessage(\r\n                content=f\"{user_name['content']}, start by uploading an image of your crop.\", \r\n                accept=[\"image/jpeg\", \"image/png\", \"image/jpg\"]\r\n            ).send()\r\n        # Decode the file\r\n"}
{"image_path": "data\\train\\00530.png", "code": "        image_file = files[0]\r\n        image_data = image_file.content # byte values of the image\r\n        image = Image.open(io.BytesIO(image_data))\r\n        model = load_model()\r\n        predicted_label, predictions = evaluate_image(image, model)\r\n        analysis_text: str = f\"\"\"\r\n            After analyzing the image you uploaded, here is what I found:\r\n            Maize Leaf Rust probability: {predictions['Maize Leaf Rust']}%\r\n            Northern Leaf Blight probability: {predictions['Northern Leaf Blight']}%\r\n            Healthy probability: {predictions['Healthy']}%\r\n            Gray Leaf Spot probability: {predictions['Gray Leaf Spot']}%\r\n            Your plant is most likely infected with {predicted_label}.\r\n            \"\"\"\r\n        elements = [\r\n            cl.Image(\r\n                name=\"image2\", display=\"inline\", content=image_data\r\n                ), \r\n            cl.Text(name=\"simple_text\", content=analysis_text, display=\"inline\", size='large')\r\n        ]\r\n        await cl.Message(content=f\"Maize image with {predicted_label}!\", elements=elements).send()\r\n        msg = cl.Message(content=\"\")\r\n        await msg.send()\r\n        await cl.sleep(1)\r\n        msg.content = agent.run('Tell me some facts about the maize disease leaf rust especially in relation to kenya.')\r\n        await msg.update()\r\n        await msg.send()\r\n        await cl.sleep(1)\r\n        msg.content = agent.run(f'Tell me some facts about the maize disease {predicted_label} especially in relation to kenya.')\r\n        await msg.update()\r\n        await msg.send()\r\n        await cl.sleep(1)\r\n        msg.content = agent.run(f'Get me aggrovets in {user_location}, Kenya')\r\n        await msg.update()\r\n        await cl.Message(content='Feel free to ask me more questions about maize plant diseases and how to deal with them.').send()\r\n    else:\r\n        await cl.Message(content='Currently cannot detect pests. Still working on that model.').send()\r\n    \r\n\r\n@cl.on_message\r\nasync def main(message: cl.Message):\r\n"}
{"image_path": "data\\train\\00531.png", "code": "    agent = cl.user_session.get(\"agent\")\r\n    msg = cl.Message(content=\"\")\r\n    await msg.send()\r\n    await cl.sleep(1)\r\n    msg.content = agent.invoke({\"input\": message.content})[\"output\"]\r\n    await msg.update()"}
{"image_path": "data\\train\\00532.png", "code": "from dotenv import load_dotenv\r\nload_dotenv()\r\nimport chainlit as cl\r\n\r\nfrom calendar_assistant.usecases.agent import agent_executor\r\n\r\n\r\n@cl.on_message\r\nasync def main(message: cl.Message):\r\n    msg = cl.Message(content=\"\")\r\n    await msg.send()\r\n    await cl.sleep(1)\r\n    msg.content = agent_executor.invoke({\"input\": message.content})['output']\r\n    await msg.update()"}
{"image_path": "data\\train\\00533.png", "code": "from dotenv import load_dotenv\r\nload_dotenv()\r\nimport chainlit as cl\r\nfrom farm_agent.agents import agent\r\nfrom farm_agent.utils import load_model, evaluate_image\r\nfrom PIL import Image\r\nimport io\r\n\r\n\r\nuser_location: str = None\r\nuser_name: str = None\r\nwelcome_text: str = \"\"\"\r\nHello there. This is an application that helps farmers monitor the health level of their crops. \r\nStart by giving me your name and location, then upload an image of your crops. I will analyze it to \r\ndetermine the diasease or pest that affects it and then tell you how to deal with the pest or \r\ndisease and where to purchase pesticides or fungicides.\r\n\"\"\"\r\n\r\n@cl.on_chat_start\r\nasync def start():\r\n    cl.user_session.set(\"agent\", agent)\r\n    await cl.Message(content=welcome_text).send()\r\n    user_name = await cl.AskUserMessage(content=\"What is your name?\", timeout=120).send()\r\n    user_location = await cl.AskUserMessage(content=\"Where are you from?\", timeout=120).send()\r\n    res = await cl.AskActionMessage(\r\n        content=\"Would you like to determine if your crops are infected by a disease or by pests?\",\r\n        actions=[\r\n            cl.Action(name=\"Check for diseases\", value=\"diseases\", label=\"\u2705 Check for diseases\"),\r\n            cl.Action(name=\"Check for Pests\", value=\"pests\", label=\"\u274c Check for Pests\")\r\n        ]\r\n    ).send()\r\n    if res and res.get(\"value\") == \"diseases\":\r\n        files = None\r\n        # Wait for the user to upload a file\r\n        while files == None:\r\n            files = await cl.AskFileMessage(\r\n                content=f\"{user_name['content']}, start by uploading an image of your crop.\", \r\n                accept=[\"image/jpeg\", \"image/png\", \"image/jpg\"]\r\n            ).send()\r\n        # Decode the file\r\n"}
{"image_path": "data\\train\\00534.png", "code": "        image_file = files[0]\r\n        image_data = image_file.content # byte values of the image\r\n        image = Image.open(io.BytesIO(image_data))\r\n        model = load_model()\r\n        predicted_label, predictions = evaluate_image(image, model)\r\n        analysis_text: str = f\"\"\"\r\n            After analyzing the image you uploaded, here is what I found:\r\n            Maize Leaf Rust probability: {predictions['Maize Leaf Rust']}%\r\n            Northern Leaf Blight probability: {predictions['Northern Leaf Blight']}%\r\n            Healthy probability: {predictions['Healthy']}%\r\n            Gray Leaf Spot probability: {predictions['Gray Leaf Spot']}%\r\n            Your plant is most likely infected with {predicted_label}.\r\n            \"\"\"\r\n        elements = [\r\n            cl.Image(\r\n                name=\"image2\", display=\"inline\", content=image_data\r\n                ), \r\n            cl.Text(name=\"simple_text\", content=analysis_text, display=\"inline\", size='large')\r\n        ]\r\n        await cl.Message(content=f\"Maize image with {predicted_label}!\", elements=elements).send()\r\n        msg = cl.Message(content=\"\")\r\n        await msg.send()\r\n        await cl.sleep(1)\r\n        msg.content = agent.run(f'Tell me some facts about the maize disease {predicted_label} especially in relation to kenya.')\r\n        await msg.update()\r\n        await msg.send()\r\n        await cl.sleep(1)\r\n        msg.content = agent.run(f'What fungicides or pesticides can be used to deal with the maize disease {predicted_label}?')\r\n        await msg.update()\r\n        await msg.send()\r\n        await cl.sleep(1)\r\n        msg.content = agent.run(f'Get me aggrovets in {user_location}, Kenya')\r\n        await msg.update()\r\n        await cl.Message(content='Feel free to ask me more questions about maize plant diseases and how to deal with them.').send()\r\n    else:\r\n        await cl.Message(content='Currently cannot detect pests. Still working on that model.').send()\r\n    \r\n\r\n@cl.on_message\r\nasync def main(message: cl.Message):\r\n"}
{"image_path": "data\\train\\00535.png", "code": "    agent = cl.user_session.get(\"agent\")\r\n    msg = cl.Message(content=\"\")\r\n    await msg.send()\r\n    await cl.sleep(1)\r\n    msg.content = agent.invoke({\"input\": message.content})[\"output\"]\r\n    await msg.update()"}
{"image_path": "data\\train\\00536.png", "code": "import chainlit as cl\r\nfrom assistant.utils.assistant_utils import welcome_user\r\nfrom assistant.agent import get_agent_executor\r\n\r\n\r\n@cl.on_chat_start\r\nasync def start():\r\n    res = await cl.AskUserMessage(content=\"What is your name?\", timeout=30).send()\r\n    if res:\r\n        msg = cl.Message(content=\"\")\r\n        await msg.send()\r\n        msg.content = welcome_user(user_name=res['content'])\r\n        await msg.update()\r\n        \r\n\r\n@cl.on_message\r\nasync def main(message: cl.Message):\r\n    msg = cl.Message(content=\"\")\r\n    await msg.send()\r\n    query: str = message.content\r\n    agent_executor = get_agent_executor(query)\r\n    msg.content = agent_executor.invoke({\"input\": query})['output']\r\n    await msg.update()"}
{"image_path": "data\\train\\00537.png", "code": "from dotenv import load_dotenv\r\nload_dotenv()\r\n# from assistant.utils.channel_utils import get_channel_latest_video, get_favorite_channels_latest_videos\r\n# from assistant.utils.playlist_utils import add_video_to_youtube_playlist\r\nfrom assistant.agent import get_agent_executor\r\n# from assistant.tools.playlist.helpers import list_playlist_videos\r\n# from assistant.tools.comment.helpers import list_video_comments\r\nfrom assistant.agent import get_tools\r\nfrom assistant.tools.comment.helpers import (\r\n    list_video_comments, find_my_comments, find_author_comments, list_comment_replies\r\n)\r\nfrom assistant.tools.channel.helpers import find_my_youtube_username\r\n\r\ntitle: str = 'Real Engineering'\r\n# print(get_favorite_channels_latest_videos())\r\n# title: str = 'How Nebula Works from Real Engineering'\r\n# playlist: str = 'Daily Videos'\r\n# add_video_to_youtube_playlist(title, playlist)\r\n# query = 'When was the youtube channel Ark Invest created?'\r\n# print(agent_executor.invoke({\"input\": query})['output'])\r\n# print(list_playlist_videos(title, title))\r\n#PLx7ERghZ6LoOKkmL4oeLoqWousfkKpdM_\r\n# print(list_video_comments('How Nebula Works', max_results=10))\r\n# query = 'When was my youtube channel created?'\r\n# agent_executor = get_agent_executor()\r\n# print(agent_executor.invoke({\"input\": query})['output'])\r\n# tools = get_tools(query)\r\n# print(len(tools))\r\n# t = [tool.description for tool in tools]\r\n# print(t)\r\n# print(find_author_comments('Trapping Rain Water - Google Interview Question - Leetcode 42', '@NeetCode'))\r\n\r\nquery = \"List all the replies to the comments by neetcode on the video titled 'Trapping Rain Water - Google Interview Question - Leetcode 42'\"\r\nagent_executor = get_agent_executor()\r\nprint(agent_executor.invoke({\"input\": query})['output'])\r\n# print(list_comment_replies('neetcode', 'Trapping Rain Water - Google Interview Question - Leetcode 42'))"}
{"image_path": "data\\train\\00538.png", "code": "from os import path\r\nimport json\r\nfrom random import choices, choice\r\nfrom langchain.docstore.document import Document\r\nimport re\r\nfrom langchain.prompts import PromptTemplate\r\nfrom langchain_openai import OpenAI\r\nfrom langchain.pydantic_v1 import BaseModel, Field\r\nfrom langchain.output_parsers import PydanticOutputParser\r\nfrom langchain_core.runnables import RunnableBranch\r\nfrom langchain_core.output_parsers import StrOutputParser\r\n\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\nllm = OpenAI(temperature=0, api_key=api_key)\r\nfile_path: str = \"comments.json\"\r\n\r\n\r\ndef lower(text: str) -> str:\r\n    return text.lower().strip()\r\n\r\n\r\ndef remove_urls(text: str) -> str:\r\n    url_pattern = r\"https?://\\S+|www\\.\\S+\"\r\n    text = re.sub(url_pattern, \"\", text)\r\n    return text\r\n\r\n\r\ndef remove_punctuations(text: str) -> str:\r\n    punctuation_pattern = r\"[^\\w\\s]\"\r\n    cleaned = re.sub(punctuation_pattern, \"\", text)\r\n    return cleaned\r\n\r\n\r\ndef clean_text(text: str) -> str:\r\n    text = lower(text)\r\n    text = remove_urls(text)\r\n    text = remove_punctuations(text)\r\n    return text\r\n\r\n"}
{"image_path": "data\\train\\00539.png", "code": "\r\ndef is_acceptable_len(text: str, l: int = 20) -> bool:\r\n    return len(text.split()) >= l\r\n\r\n\r\nwith open(file_path, \"r\", encoding=\"utf-8\") as f:\r\n    all_comments: list[str] = json.load(fp=f)\r\n    cleaned_comments: list[str] = list(map(clean_text, all_comments))\r\n    comments: list[str] = choices(population=cleaned_comments, k=10)\r\n    docs: list[Document] = [\r\n        Document(page_content=comment)\r\n        for comment in comments\r\n        if is_acceptable_len(comment)\r\n    ]\r\n    comments: list[dict[str, str | int]] = [\r\n        {\"doc_id\": i + 1, \"comment\": docs[i].page_content} for i in range(len(docs))\r\n    ]\r\n\r\ndata_dir = \"./agent_nelly/data_analysis/data\"\r\nfeatures_dir = \"features\"\r\nsave_features_dir = path.join(data_dir, features_dir, \"features.json\")\r\n\r\nwith open(save_features_dir, 'r') as f:\r\n    topics: list[str] = json.load(f)\r\n\r\ncomment: dict = choice(comments)\r\n\r\n\r\nsentiment_msg: str = \"\"\"\r\nBelow is a customer comment in JSON format with the following keys:\r\n1. doc_id - identifier of the comment\r\n2. comment - the user comment\r\n\r\nPlease analyze the comment and identify the sentiment. The sentiment can be negative, neutral or \r\npositive. Only return a single string, the sentiment.\r\n\r\nComment:\r\n```\r\n{comment}\r\n```\r\n"}
{"image_path": "data\\train\\00540.png", "code": "\"\"\"\r\n\r\nsentiment_template = PromptTemplate(template=sentiment_msg, input_variables=[\"comment\"])\r\n\r\n\r\nclass PositiveComment(BaseModel):\r\n    doc_id: int = Field(description=\"The doc_id from the input\")\r\n    topics: list[str] = Field(\r\n        description=\"List of the relevant topics for the customer review. Include only topics from the list provided.\",\r\n        default_factory=list,\r\n    )\r\n    sentiment: str = Field(\r\n        description=\"Sentiment of the topic\", enum=[\"positive\", \"neutral\", \"negative\"]\r\n    )\r\n\r\n\r\nclass NegativeComment(BaseModel):\r\n    doc_id: int = Field(description=\"The doc_id from the input\")\r\n    topics: list[str] = Field(\r\n        description=\"List of the relevant topics for the customer review. Include only topics from the list provided.\",\r\n        default_factory=list,\r\n    )\r\n    sentiment: str = Field(\r\n        description=\"Sentiment of the topic\", enum=[\"positive\", \"neutral\", \"negative\"]\r\n    )\r\n\r\n\r\npositive_parser = PydanticOutputParser(pydantic_object=PositiveComment)\r\nnegative_parser = PydanticOutputParser(pydantic_object=NegativeComment)\r\n\r\ntopic_assg_msg: str = \"\"\"\r\nBelow is a customer comment in JSON format with the following keys:\r\n1. doc_id - identifier of the comment\r\n2. comment - the user comment\r\n\r\nPlease analyze the provided comments and identify the main topics and sentiment. Include only the \r\ntopics provided below:\r\nTopics with a short description: {topics}\r\n\r\nComment:\r\n"}
{"image_path": "data\\train\\00541.png", "code": "```\r\n{comment}\r\n```\r\n\r\n{format_instructions}\r\n\"\"\"\r\n\r\npositive_tmpl = PromptTemplate(\r\n    template=topic_assg_msg,\r\n    input_variables=[\"comment\", \"topics\"],\r\n    partial_variables={\r\n        \"format_instructions\": positive_parser.get_format_instructions()\r\n    },\r\n)\r\n\r\nnegative_tmpl = PromptTemplate(\r\n    template=topic_assg_msg,\r\n    input_variables=[\"comment\", \"topics\"],\r\n    partial_variables={\r\n        \"format_instructions\": negative_parser.get_format_instructions()\r\n    },\r\n)\r\n\r\nsentiment_chain = sentiment_template | llm | StrOutputParser()\r\npos_chain = positive_tmpl | llm | positive_parser\r\nneg_chain = negative_tmpl | llm | negative_parser\r\n\r\n# res = sentiment_chain.invoke({\"comment\": comment})\r\n# print(res, comment)\r\n# if 'positive' in res.lower():\r\n#     res = pos_chain.invoke({\"comment\": comment, 'topics': topics})\r\n# elif 'negative' in res.lower():\r\n#     res = neg_chain.invoke({\"comment\": comment, 'topics': topics})\r\n# print(res)\r\n\r\nbranch = RunnableBranch(\r\n    (lambda input: 'positive' in input['sentiment'].lower(), pos_chain),\r\n    neg_chain\r\n)\r\n\r\n"}
{"image_path": "data\\train\\00542.png", "code": "full_chain = {\r\n    \"sentiment\": sentiment_chain,\r\n    \"comment\": lambda input: input['comment'],\r\n    \"topics\": lambda input: input['topics']\r\n} | branch\r\n\r\nres = full_chain.invoke({'comment': comment, \"topics\": topics})\r\nprint(comment)\r\nprint(res)\r\n"}
{"image_path": "data\\train\\00543.png", "code": "from langchain.chains import RetrievalQA\r\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\r\nfrom langchain.vectorstores.faiss import FAISS\r\nfrom langchain.vectorstores.chroma import Chroma\r\nfrom langchain_openai import ChatOpenAI, OpenAIEmbeddings\r\nfrom langchain.docstore.document import Document\r\nfrom langchain.prompts import PromptTemplate\r\nfrom os import path\r\nimport json\r\nfrom random import choices\r\n\r\ndata_dir = \"data\"\r\nvideo_data_dir = \"data\"\r\ntranscribed_data = \"transcriptions\"\r\nvideo_title = \"iphone_15_marques_review\"\r\nsave_video_dir = path.join(data_dir, video_data_dir, video_title)\r\nsave_transcript_dir = path.join(data_dir, transcribed_data, video_title + \".txt\")\r\npersist_directory = path.join(data_dir, \"vectore_store\")\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\nfile_path: str = \"comments.json\"\r\n\r\nwith open(file_path, \"r\", encoding=\"utf-8\") as f:\r\n    all_comments: list[str] = json.load(fp=f)\r\n    comments: list[str] = choices(population=all_comments, k=50)\r\n    comments: list[Document] = [Document(page_content=comment) for comment in all_comments]\r\n\r\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=200, chunk_overlap=30)\r\nsplit_docs = text_splitter.split_documents(comments)\r\n\r\nembeddings = OpenAIEmbeddings(api_key=api_key)\r\n# vectordb = FAISS.from_texts(splits, embeddings)\r\n# vectordb = FAISS.from_documents(documents=comments, embedding=embeddings)\r\n# vectordb = Chroma.from_documents(\r\n#     documents=split_docs,\r\n#     embedding=embeddings,\r\n#     persist_directory=persist_directory\r\n# )\r\n\r\ntemplate_str: str = \"\"\"\r\n"}
{"image_path": "data\\train\\00544.png", "code": "You are given the comments by various users on the review of {product}. Use the comments to answer \r\nthe questions that follow. When answering questions, try to list out your answer, with each answer \r\non its own separate line. If you do not know the answer, just say that you do not know. DO NOT MAKE \r\nSTUFF UP.\r\n---------\r\n{context}\r\nQuestion: {question}\r\nHelpful answer: \r\n\"\"\"\r\n\r\nproduct: str = \"iphone 15 pro max\"\r\ntemplate = PromptTemplate.from_template(template_str)\r\ntemplate = template.partial(product=product)\r\n\r\nvectordb = Chroma(\r\n    persist_directory=persist_directory,\r\n    embedding_function=embeddings\r\n)\r\n\r\nqa_chain = RetrievalQA.from_chain_type(\r\n    llm=ChatOpenAI(model_name=\"gpt-3.5-turbo\", temperature=0, api_key=api_key),\r\n    chain_type=\"stuff\",\r\n    return_source_documents=True,\r\n    retriever=vectordb.as_retriever(search_kwargs={\"k\": 10}),\r\n    chain_type_kwargs={\"prompt\": template}\r\n)\r\n\r\nwhile True:\r\n    query = input(\"User: \")\r\n    res = qa_chain.invoke(query)\r\n    print(res[\"result\"])"}
{"image_path": "data\\train\\00545.png", "code": "from langchain.output_parsers import PydanticOutputParser\r\nfrom langchain.pydantic_v1 import Field, BaseModel\r\nfrom langchain.prompts import PromptTemplate\r\nfrom langchain_openai import OpenAI\r\nimport re\r\nimport json\r\nfrom langchain.docstore.document import Document\r\nfrom random import choices\r\nfrom langchain.base_language import BaseLanguageModel\r\n\r\nfile_path: str = \"comments.json\"\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\n\r\n\r\ndef lower(text: str) -> str:\r\n    return text.lower().strip()\r\n\r\n\r\ndef remove_urls(text: str) -> str:\r\n    url_pattern = r\"https?://\\S+|www\\.\\S+\"\r\n    text = re.sub(url_pattern, \"\", text)\r\n    return text\r\n\r\n\r\ndef remove_punctuations(text: str) -> str:\r\n    punctuation_pattern = r\"[^\\w\\s]\"\r\n    cleaned = re.sub(punctuation_pattern, \"\", text)\r\n    return cleaned\r\n\r\n\r\ndef clean_text(text: str) -> str:\r\n    text = lower(text)\r\n    text = remove_urls(text)\r\n    text = remove_punctuations(text)\r\n    return text\r\n\r\n\r\ndef is_acceptable_len(text: str, l=15) -> bool:\r\n    return len(text.split()) >= l\r\n\r\n"}
{"image_path": "data\\train\\00546.png", "code": "with open(file_path, \"r\", encoding=\"utf-8\") as f:\r\n    all_comments: list[str] = json.load(fp=f)\r\n    cleaned_comments: list[str] = list(map(clean_text, all_comments))\r\n    # comments: list[str] = choices(population=cleaned_comments, k=3)\r\n    comments = cleaned_comments\r\n    docs: list[Document] = [\r\n        Document(page_content=comment)\r\n        for comment in comments\r\n        if is_acceptable_len(comment)\r\n    ]\r\n    comments: list[dict[str, str | int]] = [\r\n        {\"doc_id\": i + 1, \"comment\": docs[i].page_content} for i in range(len(docs))\r\n    ]\r\n\r\ndata_dir = \"./agent_nelly/data_analysis/data\"\r\nfeatures_dir = \"features\"\r\nsave_features_dir = path.join(data_dir, features_dir, \"features.json\")\r\n\r\nwith open(save_features_dir, 'r') as f:\r\n    topics: list[str] = json.load(f)\r\n\r\n\r\nclass CustomerCommentData(BaseModel):\r\n    doc_id: int = Field(description=\"The doc_id from the input\")\r\n    topics: list[str] = Field(\r\n        description=\"List of the relevant topics for the customer review. Include only topics from the list provided.\",\r\n        default_factory=list,\r\n    )\r\n    sentiment: str = Field(\r\n        description=\"Sentiment of the topic\", enum=[\"positive\", \"neutral\", \"negative\"]\r\n    )\r\n    \r\n\r\nclass CommentsParser(BaseModel):\r\n    comment: list[CustomerCommentData] = Field(description=\"A list of the customer comment data\", default_factory=list)\r\n\r\n\r\noutput_parser = PydanticOutputParser(pydantic_object=CommentsParser)\r\nformat_instructions = output_parser.get_format_instructions()\r\n\r\n"}
{"image_path": "data\\train\\00547.png", "code": "topic_assign_msg: str = \"\"\"\r\nBelow is a list of customer comments in JSON format with the following keys:\r\n1. doc_id - identifier of the comment\r\n2. comment - the user comment\r\n\r\nPlease analyze the provided comments and identify the main topics and sentiment. Include only the \r\ntopics mentioned in the following text:\r\nText: {topics}\r\n\r\n{format_instructions}\r\n\r\nuser comments: \r\n```{comments}```\r\n\"\"\"\r\n\r\ntopic_assign_tmpl = PromptTemplate(\r\n    template=topic_assign_msg,\r\n    input_variables=[\"topics\", \"comments\", \"format_instructions\"],\r\n)\r\n\r\nwith open('analysis.json', 'r') as f:\r\n    data = json.load(f)\r\n    \r\ni = data[-1][\"comment_id\"] + 1\r\n\r\nfrom time import sleep\r\nimport json\r\nfor _ in range(10):\r\n    d = comments[i: i+3]\r\n    x = {}\r\n    for s in d:\r\n        x[s['doc_id']] = s['comment']\r\n    i += 3\r\n    inputs = {\r\n        \"topics\": topics,\r\n        \"format_instructions\": format_instructions,\r\n        \"comments\": json.dumps(d),\r\n    }\r\n    # print(d)\r\n    # print(c)\r\n"}
{"image_path": "data\\train\\00548.png", "code": "    chat = OpenAI(temperature=0, api_key=api_key)\r\n    try:\r\n        chain = topic_assign_tmpl | chat | output_parser\r\n        res = chain.invoke(inputs)\r\n    except Exception:\r\n        pass\r\n    else:\r\n        print(res)\r\n        res = [\r\n            {\r\n                \"comment_id\": c.doc_id,\r\n                \"comment\": x[c.doc_id],\r\n                \"sentiment\": c.sentiment,\r\n                \"features\": c.topics\r\n            }\r\n            for c in res.comment\r\n        ]\r\n        print(res)\r\n        for y in res:\r\n            data.append(y)\r\n        with open('analysis.json', 'w') as f:\r\n            json.dump(data, fp=f, indent=4)\r\n        sleep(5)\r\n"}
{"image_path": "data\\train\\00549.png", "code": "from langchain.chains import RetrievalQA\r\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\r\nfrom langchain.vectorstores.faiss import FAISS\r\nfrom langchain_openai import ChatOpenAI, OpenAIEmbeddings\r\nfrom os import path\r\n\r\ndata_dir = \"data\"\r\nvideo_data_dir = \"data\"\r\ntranscribed_data = \"transcriptions\"\r\nvideo_title = \"iphone_15_marques_review\"\r\nsave_video_dir = path.join(data_dir, video_data_dir, video_title)\r\nsave_transcript_dir = path.join(data_dir, transcribed_data, video_title + \".txt\")\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\nwith open(save_transcript_dir, \"r\") as f:\r\n    video_transcript = f.read()\r\n\r\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=2500, chunk_overlap=150)\r\nsplits = text_splitter.split_text(video_transcript)\r\n\r\nembeddings = OpenAIEmbeddings(api_key=api_key)\r\nvectordb = FAISS.from_texts(splits, embeddings)\r\n\r\nqa_chain = RetrievalQA.from_chain_type(\r\n    llm=ChatOpenAI(model_name=\"gpt-3.5-turbo\", temperature=0, api_key=api_key),\r\n    chain_type=\"stuff\",\r\n    retriever=vectordb.as_retriever(),\r\n)\r\n\r\nfeatures: list[str] = [\r\n    \"5G connectivity\",\r\n    \"A15 Bionic chip\",\r\n    \"ProMotion display\",\r\n    \"Ceramic Shield front cover\",\r\n    \"Triple-camera system\",\r\n    \"LiDAR scanner\",\r\n    \"Night mode\",\r\n    \"Cinematic mode\",\r\n    \"Dolby Vision HDR recording\",\r\n    \"MagSafe charging\",\r\n"}
{"image_path": "data\\train\\00550.png", "code": "    \"Face ID\",\r\n    \"Water and dust resistance\",\r\n    \"iOS 15\",\r\n    \"Improved battery life\",\r\n    \"Siri voice recognition\",\r\n    \"Apple Pay\",\r\n    \"Apple Fitness+ integration\",\r\n    \"Apple Arcade subscription\",\r\n    \"Apple Music\",\r\n    \"iMessage\",\r\n    \"App Store\",\r\n    \"iCloud storage\",\r\n    \"Privacy features\",\r\n]\r\n\r\nfor feature in features:\r\n    print(\"#######################################################\")\r\n    query = f\"What does the video cover in relation to {feature}?\"\r\n    print(qa_chain.invoke(query))\r\n    print(\"#######################################################\")\r\n"}
{"image_path": "data\\train\\00551.png", "code": "from os import path\r\nimport json\r\nfrom random import choices\r\nfrom langchain.docstore.document import Document\r\nimport re\r\nfrom langchain.prompts import ChatPromptTemplate\r\n\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\nfile_path: str = \"comments.json\"\r\n\r\n\r\ndef lower(text: str) -> str:\r\n    return text.lower().strip()\r\n\r\n# def remove_tags(text: str) -> str:\r\n#     pattern = r'<.*?>'\r\n#     text = re.sub()\r\n\r\ndef remove_urls(text: str) -> str:\r\n    url_pattern = r'https?://\\S+|www\\.\\S+'\r\n    text = re.sub(url_pattern, \"\", text)\r\n    return text\r\n\r\ndef remove_punctuations(text: str) -> str:\r\n    punctuation_pattern = r'[^\\w\\s]'\r\n    cleaned = re.sub(punctuation_pattern, \"\", text)\r\n    return cleaned\r\n\r\ndef clean_text(text: str) -> str:\r\n    text = lower(text)\r\n    text = remove_urls(text)\r\n    text = remove_punctuations(text)\r\n    return text\r\n\r\ndef is_acceptable_len(text: str, l=6) -> bool:\r\n    return len(text.split()) >= l\r\n\r\nwith open(file_path, \"r\", encoding=\"utf-8\") as f:\r\n    all_comments: list[str] = json.load(fp=f)\r\n"}
{"image_path": "data\\train\\00552.png", "code": "    cleaned_comments: list[str] = list(map(clean_text, all_comments))\r\n    comments: list[str] = choices(population=cleaned_comments, k=10)\r\n    comments: list[Document] = [Document(page_content=comment) for comment in comments if is_acceptable_len(comment)]\r\n    \r\ndata_dir = \"./agent_nelly/data_analysis/data\"\r\nfeatures_dir = \"features\"\r\nsave_features_dir = path.join(data_dir, features_dir, \"features.json\")\r\n\r\nwith open(save_features_dir, 'r') as f:\r\n    topics: list[str] = json.load(f)\r\n\r\ntopic_assignment_msg: str = \"\"\"\r\nYou are provided with a detailed summary for the review of the product {product}. You will also be \r\ngiven a comment, which is a reaction to the product review. Please analyze the  \r\n\r\nList of topics: {topics}\r\nComments: {comments}\r\n\"\"\"\r\n\r\n"}
{"image_path": "data\\train\\00553.png", "code": "from langchain.output_parsers import PydanticOutputParser\r\nfrom langchain.pydantic_v1 import Field, BaseModel\r\nfrom langchain.prompts import ChatPromptTemplate, PromptTemplate\r\nfrom langchain_openai import ChatOpenAI, OpenAI\r\nimport re\r\nimport json\r\nfrom langchain.docstore.document import Document\r\nfrom random import choices\r\nfrom os import path\r\n\r\n\r\nfile_path: str = \"comments.json\"\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\n\r\n\r\ndef lower(text: str) -> str:\r\n    return text.lower().strip()\r\n\r\n\r\ndef remove_urls(text: str) -> str:\r\n    url_pattern = r\"https?://\\S+|www\\.\\S+\"\r\n    text = re.sub(url_pattern, \"\", text)\r\n    return text\r\n\r\n\r\ndef remove_punctuations(text: str) -> str:\r\n    punctuation_pattern = r\"[^\\w\\s]\"\r\n    cleaned = re.sub(punctuation_pattern, \"\", text)\r\n    return cleaned\r\n\r\n\r\ndef clean_text(text: str) -> str:\r\n    text = lower(text)\r\n    text = remove_urls(text)\r\n    text = remove_punctuations(text)\r\n    return text\r\n\r\n\r\ndef is_acceptable_len(text: str, l=15) -> bool:\r\n    return len(text.split()) >= l\r\n"}
{"image_path": "data\\train\\00554.png", "code": "\r\n\r\nwith open(file_path, \"r\", encoding=\"utf-8\") as f:\r\n    all_comments: list[str] = json.load(fp=f)\r\n    cleaned_comments: list[str] = list(map(clean_text, all_comments))\r\n    comments: list[str] = choices(population=cleaned_comments, k=10)\r\n    docs: list[Document] = [\r\n        Document(page_content=comment)\r\n        for comment in comments\r\n        if is_acceptable_len(comment)\r\n    ]\r\n    comments: list[dict[str, str | int]] = [\r\n        {\"doc_id\": i + 1, \"comment\": docs[i].page_content} for i in range(len(docs))\r\n    ]\r\n\r\ndata_dir = \"./agent_nelly/data_analysis/data\"\r\nfeatures_dir = \"features\"\r\nsave_features_dir = path.join(data_dir, features_dir, \"features.json\")\r\n\r\nwith open(save_features_dir, 'r') as f:\r\n    topics: list[str] = json.load(f)\r\n\r\n\r\nclass CustomerCommentData(BaseModel):\r\n    doc_id: int = Field(description=\"The doc_id from the input\")\r\n    topics: list[str] = Field(\r\n        description=\"List of the relevant topics for the customer review. Include only topics from the list provided.\",\r\n        default_factory=list,\r\n    )\r\n    sentiment: str = Field(\r\n        description=\"Sentiment of the topic\", enum=[\"positive\", \"neutral\", \"negative\"]\r\n    )\r\n    \r\n\r\nclass CommentsParser(BaseModel):\r\n    comment: list[CustomerCommentData] = Field(description=\"A list of the customer comment data\", default_factory=list)\r\n\r\n\r\noutput_parser = PydanticOutputParser(pydantic_object=CommentsParser)\r\nformat_instructions = output_parser.get_format_instructions()\r\n"}
{"image_path": "data\\train\\00555.png", "code": "\r\ntopic_assign_msg: str = \"\"\"\r\nBelow is a list of customer comments in JSON format with the following keys:\r\n1. doc_id - identifier of the comment\r\n2. comment - the user comment\r\n\r\nPlease analyze the provided comments and identify the main topics and sentiment. Include only the \r\ntopics mentioned in the following text:\r\nText: {topics}\r\n\r\n{format_instructions}\r\n\r\nuser comments: \r\n```{comments}```\r\n\"\"\"\r\n\r\ntopic_assign_tmpl = PromptTemplate(\r\n    template=topic_assign_msg,\r\n    input_variables=[\"topics\", \"comments\", \"format_instructions\"],\r\n)\r\n# topic_assign_tmpl = ChatPromptTemplate.from_messages(\r\n#     [\r\n#         (\"system\", \"You are a helpful assistant. Your task is to analyze user comments.\"),\r\n#         (\"user\", topic_assign_msg)\r\n#     ]\r\n# )\r\n\r\n# messages = topic_assign_tmpl.format(\r\n#     topics=topics,\r\n#     format_instructions=format_instructions,\r\n#     comments=json.dumps(comments)\r\n# )\r\n\r\ninputs = {\r\n    \"topics\": topics,\r\n    \"format_instructions\": format_instructions,\r\n    \"comments\": json.dumps(comments),\r\n}\r\n\r\nchat = OpenAI(temperature=0, api_key=api_key)\r\n"}
{"image_path": "data\\train\\00556.png", "code": "chain = topic_assign_tmpl | chat | output_parser\r\nres = chain.invoke(inputs)\r\nprint(res)\r\n"}
{"image_path": "data\\train\\00557.png", "code": "from langchain_community.document_loaders.generic import GenericLoader\r\nfrom langchain_community.document_loaders.parsers import OpenAIWhisperParser\r\nfrom langchain_community.document_loaders.blob_loaders.youtube_audio import (\r\n    YoutubeAudioLoader,\r\n)\r\nfrom os import path\r\n\r\n# Two Karpathy lecture videos\r\nurls = [\"https://www.youtube.com/watch?v=cBpGq-vDr2Y\"]\r\n\r\n# Directory to save audio files\r\ndata_dir = \"data\"\r\nvideo_data_dir = \"data\"\r\ntranscribed_data = \"transcriptions\"\r\nvideo_title = \"iphone_15_marques_review\"\r\nsave_video_dir = path.join(data_dir, video_data_dir, video_title)\r\nsave_transcript_dir = path.join(data_dir, transcribed_data, video_title + \".txt\")\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\n\r\nloader = GenericLoader(\r\n    YoutubeAudioLoader(urls, save_video_dir), OpenAIWhisperParser(api_key=api_key)\r\n)\r\ndocs = loader.load()\r\n\r\nfull_transcript = \"\"\r\nfor doc in docs:\r\n    full_transcript += doc.page_content\r\n\r\nwith open(save_transcript_dir, \"w\", encoding=\"utf-8\") as f:\r\n    f.write(full_transcript)\r\n\r\nprint(full_transcript)\r\n"}
{"image_path": "data\\train\\00558.png", "code": "from os import path\r\n\r\nfrom langchain.chains import StuffDocumentsChain\r\nfrom langchain.chains.llm import LLMChain\r\nfrom langchain.llms.base import BaseLLM\r\nfrom langchain.prompts import PromptTemplate\r\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\r\nfrom langchain_community.document_loaders.text import TextLoader\r\nfrom langchain_openai import ChatOpenAI, OpenAI\r\nfrom langchain.docstore.document import Document\r\n\r\nwith open('analysis.json', 'r') as f:\r\n    import json\r\n    analy = json.load(f)\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\n\r\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=1500, chunk_overlap=150)\r\n\r\n\r\ntemplate_str: str = \"\"\"\r\nYou are provided with the coments of various users to the review of the {product}\r\n\r\nPlease provide a detailed summary of the users comments. Make sure to identify the features \r\nthat the users loved as well as those that they hated.\r\ncomments: {comments}\r\ndetailed summary: \r\n\"\"\"\r\n\r\nproduct: str = \"Apple vision pro\"\r\ntemplate = PromptTemplate.from_template(template_str)\r\ntemplate = template.partial(product=product)\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\nchat: BaseLLM = ChatOpenAI(temperature=0, api_key=api_key)\r\nllm: BaseLLM = OpenAI(temperature=0, api_key=api_key)\r\n\r\nllm_chain = LLMChain(llm=chat, prompt=template)\r\nstuff_chain = StuffDocumentsChain(llm_chain=llm_chain, document_variable_name=\"comments\")\r\n\r\n"}
{"image_path": "data\\train\\00559.png", "code": "# loader = TextLoader(file_path=save_transcript_dir)\r\n# docs = loader.load_and_split(text_splitter=text_splitter)\r\ndocs: list[Document] = [\r\n    Document(page_content=comment['comment']) for comment in analy\r\n]\r\nres = stuff_chain.run(docs)\r\n# chain = template | llm\r\n# res = chain.invoke({\"comments\": analy})\r\nprint(res)\r\n\r\n\r\n# def save_summary(summary: str) -> None:\r\n#     with open(save_transcript_dir, \"w\") as f:\r\n#         f.write(summary)\r\n\r\n\r\n# def summarize_video(video_transcript: str) -> str:\r\n#     with open(save_transcript_dir, \"r\") as f:\r\n#         summry: str = f.read()\r\n#     return summry\r\n"}
{"image_path": "data\\train\\00560.png", "code": "from dotenv import load_dotenv\r\n\r\nload_dotenv()\r\nfrom langchain.agents import AgentExecutor, Tool\r\nfrom langchain.agents.format_scratchpad import format_to_openai_function_messages\r\nfrom langchain.agents.output_parsers import OpenAIFunctionsAgentOutputParser\r\nfrom langchain.prompts import ChatPromptTemplate, MessagesPlaceholder\r\nfrom langchain.tools.render import format_tool_to_openai_function\r\nfrom typing import Optional\r\nfrom langchain.llms.base import BaseLLM\r\nfrom langchain_openai import OpenAI, ChatOpenAI\r\nfrom langchain.callbacks.manager import (\r\n    AsyncCallbackManagerForToolRun,\r\n    CallbackManagerForToolRun,\r\n)\r\nfrom langchain.tools import BaseTool, Tool\r\nfrom langchain_community.utilities.google_search import GoogleSearchAPIWrapper\r\n\r\n\r\nclass GoogleSearchTool(BaseTool):\r\n    name = \"google_search\"\r\n    description = \"\"\"\r\n    useful when you need to to search for the latest information from the web\r\n    \"\"\"\r\n\r\n    def _run(\r\n        self, query: str, run_manager: Optional[CallbackManagerForToolRun] = None\r\n    ) -> str:\r\n        \"\"\"Use the tool.\"\"\"\r\n        search = GoogleSearchAPIWrapper()\r\n        return search.run(query=query)\r\n\r\n    async def _arun(\r\n        self, query: str, run_manager: Optional[AsyncCallbackManagerForToolRun] = None\r\n    ) -> str:\r\n        \"\"\"Use the tool asynchronously.\"\"\"\r\n        raise NotImplementedError()\r\n\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\n"}
{"image_path": "data\\train\\00561.png", "code": "chatgpt: BaseLLM = ChatOpenAI(temperature=0, api_key=api_key)\r\n\r\ntools: list[Tool] = [\r\n    GoogleSearchTool(),\r\n]\r\n\r\n\r\ndef get_agent_executor():\r\n    \"\"\"Get the agent\"\"\"\r\n    prompt = ChatPromptTemplate.from_messages(\r\n        [\r\n            (\r\n                \"system\",\r\n                \"You are a very useful assistant. Your task will be to asnswer the users question. Be very friendly and professional.\",\r\n            ),\r\n            (\"user\", \"{input}\"),\r\n            MessagesPlaceholder(variable_name=\"agent_scratchpad\"),\r\n        ]\r\n    )\r\n\r\n    functions = [format_tool_to_openai_function(t) for t in tools]\r\n\r\n    llm_with_tools = chatgpt.bind(functions=functions)\r\n\r\n    agent = (\r\n        {\r\n            \"input\": lambda x: x[\"input\"],\r\n            \"agent_scratchpad\": lambda x: format_to_openai_function_messages(\r\n                x[\"intermediate_steps\"]\r\n            ),\r\n        }\r\n        | prompt\r\n        | llm_with_tools\r\n        | OpenAIFunctionsAgentOutputParser()\r\n    )\r\n\r\n    agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)\r\n    return agent_executor\r\n\r\n\r\n"}
{"image_path": "data\\train\\00562.png", "code": "agent = get_agent_executor()\r\n# query = \"What are the main features of the iphone 15?\"\r\n# query = \"What are some of the complaints about iphone 15?\"\r\n# query = \"What features of the iphone 15 do its users love most?\"\r\nquery = \"What are the pros and cons of the iphone 15?\"\r\nres = agent.invoke({\"input\": query})\r\nprint(res)\r\n"}
{"image_path": "data\\train\\00563.png", "code": "from langchain.chains import StuffDocumentsChain\r\nfrom langchain.chains.llm import LLMChain\r\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\r\nfrom langchain_community.document_loaders.text import TextLoader\r\nfrom os import path\r\nfrom langchain.prompts import PromptTemplate\r\nfrom langchain.llms.base import BaseLLM\r\nfrom langchain_openai import ChatOpenAI, OpenAI\r\n\r\n\r\ndata_dir = \"./agent_nelly/data_analysis/data\"\r\nsummary_dir = \"summary\"\r\nsave_transcript_dir = path.join(data_dir, summary_dir, \"summary.txt\")\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\n\r\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=1500, chunk_overlap=150)\r\n\r\n\r\ntemplate_str: str = \"\"\"\r\nYou are provided with the transcript for a youtube video. The video is a review of the product {product}. \r\nReturn a JSON object with a single key ```features``` which is a list of all the {product} features mentioned.\r\nTranscript: {text} \r\n\"\"\"\r\n\r\nproduct: str = \"iphone 15 pro max\"\r\ntemplate = PromptTemplate.from_template(template_str)\r\ntemplate = template.partial(product=product)\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\nchat: BaseLLM = ChatOpenAI(temperature=0, api_key=api_key)\r\nllm: BaseLLM = OpenAI(temperature=0, api_key=api_key)\r\n\r\nwith open(save_transcript_dir, 'r') as f:\r\n    summry: str = f.read()\r\n    \r\nchain = template | llm\r\nres = chain.invoke({\"text\": summry})\r\nprint(res)"}
{"image_path": "data\\train\\00564.png", "code": "from typing import Generator, Optional, Iterator\r\nfrom pydantic import BaseModel, Field\r\nfrom youtube import YouTube\r\nfrom youtube.models import Channel, Comment, Search, Video\r\nfrom youtube.schemas import (SearchOptionalParameters, SearchPart,\r\n                             YouTubeListResponse, YouTubeRequest,\r\n                             YouTubeResponse)\r\nimport json\r\nfrom rich.table import Table\r\nfrom rich.console import Console\r\nfrom rich import box\r\nfrom rich.live import Live\r\n\r\n\r\nclient_secrets_file = \"/home/lyle/Downloads/search.json\"\r\nyoutube_client = YouTube(client_secret_file=client_secrets_file)\r\nyoutube_client_object = youtube_client.authenticate()\r\nyoutube_client.youtube_client = youtube_client_object\r\n\r\n\r\ndef get_channel_id(channel_name: str) -> str:\r\n    \"\"\"Get the channel id.\"\"\"\r\n    response: YouTubeResponse = youtube_client.find_channel_by_name(channel_name)\r\n    search_result: Search = response.items[0]\r\n    return search_result.resource_id\r\n\r\n\r\ndef search_youtube_channels(product: str, max_results: int = 5) -> list[Search]:\r\n    search_part: SearchPart = SearchPart()\r\n    query: str = f\"latest {product} review\"\r\n    optional_params: SearchOptionalParameters = SearchOptionalParameters(\r\n        q=query,\r\n        maxResults=max_results,\r\n        type=[\"channel\"],\r\n    )\r\n    search_schema: YouTubeRequest = YouTubeRequest(\r\n        part=search_part, optional_parameters=optional_params\r\n    )\r\n    response: YouTubeResponse = youtube_client.search(search_schema)\r\n    items: list[Search] = response.items\r\n"}
{"image_path": "data\\train\\00565.png", "code": "    return items\r\n\r\n\r\ndef get_channel_details(channel: Search) -> Channel:\r\n    \"\"\"Get channel details\"\"\"\r\n    response: YouTubeListResponse = youtube_client.find_channel_by_id(\r\n        channel_id=channel.resource_id\r\n    )\r\n    channel: Channel = response.items[0]\r\n    return channel\r\n\r\n\r\ndef parse_channel_details(channel: Channel) -> dict:\r\n    return {\r\n        \"title\": channel.snippet.title,\r\n        \"description\": channel.snippet.description,\r\n        \"date\": str(channel.snippet.published_at.date()),\r\n        \"subscribers\": channel.statistics.subscribers_count,\r\n        \"videos\": channel.statistics.videos_count,\r\n    }\r\n    \r\n    \r\ndef get_channels(product: str, max_results: int = 10) -> list[dict]:\r\n    channels: list[Search] = search_youtube_channels(product=product, max_results=max_results)\r\n    channels: list[Channel] = map(get_channel_details, channels)\r\n    channels: list[dict] = map(parse_channel_details, channels)\r\n    return channels\r\n\r\ndef save_data(file_path: str, data: list) -> None:\r\n    with open(file_path, 'w') as f:\r\n        json.dump(data, f, indent=4)\r\n        \r\ndef load_data(file_path: str) -> dict:\r\n    with open(file_path, 'r') as f:\r\n        data: list[dict] = json.load(f)\r\n    return data\r\n\r\n\r\ndef create_channels_table(table_data: list[dict]) -> Table:\r\n    table: Table = Table(row_styles=[\"dim\", \"\"],leading=1, box=box.MINIMAL_DOUBLE_HEAD,\r\n"}
{"image_path": "data\\train\\00566.png", "code": "         title=\"[bold italic gold1]Youtube channels reviewing Iphone 15 pro[/bold italic gold1]\")\r\n    table.add_column(header=\"[b]Channel Title\", justify=\"left\", style=\"dark_orange\")\r\n    table.add_column(header=\"Subscribers\", justify=\"left\", style=\"light_coral\")\r\n    table.add_column(header=\"[b]Videos\", justify=\"left\", style=\"yellow2\")\r\n    table.add_column(header=\"Date\", justify=\"center\", style=\"violet\")\r\n    table.columns[0].header_style = \"bold chartreuse1\"\r\n    table.columns[1].header_style = \"bold dark_goldenrod\"\r\n    table.columns[2].header_style = \"bold chartreuse1\"\r\n    table.columns[3].header_style = \"bold dark_goldenrod\"\r\n    table.border_style = \"bright_yellow\"\r\n    table.pad_edge = True\r\n    for row in table_data:\r\n        table.add_row(row[\"title\"], str(row[\"subscribers\"]), str(row[\"videos\"]), row[\"date\"])\r\n    return table\r\n\r\n\r\ndef video_search(\r\n    product: str, channel_title: str, max_results: int = 5\r\n) -> list[Search]:\r\n    \"\"\"Search the given channel for the given videos.\"\"\"\r\n    query: str = f\"latest {product} review\"\r\n    channel_id: str = get_channel_id(channel_name=channel_title)\r\n    search_part: SearchPart = SearchPart()\r\n    optional_params: SearchOptionalParameters = SearchOptionalParameters(\r\n        channelId=channel_id,\r\n        q=query,\r\n        maxResults=max_results,\r\n        type=[\"video\"],\r\n    )\r\n    search_schema: YouTubeRequest = YouTubeRequest(\r\n        part=search_part, optional_parameters=optional_params\r\n    )\r\n    response: YouTubeResponse = youtube_client.search(search_schema)\r\n    items: list[Search] = response.items\r\n    return items\r\n\r\n\r\ndef get_video_id(video_title: str) -> str:\r\n    \"\"\"Get video id given the title.\"\"\"\r\n    part: SearchPart = SearchPart()\r\n"}
{"image_path": "data\\train\\00567.png", "code": "    optional_parameters: SearchOptionalParameters = SearchOptionalParameters(\r\n        q=video_title, maxResults=1, type=[\"video\"]\r\n    )\r\n    search_request: YouTubeRequest = YouTubeRequest(\r\n        part=part, optional_parameters=optional_parameters\r\n    )\r\n    search_results: YouTubeResponse = youtube_client.search(search_request)\r\n    search_result: Search = search_results.items[0]\r\n    return search_result.resource_id\r\n\r\n\r\ndef get_video_details(video: Search) -> Video:\r\n    \"\"\"Get video details\"\"\"\r\n    response: YouTubeListResponse = youtube_client.find_video_by_id(video.resource_id)\r\n    video: Video = response.items[0]\r\n    return video\r\n\r\n\r\ndef parse_video_details(video: Video) -> dict:\r\n    return {\r\n        \"title\": video.snippet.title,\r\n        \"description\": video.snippet.description,\r\n        \"date\": str(video.snippet.published_at),\r\n        \"views\": video.statistics.views_count,\r\n        \"comments\": video.statistics.comments_count,\r\n        \"likes\": video.statistics.likes_count,\r\n    }\r\n    \r\ndef get_videos(product: str, channel: str) -> list[dict]:\r\n    videos: list[Search] = video_search(product=product, channel_title=channel)\r\n    videos: list[Video] = map(get_video_details, videos)\r\n    videos: list[dict] = map(parse_video_details, videos)\r\n    return videos\r\n\r\n\r\ndef create_videos_table(table_data: list[dict]) -> Table:\r\n    table: Table = Table(row_styles=[\"dim\", \"\"],leading=1, box=box.MINIMAL_DOUBLE_HEAD,\r\n         title=\"[bold italic gold1]Youtube videos reviewing Iphone 15 pro[/bold italic gold1]\")\r\n    table.add_column(header=\"[b]Video Title\", justify=\"left\", style=\"dark_orange\")\r\n    table.add_column(header=\"Views\", justify=\"left\", style=\"light_coral\")\r\n"}
{"image_path": "data\\train\\00568.png", "code": "    table.add_column(header=\"[b]Comments\", justify=\"left\", style=\"yellow2\")\r\n    table.add_column(header=\"Likes\", justify=\"left\", style=\"magenta3\")\r\n    table.add_column(header=\"[b]Date\", justify=\"center\", style=\"violet\")\r\n    table.columns[0].header_style = \"bold chartreuse1\"\r\n    table.columns[1].header_style = \"bold dark_goldenrod\"\r\n    table.columns[2].header_style = \"bold chartreuse1\"\r\n    table.columns[3].header_style = \"bold dark_goldenrod\"\r\n    table.columns[4].header_style = \"bold chartreuse1\"\r\n    table.border_style = \"bright_yellow\"\r\n    table.pad_edge = True\r\n    for row in table_data:\r\n        table.add_row(row[\"title\"], str(row[\"views\"]), str(row[\"comments\"]), str(row[\"likes\"]), row[\"date\"])\r\n    return table\r\n\r\n\r\ndef parse_comment(comment: Comment) -> dict:\r\n    return {\r\n        \"comment_id\": comment.id,\r\n        \"comment\": comment.snippet.text_display,\r\n        \"likes\": comment.snippet.like_count,\r\n        \"date_published\": str(comment.snippet.published_at),\r\n    }\r\n    \r\n    \r\nclass Data(BaseModel):\r\n    id: str\r\n    comment: str\r\n    sentiment: Optional[str] = Field(\r\n        description=\"The comment sentiment\",\r\n        enum=[\"neutral\", \"positive\", \"negative\"],\r\n        default=None,\r\n    )\r\n    features: Optional[list[str]] = Field(\r\n        description=\"The features mentioned in the comment\", default_factory=list\r\n    )\r\n    likes: Optional[int] = Field(description=\"The number of likes\", default=None)\r\n    date: Optional[str] = Field(\r\n        description=\"The date when the comment was posted\", default=None\r\n    )\r\n\r\n"}
{"image_path": "data\\train\\00569.png", "code": "\r\ndef get_video_comments(video_id: str, max_results: Optional[int] = 10) -> Generator:\r\n    \"\"\"List a given videos comments\"\"\"\r\n    comment_iterator: Iterator = youtube_client.get_comments_iterator(video_id=video_id)\r\n    done: bool = False\r\n    comment_count: int = 0\r\n    for comment_threads in comment_iterator:\r\n        if done:\r\n            break\r\n        for comment_thread in comment_threads:\r\n            comment: Comment = comment_thread.snippet.top_level_comment\r\n            comment = parse_comment(comment=comment)\r\n            # comment = Data(\r\n            #     id=comment[\"comment_id\"],\r\n            #     comment=comment[\"comment\"],\r\n            #     likes=comment[\"likes\"],\r\n            #     date=comment[\"date_published\"],\r\n            # )\r\n            yield comment\r\n            comment_count += 1\r\n            if comment_count > max_results:\r\n                done = True\r\n                break\r\n            \r\n            \r\ndef create_comments_table(table_data: list[dict]) -> Table:\r\n    table: Table = Table(row_styles=[\"dim\", \"\"],leading=1, box=box.MINIMAL_DOUBLE_HEAD)\r\n    table.add_column(header=\"[b]Comment Id\", justify=\"left\", style=\"dark_orange\")\r\n    table.add_column(header=\"Comment\", justify=\"left\", style=\"light_coral\")\r\n    table.add_column(header=\"[b]Likes\", justify=\"left\", style=\"yellow2\")\r\n    table.add_column(header=\"Date\", justify=\"center\", style=\"violet\")\r\n    table.columns[0].header_style = \"bold chartreuse1\"\r\n    table.columns[1].header_style = \"bold dark_goldenrod\"\r\n    table.columns[2].header_style = \"bold chartreuse1\"\r\n    table.columns[3].header_style = \"bold dark_goldenrod\"\r\n    table.border_style = \"bright_yellow\"\r\n    table.pad_edge = True\r\n    for row in table_data:\r\n        table.add_row(row[\"comment_id\"], row[\"comment\"], str(row[\"likes\"]), row[\"date_published\"])\r\n    return table\r\n"}
{"image_path": "data\\train\\00570.png", "code": "\r\n\r\nchannel_file_path: str = \"channels.json\"\r\nproduct: str = \"iphone 15 pro\"\r\nchannel: str = \"Marques Brownlee\"\r\nvideo_file_path: str = \"videos.json\"\r\ncomments_file_path: str = \"comments_1.json\"\r\n# save_data(file_path=channel_file_path, data=list(get_channels(product=product)))\r\n# channels: list[dict] = load_data(file_path=channel_file_path)\r\n\r\n# videos: list[dict] = get_videos(product=product, channel=channel)\r\n# save_data(file_path=video_file_path, data=list(get_videos(product=product, channel=channel)))\r\n# videos: list[dict] = load_data(file_path=video_file_path)\r\n\r\n# save_data(file_path=comments_file_path, data=list(get_video_comments(video_id='cBpGq-vDr2Y', max_results=100)))\r\ncomments: list[dict] = load_data(file_path=comments_file_path)\r\nconsole = Console()\r\nbatch: int = 10\r\nfrom time import sleep\r\n# with Live(create_comments_table(comments[:batch])) as live:\r\n#     index: int = 0\r\n#     for i in range(batch, len(comments)):\r\n#         live.update(create_comments_table(comments[i: i+batch]))\r\n#         sleep(0.1)\r\n        \r\n# from collections import deque\r\n# queue = deque(maxlen=10, iterable=comments[:batch])\r\n# with Live(create_comments_table(table_data=queue)) as live:\r\n#     for data in comments[batch:]:\r\n#         queue.append(data)\r\n#         live.update(create_comments_table(table_data=queue))\r\n#         sleep(0.5)\r\n# from collections import deque\r\n# queue = deque(maxlen=10)\r\n# iterator = get_video_comments(video_id='cBpGq-vDr2Y', max_results=100)\r\n# for _ in range(batch):\r\n#     queue.append(next(iterator))\r\n# with Live(create_comments_table(table_data=queue)) as live:\r\n#     for data in iterator:\r\n#         queue.append(data)\r\n"}
{"image_path": "data\\train\\00571.png", "code": "#         live.update(create_comments_table(table_data=queue))\r\n\r\n\r\ndef create_analyzed_comments_table(table_data: list[dict]) -> Table:\r\n    table: Table = Table(row_styles=[\"dim\", \"\"],leading=1, box=box.MINIMAL_DOUBLE_HEAD)\r\n    table.add_column(header=\"[b]Comment Id\", justify=\"left\", style=\"dark_orange\")\r\n    table.add_column(header=\"Comment\", justify=\"left\", style=\"light_coral\")\r\n    table.add_column(header=\"[b]Likes\", justify=\"left\", style=\"yellow2\")\r\n    table.add_column(header=\"Sentiment\", justify=\"left\", style=\"light_coral\")\r\n    table.add_column(header=\"[b]Topics\", justify=\"left\", style=\"yellow2\")\r\n    table.add_column(header=\"Date\", justify=\"center\", style=\"violet\")\r\n    table.columns[0].header_style = \"bold chartreuse1\"\r\n    table.columns[1].header_style = \"bold dark_goldenrod\"\r\n    table.columns[2].header_style = \"bold chartreuse1\"\r\n    table.columns[3].header_style = \"bold dark_goldenrod\"\r\n    table.columns[4].header_style = \"bold chartreuse1\"\r\n    table.columns[5].header_style = \"bold dark_goldenrod\"\r\n    table.border_style = \"bright_yellow\"\r\n    table.pad_edge = True\r\n    colors = {\r\n        'negative': 'red',\r\n        'positive': 'green',\r\n        'neutral': 'purple'\r\n    }\r\n    for row in table_data:\r\n        color = colors[row[\"sentiment\"]]\r\n        table.add_row(row[\"comment_id\"], row[\"comment\"], str(row[\"likes\"]), f\"[bold {color}]{row['sentiment']}[/bold {color}]\", \", \".join(row[\"features\"]), row[\"date_published\"])\r\n    return table\r\ndef analyze_comment(comment: dict) -> dict:\r\n    from random import choice, choices\r\n    sentiments: list[str] = ['negative', 'positive', 'neutral']\r\n    all_topics: list[str] = [\"Incremental changes in design\", \"Softer corners\", \"Slimmer bezels\", \"USB Type-C port\"]\r\n    sentiment: str = choice(sentiments)\r\n    topics: list[str] = choices(population=all_topics, k=3)\r\n    comment['topics'] = topics\r\n    comment['sentiment'] = sentiment\r\n    return comment\r\n# analyzed_comments: list[dict] = list(map(analyze_comment, comments)) \r\nwith open('analysis.json', 'r') as f:\r\n    analyzed_comments: list[dict] = json.load(f)\r\n"}
{"image_path": "data\\train\\00572.png", "code": "\r\nfrom random import randint    \r\ndef like(comment: dict) -> dict:\r\n    comment['likes'] = randint(0,2)\r\n    return comment\r\n\r\nanalyzed_comments: list[dict] = list(map(like, analyzed_comments))\r\n            \r\n            \r\nfrom collections import deque\r\nqueue = deque(maxlen=10, iterable=analyzed_comments[:batch])\r\nwith Live(create_analyzed_comments_table(table_data=queue)) as live:\r\n    for data in analyzed_comments[batch:]:\r\n        queue.append(data)\r\n        live.update(create_analyzed_comments_table(table_data=queue))\r\n        sleep(0.5)"}
{"image_path": "data\\train\\00573.png", "code": "from langchain.prompts import PromptTemplate\r\nfrom os import path\r\nfrom langchain.llms.base import BaseLLM\r\nfrom langchain_openai import OpenAI\r\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\r\n\r\n\r\ndata_dir = \"data\"\r\nvideo_data_dir = \"data\"\r\ntranscribed_data = \"transcriptions\"\r\nvideo_title = \"iphone_15_marques_review\"\r\nsave_video_dir = path.join(data_dir, video_data_dir, video_title)\r\nsave_transcript_dir = path.join(data_dir, transcribed_data, video_title + \".txt\")\r\n\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\napi_key: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\nchatgpt: BaseLLM = OpenAI(temperature=0, api_key=api_key)\r\n\r\nprompt: str = \"\"\"\r\nYou are given the transcript for a video that covers the review of the iphone 15 pro. Find out all the \r\nfeatures covered in the review. Only return the features of the iphine 15 pri. Return a JSON object with a single key called features.\r\nTranscript: {transcript}\r\n\"\"\"\r\n\r\nwith open(save_transcript_dir, \"r\") as f:\r\n    video_transcript = f.read()\r\n\r\ntemplate = PromptTemplate(template=prompt, input_variables=[\"transcript\"])\r\n\r\nchain = template | chatgpt\r\n\r\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=2500, chunk_overlap=150)\r\nsplits = text_splitter.split_text(video_transcript)\r\ntopics = []\r\nfor doc in splits:\r\n    res = chain.invoke({\"transcript\": doc})\r\n    topics.append(res)\r\n    print(res)\r\nprint(topics)\r\n"}
{"image_path": "data\\train\\00574.png", "code": "from dotenv import load_dotenv\r\n\r\nload_dotenv()\r\nfrom langchain.agents import tool\r\nfrom langchain.pydantic_v1 import BaseModel, Field\r\nfrom langchain_core.utils.function_calling import convert_to_openai_function\r\nfrom langchain_community.utilities.google_search import GoogleSearchAPIWrapper\r\nimport os\r\nfrom langchain_openai import ChatOpenAI, OpenAI\r\nfrom langchain.prompts import ChatPromptTemplate, PromptTemplate\r\nfrom langchain.llms.base import BaseLLM\r\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\r\nfrom os import path\r\n\r\n\r\nOPENAI_API_KEY: str = \"sk-dummy_openai_key_placeholder_123456789\"\r\n\r\nGOOGLE_API_KEY: str = os.environ.get(\r\n    \"GOOGLE_API_KEY\", \"AIzaSy_dummy_google_key_placeholder_123\"\r\n)\r\nGOOGLE_CSE_ID: str = os.environ.get(\"GOOGLE_CSE_ID\", \"a347832f863fd4f5d\")\r\n\r\nchat_model: BaseLLM = ChatOpenAI(temperature=0, api_key=OPENAI_API_KEY)\r\nllm: BaseLLM = OpenAI(temperature=0, api_key=OPENAI_API_KEY)\r\n\r\ngoogle_search = GoogleSearchAPIWrapper(\r\n    google_api_key=GOOGLE_API_KEY, google_cse_id=GOOGLE_CSE_ID, k=3\r\n)\r\n\r\ndata_dir = \"data\"\r\nvideo_data_dir = \"data\"\r\ntranscribed_data = \"transcriptions\"\r\nvideo_title = \"iphone_15_marques_review\"\r\nsave_video_dir = path.join(data_dir, video_data_dir, video_title)\r\nsave_transcript_dir = path.join(data_dir, transcribed_data, video_title + \".txt\")\r\n\r\n\r\nclass UserQuery(BaseModel):\r\n    query: str = Field(description=\"What the user wants to search for on the web\")\r\n    result_count: int = Field(description=\"The number of results to return\", default=5)\r\n"}
{"image_path": "data\\train\\00575.png", "code": "\r\n\r\nclass ProductFeatures(BaseModel):\r\n    display: str\r\n    design: str\r\n    perfomance: str\r\n    camera: str\r\n\r\n\r\n@tool(args_schema=UserQuery)\r\ndef google_search_tool(query: str, result_count: int) -> str:\r\n    \"\"\"Search for the latest information from the web using Google.\"\"\"\r\n    google_search = GoogleSearchAPIWrapper(\r\n        google_api_key=GOOGLE_API_KEY, google_cse_id=GOOGLE_CSE_ID, k=3\r\n    )\r\n    google_search.k = result_count\r\n    return google_search.run(query=query)\r\n\r\n\r\nchat_model.bind(functions=[convert_to_openai_function(google_search_tool)])\r\nprompt = ChatPromptTemplate.from_messages(\r\n    messages=[\r\n        (\r\n            \"system\",\r\n            \"You are a very good product analyst for apple products. Your task is to find out the most accurate detailed information on various apple products.\",\r\n        ),\r\n        (\"human\", \"{request}\"),\r\n    ]\r\n)\r\n\r\n# analyst_chain = prompt | chat_model\r\n\r\n# res = analyst_chain.invoke(\r\n#     {\"request\": \"What are all the features of the iphone 13 pro max?\"}\r\n# )\r\n\r\n# print(res)\r\n\r\nproduct_features_template_str: str = \"\"\"\r\nYou will be provided with a product name. Your task will be to list all all the product,s features \r\n"}
{"image_path": "data\\train\\00576.png", "code": "that can be used during the creation of a youtube video that reviews the product for users. Only \r\nreturn a JSON object with the key ``features``.\r\nProduct: {product}\r\n\"\"\"\r\n\r\nproduct_features_description_template: str = \"\"\"\r\nYou will be provided by a list of product features as well as a product name. Your task is to \r\nprovide a detailed description of each feature. Only return a JSON object with each feature as \r\na key.\r\nProduct Name: {product}\r\nProduct features: {features}\r\n\"\"\"\r\n\r\nfeatures_covered_template_str: str = \"\"\"\r\nYou will be provided with the transcript for a youtube video that reviews a product. The product name \r\nwill also be provided as well as the features of the given product. Your task will be to find all the \r\nfeatures of the product that are found in the feature list and are also covered in the transcript. For \r\neach feature covered in the transcript, provide a short summary of what is covered. Only consider the \r\nfeatures in the feature list. Only return a valid JSON object with each feature as a key and a short \r\nsummary.\r\nProduct: {product}\r\nFeatures: {features}\r\nTranscript: {transcript}\r\n\"\"\"\r\n\r\n\r\nfeatures_template = PromptTemplate(\r\n    template=product_features_template_str, input_variables=[\"product\"]\r\n)\r\nfeatures_description_template = PromptTemplate(\r\n    template=product_features_description_template,\r\n    input_variables=[\"product\", \"features\"],\r\n)\r\nfeatures_covered_template = PromptTemplate(\r\n    template=features_covered_template_str, input_variables=[\"product\", \"transcript\", \"features\"]\r\n)\r\n\r\nproduct: str = \"iphone 13 pro\"\r\nfeatures: list[str] = [\r\n    \"5G connectivity\",\r\n"}
{"image_path": "data\\train\\00577.png", "code": "    \"A15 Bionic chip\",\r\n    \"ProMotion display\",\r\n    \"Ceramic Shield front cover\",\r\n    \"Triple-camera system\",\r\n    \"LiDAR scanner\",\r\n    \"Night mode\",\r\n    \"Cinematic mode\",\r\n    \"Dolby Vision HDR recording\",\r\n    \"MagSafe charging\",\r\n    \"Face ID\",\r\n    \"Water and dust resistance\",\r\n    \"iOS 15\",\r\n    \"Improved battery life\",\r\n    \"Siri voice recognition\",\r\n    \"Apple Pay\",\r\n    \"Apple Fitness+ integration\",\r\n    \"Apple Arcade subscription\",\r\n    \"Apple Music\",\r\n    \"iMessage\",\r\n    \"App Store\",\r\n    \"iCloud storage\",\r\n    \"Privacy features\",\r\n]\r\n# start: int = 0\r\n# step: int = 3\r\n# while start < len(features):\r\n#     f: list[str] = features[start: start + step]\r\n#     chain = features_description_template | llm\r\n#     res = chain.invoke({\"product\": \"iphone 13 pro\", \"features\": f})\r\n#     print(res)\r\n#     start += step\r\nwith open(save_transcript_dir, \"r\") as f:\r\n    video_transcript = f.read()\r\n    \r\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=4000, chunk_overlap=0)\r\nsplits = text_splitter.split_text(video_transcript)\r\nfeatures_covered = []\r\nfor doc in splits:\r\n    chain = features_covered_template | llm\r\n    res = chain.invoke({\"transcript\": doc, \"product\": \"iphone 13 pro\", \"features\": features})\r\n"}
{"image_path": "data\\train\\00578.png", "code": "    features_covered.append(res)\r\n    print(res)\r\nprint(features_covered)\r\n# print(len(splits))\r\n# for split in splits:\r\n#     print(split)\r\n#     print(\"###################\")"}
{"image_path": "data\\train\\00579.png", "code": "from collections.abc import Iterator\r\nfrom typing import Optional\r\nfrom youtube import YouTube\r\nfrom youtube.models import Search, Video\r\nfrom youtube.schemas import (\r\n    SearchOptionalParameters,\r\n    SearchPart,\r\n    YouTubeListResponse,\r\n    YouTubeRequest,\r\n    YouTubeResponse,\r\n)\r\nfrom youtube.models import Comment\r\nfrom youtube.schemas import (\r\n    CommentThreadFilter,\r\n    CommentThreadOptionalParameters,\r\n    CommentThreadPart,\r\n    YouTubeRequest,\r\n)\r\nimport json\r\n\r\n\r\ndef get_video_id(video_title: str) -> str:\r\n    \"\"\"Get video id given the title.\"\"\"\r\n    part: SearchPart = SearchPart()\r\n    optional_parameters: SearchOptionalParameters = SearchOptionalParameters(\r\n        q=video_title, maxResults=1, type=[\"video\"]\r\n    )\r\n    search_request: YouTubeRequest = YouTubeRequest(\r\n        part=part, optional_parameters=optional_parameters\r\n    )\r\n    search_results: YouTubeResponse = youtube_client.search(search_request)\r\n    search_result: Search = search_results.items[0]\r\n    return search_result.resource_id\r\n\r\n\r\ndef list_video_comments(video_id: str, max_results: Optional[int] = 2500) -> None:\r\n    \"\"\"List a given videos comments\"\"\"\r\n    # video_id: str = get_video_id(video_title)\r\n    part: CommentThreadPart = CommentThreadPart()\r\n    filter: CommentThreadFilter = CommentThreadFilter(videoId=video_id)\r\n"}
{"image_path": "data\\train\\00580.png", "code": "    optional: CommentThreadOptionalParameters = CommentThreadOptionalParameters(\r\n        maxResults=25\r\n    )\r\n    request: YouTubeRequest = YouTubeRequest(\r\n        part=part, filter=filter, optional_parameters=optional\r\n    )\r\n    comment_iterator: Iterator = youtube_client.get_comments_iterator(request)\r\n    done: bool = False\r\n    comment_count: int = 0\r\n    for comment_threads in comment_iterator:\r\n        comments: list[str] = []\r\n        if done:\r\n            break\r\n        for comment_thread in comment_threads:\r\n            comment: Comment = comment_thread.snippet.top_level_comment\r\n            comments.append(comment.snippet.text_display)\r\n            comment_count += 1\r\n            if comment_count > max_results:\r\n                done = True\r\n                break\r\n        with open(\"comments.json\", \"r\", encoding=\"utf-8\") as f:\r\n            existing_comments: list[str] = json.load(f)\r\n\r\n        with open(\"comments.json\", \"w\", encoding=\"utf-8\") as f:\r\n            existing_comments += comments\r\n            json.dump(existing_comments, fp=f, indent=2)\r\n    return comment_count\r\n\r\n\r\nclient_secrets_file = \"/home/lyle/Downloads/search.json\"\r\nyoutube_client = YouTube(client_secret_file=client_secrets_file)\r\nyoutube_client_object = youtube_client.authenticate()\r\nyoutube_client.youtube_client = youtube_client_object\r\n\r\n\r\n# print(get_video_id(video_title='iPhone 15 Pro Review: The Good, The Bad, & The Ugly!'))\r\nprint(list_video_comments(video_id=\"cBpGq-vDr2Y\"))\r\n"}
{"image_path": "data\\train\\00581.png", "code": "from dotenv import load_dotenv\r\nload_dotenv()\r\nfrom crewai import Crew\r\nfrom textwrap import dedent\r\n\r\nfrom product_review_agents import ProductReviewAgents\r\nfrom product_review_tasks import ProductReviewTasks\r\n\r\n\r\nclass ProductReviewCrew:\r\n  def __init__(self, product):\r\n    self.product = product\r\n\r\n  def run(self):\r\n    agents = ProductReviewAgents()\r\n    tasks = ProductReviewTasks()\r\n\r\n    research_analyst_agent = agents.research_analyst()\r\n\r\n    research_task = tasks.research(research_analyst_agent, self.product)\r\n\r\n    crew = Crew(\r\n      agents=[\r\n        research_analyst_agent,\r\n      ],\r\n      tasks=[\r\n        research_task,\r\n      ],\r\n      verbose=True\r\n    )\r\n\r\n    result = crew.kickoff()\r\n    return result\r\n\r\nif __name__ == \"__main__\":\r\n  print(\"## Welcome to Product Analysis Crew\")\r\n  print('-------------------------------')\r\n  company = input(\r\n    dedent(\"\"\"\r\n      What is the product you want to analyze?\r\n"}
{"image_path": "data\\train\\00582.png", "code": "    \"\"\"))\r\n  \r\n  product_crew = ProductReviewCrew(company)\r\n  result = product_crew.run()\r\n  print(\"\\n\\n########################\")\r\n  print(\"## Here is the Report\")\r\n  print(\"########################\\n\")\r\n  print(result)"}
{"image_path": "data\\train\\00583.png", "code": "from crewai import Agent\r\nfrom tools import FindProductVideoTools, FindProductReviewTools\r\nfrom langchain.llms.openai import OpenAI\r\nfrom langchain.chat_models import ChatOpenAI\r\n\r\n\r\nclass ProductReviewAgents():\r\n    def research_analyst(self):\r\n        return Agent(\r\n        role='Product Video Researcher',\r\n        goal=\"\"\"Find the best product review videos from youtube\"\"\",\r\n        backstory=\"\"\"Known for your indepth knowledge of various videos that \r\n        analyze different products on youtube. Now you have to find the best video that \r\n        reviews the given product.\"\"\",\r\n        llm=OpenAI(temperature=0.7),\r\n        verbose=True,\r\n        tools=[\r\n            FindProductVideoTools.find_product_video_id,\r\n            FindProductReviewTools.find_product_reviews\r\n        ]\r\n  )"}
{"image_path": "data\\train\\00584.png", "code": "from crewai import Task\r\nfrom textwrap import dedent\r\n\r\nclass ProductReviewTasks():\r\n    def research(self, agent, product):\r\n        return Task(description=dedent(f\"\"\"\r\n            Collect and summarize the most recent comments from the \r\n            products review from youtube.\r\n            Maje sure to capture the sentiment of each comment, \r\n            what the user liked, did not like as well as other \r\n            features that they wish were present.\r\n\r\n            Your final answer MUST be a report that includes a\r\n            comprehensive summary of the reviews, capturing \r\n            the most loved features.\r\n            \r\n            {self.__tip_section()}\r\n\r\n            Selected product by the customer: {product}\r\n            \"\"\"),\r\n            agent=agent\r\n        )\r\n    \r\n    def __tip_section(self):\r\n        return \"If you do your BEST WORK, I'll give you a $10,000 commision!\""}
{"image_path": "data\\train\\00585.png", "code": "from langchain.agents import AgentType, Tool, initialize_agent, tool\r\nfrom langchain.llms import OpenAI\r\nfrom langchain.memory import ConversationBufferMemory\r\nfrom langchain.utilities import SerpAPIWrapper\r\nimport googlemaps\r\nimport os\r\nimport chainlit as cl\r\nfrom dotenv import load_dotenv\r\nload_dotenv()\r\n\r\n\r\n@tool\r\ndef get_agrovets(query: str) -> str:\r\n    \"\"\"Useful when you need to get agrovets in a given location. Give it a query, such as agrovets in Nairobi, Kenya.\r\n    \"\"\"\r\n    gmaps = googlemaps.Client(key=os.environ['GOOGLE_MAPS_API_KEY'])\r\n    results = gmaps.places(query=f'Get me aggrovets in {query}')\r\n    aggrovet_locations: list[dict] = list()\r\n    for result in results['results']:\r\n        bussiness: dict = dict()\r\n        bussiness['business_status'] = result['business_status']\r\n        bussiness['formatted_address'] = result['formatted_address']\r\n        bussiness['name'] = result['name']\r\n        bussiness['opening_hours'] = result.get('opening_hours', 'NaN')\r\n        aggrovet_locations.append(bussiness)\r\n    return aggrovet_locations\r\n\r\n\r\n@cl.on_chat_start\r\nasync def start():\r\n    tools: list[Tool] = [\r\n        get_agrovets\r\n    ]\r\n    llm = OpenAI(temperature=0)\r\n    memory = ConversationBufferMemory(memory_key=\"chat_history\")\r\n    agent = initialize_agent(\r\n        tools,\r\n        llm,\r\n        agent=AgentType.CONVERSATIONAL_REACT_DESCRIPTION,\r\n        verbose=True,\r\n"}
{"image_path": "data\\train\\00586.png", "code": "        memory=memory,\r\n    )\r\n    cl.user_session.set(\"agent\", agent)\r\n    \r\n\r\n@cl.on_message\r\nasync def main(message: cl.Message):\r\n    agent = cl.user_session.get(\"agent\")\r\n    msg = cl.Message(content=\"\")\r\n    await msg.send()\r\n    await cl.sleep(1)\r\n    msg.content = agent.invoke({\"input\": message.content})[\"output\"]\r\n    await msg.update()"}
{"image_path": "data\\train\\00587.png", "code": "from pydantic import Field, BaseModel\r\n\r\n\r\nclass Trip(BaseModel):\r\n    start: str = Field(description=\"start location of trip\")\r\n    end: str = Field(description=\"end location of trip\")\r\n    waypoints: list[str] = Field(description=\"list of waypoints\")\r\n    transit: str = Field(description=\"mode of transportation\")"}
{"image_path": "data\\train\\00588.png", "code": "# import openai\r\nimport logging\r\nimport time\r\n# for Palm\r\nfrom langchain.llms import GooglePalm\r\n# for OpenAI\r\nfrom langchain.chat_models import ChatGooglePalm, ChatOpenAI\r\nfrom langchain.chains import LLMChain, SequentialChain\r\nfrom prompt_templates import (\r\n    ValidationTemplate, load_secets, MappingTemplate, ItineraryTemplate)\r\n\r\n\r\nlogging.basicConfig(level=logging.INFO)\r\n\r\nclass Agent(object):\r\n    def __init__(\r\n        self,\r\n        open_ai_api_key,\r\n        model=\"gpt-3.5-turbo\",\r\n        temperature=0,\r\n        debug=True,\r\n    ):\r\n        self.logger = logging.getLogger(__name__)\r\n        self.logger.setLevel(logging.INFO)\r\n        self._openai_key = open_ai_api_key\r\n\r\n        self.chat_model = ChatOpenAI(model=model, temperature=temperature, openai_api_key=self._openai_key)\r\n        self.validation_prompt = ValidationTemplate()\r\n        self.itinerary_prompt = ItineraryTemplate()\r\n        self.mapping_prompt = MappingTemplate()\r\n        self.validation_chain = self._set_up_validation_chain(debug)\r\n        self.agent_chain = self._set_up_agent_chain(debug)\r\n\r\n    def _set_up_validation_chain(self, debug=True):\r\n        \"\"\"\r\n\r\n        Parameters\r\n        ----------\r\n        debug\r\n\r\n"}
{"image_path": "data\\train\\00589.png", "code": "        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n        validation_agent = LLMChain(\r\n            llm=self.chat_model,\r\n            prompt=self.validation_prompt.chat_prompt,\r\n            output_parser=self.validation_prompt.parser,\r\n            output_key=\"validation_output\",\r\n            verbose=debug,\r\n        )\r\n\r\n        overall_chain = SequentialChain(\r\n            chains=[validation_agent],\r\n            input_variables=[\"query\", \"format_instructions\"],\r\n            output_variables=[\"validation_output\"],\r\n            verbose=debug,\r\n        )\r\n\r\n        return overall_chain\r\n\r\n    def _set_up_agent_chain(self, debug=True):\r\n        \"\"\"\r\n\r\n        Parameters\r\n        ----------\r\n        debug\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n        travel_agent = LLMChain(\r\n            llm=self.chat_model,\r\n            prompt=self.itinerary_prompt.chat_prompt,\r\n            verbose=debug,\r\n            output_key=\"agent_suggestion\",\r\n        )\r\n\r\n        parser = LLMChain(\r\n"}
{"image_path": "data\\train\\00590.png", "code": "            llm=self.chat_model,\r\n            prompt=self.mapping_prompt.chat_prompt,\r\n            output_parser=self.mapping_prompt.parser,\r\n            verbose=debug,\r\n            output_key=\"mapping_list\",\r\n        )\r\n\r\n        overall_chain = SequentialChain(\r\n            chains=[travel_agent, parser],\r\n            input_variables=[\"query\", \"format_instructions\"],\r\n            output_variables=[\"agent_suggestion\", \"mapping_list\"],\r\n            verbose=debug,\r\n        )\r\n\r\n        return overall_chain\r\n\r\n    def suggest_travel(self, query):\r\n        \"\"\"\r\n\r\n        Parameters\r\n        ----------\r\n        query\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n        self.logger.info(\"Validating query\")\r\n        t1 = time.time()\r\n        self.logger.info(\r\n            \"Calling validation (model is {}) on user input\".format(\r\n                self.chat_model.model_name\r\n            )\r\n        )\r\n        validation_result = self.validation_chain(\r\n            {\r\n                \"query\": query,\r\n                \"format_instructions\": self.validation_prompt.parser.get_format_instructions(),\r\n            }\r\n        )\r\n"}
{"image_path": "data\\train\\00591.png", "code": "\r\n        validation_test = validation_result[\"validation_output\"].dict()\r\n        t2 = time.time()\r\n        self.logger.info(\"Time to validate request: {}\".format(round(t2 - t1, 2)))\r\n\r\n        if validation_test[\"plan_is_valid\"].lower() == \"no\":\r\n            self.logger.warning(\"User request was not valid!\")\r\n            print(\"\\n######\\n Travel plan is not valid \\n######\\n\")\r\n            print(validation_test[\"updated_request\"])\r\n            return None, None, validation_result\r\n\r\n        else:\r\n            # plan is valid\r\n            self.logger.info(\"Query is valid\")\r\n            self.logger.info(\"Getting travel suggestions\")\r\n            t1 = time.time()\r\n\r\n            self.logger.info(\r\n                \"User request is valid, calling agent (model is {})\".format(\r\n                    self.chat_model.model_name\r\n                )\r\n            )\r\n\r\n            agent_result = self.agent_chain(\r\n                {\r\n                    \"query\": query,\r\n                    \"format_instructions\": self.mapping_prompt.parser.get_format_instructions(),\r\n                }\r\n            )\r\n\r\n            trip_suggestion = agent_result[\"agent_suggestion\"]\r\n            list_of_places = agent_result[\"mapping_list\"].dict()\r\n            t2 = time.time()\r\n            self.logger.info(\"Time to get suggestions: {}\".format(round(t2 - t1, 2)))\r\n\r\n            return trip_suggestion, list_of_places, validation_result\r\n\r\n\r\nsecrets = load_secets()    \r\n\r\n"}
{"image_path": "data\\train\\00592.png", "code": "query = \"\"\"\r\n        I want to do a three day trip across Kenya's Rift valley.\r\n        \"\"\"\r\ntravel_agent = Agent(\r\n   open_ai_api_key=secrets['OPENAI_API_KEY'],\r\n   debug=True,\r\n)\r\n\r\nitinerary, list_of_places, validation = travel_agent.suggest_travel(query)\r\nprint(validation)\r\nprint(itinerary)\r\nprint(list_of_places)"}
{"image_path": "data\\train\\00593.png", "code": "from langchain.prompts.chat import (\r\n    ChatPromptTemplate,\r\n    SystemMessagePromptTemplate,\r\n    HumanMessagePromptTemplate,\r\n)\r\nfrom langchain.output_parsers import PydanticOutputParser\r\nfrom pydantic import BaseModel, Field\r\nfrom dotenv import load_dotenv\r\nfrom pathlib import Path\r\nimport os\r\nfrom models import Trip\r\n\r\n\r\ndef load_secets():\r\n    load_dotenv()\r\n    env_path = Path(\".\") / \".env\"\r\n    load_dotenv(dotenv_path=env_path)\r\n\r\n    open_ai_key = os.getenv(\"OPENAI_API_KEY\")\r\n    google_palm_key = os.getenv(\"GOOGLE_PALM_API_KEY\")\r\n\r\n    return {\r\n        \"OPENAI_API_KEY\": open_ai_key,\r\n        \"GOOGLE_PALM_API_KEY\": google_palm_key,\r\n    }\r\n\r\n\r\nclass Validation(BaseModel):\r\n    plan_is_valid: str = Field(\r\n        description=\"This field is 'yes' if the plan is feasible, 'no' otherwise\"\r\n    )\r\n    updated_request: str = Field(description=\"Your update to the plan\")\r\n\r\n\r\nclass ValidationTemplate(object):\r\n    def __init__(self):\r\n        self.system_template = \"\"\"\r\n      You are a travel agent who helps users make exciting travel plans.\r\n\r\n      The user's request will be denoted by four hashtags. Determine if the user's\r\n"}
{"image_path": "data\\train\\00594.png", "code": "      request is reasonable and achievable within the constraints they set.\r\n\r\n      A valid request should contain the following:\r\n      - A start and end location\r\n      - A trip duration that is reasonable given the start and end location\r\n      - Some other details, like the user's interests and/or preferred mode of transport\r\n\r\n      Any request that contains potentially harmful activities is not valid, regardless of what\r\n      other details are provided.\r\n\r\n      If the request is not valid, set\r\n      plan_is_valid = 0 and use your travel expertise to update the request to make it valid,\r\n      keeping your revised request shorter than 100 words.\r\n\r\n      If the request seems reasonable, then set plan_is_valid = 1 and\r\n      don't revise the request.\r\n\r\n      {format_instructions}\r\n    \"\"\"\r\n\r\n        self.human_template = \"\"\"\r\n      ####{query}####\r\n    \"\"\"\r\n\r\n        self.parser = PydanticOutputParser(pydantic_object=Validation)\r\n\r\n        self.system_message_prompt = SystemMessagePromptTemplate.from_template(\r\n            self.system_template,\r\n            partial_variables={\r\n                \"format_instructions\": self.parser.get_format_instructions()\r\n            },\r\n        )\r\n        self.human_message_prompt = HumanMessagePromptTemplate.from_template(\r\n            self.human_template, input_variables=[\"query\"]\r\n        )\r\n\r\n        self.chat_prompt = ChatPromptTemplate.from_messages(\r\n            [self.system_message_prompt, self.human_message_prompt]\r\n        )\r\n\r\n"}
{"image_path": "data\\train\\00595.png", "code": "\r\nclass ItineraryTemplate(object):\r\n    def __init__(self):\r\n        self.system_template = \"\"\"\r\n      You are a travel agent who helps users make exciting travel plans.\r\n\r\n      The user's request will be denoted by four hashtags. Convert the\r\n      user's request into a detailed itinerary describing the places\r\n      they should visit and the things they should do.\r\n\r\n      Try to include the specific address of each location.\r\n\r\n      Remember to take the user's preferences and timeframe into account,\r\n      and give them an itinerary that would be fun and doable given their constraints.\r\n\r\n      Return the itinerary as a bulleted list with clear start and end locations.\r\n      Be sure to mention the type of transit for the trip.\r\n      If specific start and end locations are not given, choose ones that you think are suitable and give specific addresses.\r\n      Your output must be the list and nothing else.\r\n    \"\"\"\r\n\r\n        self.human_template = \"\"\"\r\n      ####{query}####\r\n    \"\"\"\r\n\r\n        self.system_message_prompt = SystemMessagePromptTemplate.from_template(\r\n            self.system_template,\r\n        )\r\n        self.human_message_prompt = HumanMessagePromptTemplate.from_template(\r\n            self.human_template, input_variables=[\"query\"]\r\n        )\r\n\r\n        self.chat_prompt = ChatPromptTemplate.from_messages(\r\n            [self.system_message_prompt, self.human_message_prompt]\r\n        )\r\n\r\n\r\nclass MappingTemplate(object):\r\n    def __init__(self):\r\n        self.system_template = \"\"\"\r\n"}
{"image_path": "data\\train\\00596.png", "code": "      You an agent who converts detailed travel plans into a simple list of locations.\r\n\r\n      The itinerary will be denoted by four hashtags. Convert it into\r\n      list of places that they should visit. Try to include the specific address of each location.\r\n\r\n      Your output should always contain the start and end point of the trip, and may also include a list\r\n      of waypoints. It should also include a mode of transit. The number of waypoints cannot exceed 20.\r\n      If you can't infer the mode of transit, make a best guess given the trip location.\r\n\r\n      For example:\r\n\r\n      ####\r\n      Itinerary for a 2-day driving trip within London:\r\n      - Day 1:\r\n        - Start at Buckingham Palace (The Mall, London SW1A 1AA)\r\n        - Visit the Tower of London (Tower Hill, London EC3N 4AB)\r\n        - Explore the British Museum (Great Russell St, Bloomsbury, London WC1B 3DG)\r\n        - Enjoy shopping at Oxford Street (Oxford St, London W1C 1JN)\r\n        - End the day at Covent Garden (Covent Garden, London WC2E 8RF)\r\n      - Day 2:\r\n        - Start at Westminster Abbey (20 Deans Yd, Westminster, London SW1P 3PA)\r\n        - Visit the Churchill War Rooms (Clive Steps, King Charles St, London SW1A 2AQ)\r\n        - Explore the Natural History Museum (Cromwell Rd, Kensington, London SW7 5BD)\r\n        - End the trip at the Tower Bridge (Tower Bridge Rd, London SE1 2UP)\r\n      #####\r\n\r\n      Output:\r\n      Start: Buckingham Palace, The Mall, London SW1A 1AA\r\n      End: Tower Bridge, Tower Bridge Rd, London SE1 2UP\r\n      Waypoints: [\"Tower of London, Tower Hill, London EC3N 4AB\", \"British Museum, Great Russell St, Bloomsbury, London WC1B 3DG\", \"Oxford St, London W1C 1JN\", \"Covent Garden, London WC2E 8RF\",\"Westminster, London SW1A 0AA\", \"St. James's Park, London\", \"Natural History Museum, Cromwell Rd, Kensington, London SW7 5BD\"]\r\n      Transit: driving\r\n\r\n      Transit can be only one of the following options: \"driving\", \"train\", \"bus\" or \"flight\".\r\n\r\n      {format_instructions}\r\n    \"\"\"\r\n\r\n        self.human_template = \"\"\"\r\n      ####{agent_suggestion}####\r\n    \"\"\"\r\n"}
{"image_path": "data\\train\\00597.png", "code": "\r\n        self.parser = PydanticOutputParser(pydantic_object=Trip)\r\n\r\n        self.system_message_prompt = SystemMessagePromptTemplate.from_template(\r\n            self.system_template,\r\n            partial_variables={\r\n                \"format_instructions\": self.parser.get_format_instructions()\r\n            },\r\n        )\r\n        self.human_message_prompt = HumanMessagePromptTemplate.from_template(\r\n            self.human_template, input_variables=[\"agent_suggestion\"]\r\n        )\r\n\r\n        self.chat_prompt = ChatPromptTemplate.from_messages(\r\n            [self.system_message_prompt, self.human_message_prompt]\r\n        )"}
{"image_path": "data\\train\\00598.png", "code": "from redis import Redis\r\n\r\nredis = Redis()\r\n\r\npage = '1'\r\nres = redis.zrevrange(f'quote_authors', 0, 10, withscores=True)\r\nprint(res)"}
{"image_path": "data\\train\\00599.png", "code": "from youtube.models import (\r\n    Playlist, PlaylistItem, Search\r\n)\r\nfrom api.database.models import Video\r\nfrom youtube import YouTube\r\nfrom youtube.resources.schemas import (\r\n    SearchPart, SearchFilter, SearchOptionalParameters\r\n)\r\nfrom youtube.resources.schemas import (\r\n    YouTubeResponse, CreateStatus, CreatePlaylistSnippet, CreatePlaylistSchema,\r\n    VideoResourceId, CreatePlaylistItemSnippet, CreatePlaylistItem, YouTubeRequest\r\n)\r\nfrom redis import Redis\r\nimport logging\r\nfrom dotenv import load_dotenv\r\nfrom config import RedisSettings, Config\r\nfrom api.database.models import Channel\r\nfrom api.database.crud import get_all_channels, get_channel_by_title\r\nfrom api.database.database import get_db\r\nfrom json import loads, dumps\r\nfrom datetime import timedelta\r\n\r\n\r\nload_dotenv()\r\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s', datefmt='%d-%b-%y %H:%M:%S')\r\n\r\nredis_config: RedisSettings = RedisSettings()\r\nredis: Redis = Redis(\r\n    host=redis_config.redis_host,\r\n    port=redis_config.redis_port,\r\n    decode_responses=True\r\n)\r\nconfig: Config = Config()\r\n\r\n\r\ndef get_youtube_client(client_secret_file: str) -> YouTube:\r\n    logging.info('Creating the YouTube client.')\r\n    youtube: YouTube = YouTube(client_secret_file=client_secret_file)\r\n    logging.info('Authenticating the user.')\r\n    youtube.authenticate()\r\n"}
{"image_path": "data\\train\\00600.png", "code": "    logging.info('Request authenticated.')\r\n    return youtube\r\n\r\n\r\ndef create_playlist(title: str, \r\n                    description: str, \r\n                    youtube: YouTube,\r\n                    default_language: str = 'en', \r\n                    privacy_status: str = 'public') -> Playlist:\r\n    snippet: CreatePlaylistSnippet = CreatePlaylistSnippet(\r\n        title=title,\r\n        description=description,\r\n        defaultLanguage=default_language\r\n    )\r\n    create_schema: CreatePlaylistSchema = CreatePlaylistSchema(\r\n        snippet=snippet,\r\n        status=CreateStatus(privacyStatus=privacy_status)\r\n    )\r\n    playlist: Playlist = youtube.insert_playlist(create_schema)\r\n    return playlist\r\n\r\n\r\ndef get_playlists() -> dict[str, dict]:\r\n    playlists: dict[str, str] = {\r\n        'Daily Videos': {\r\n            'id': 'PL_26vmg8W_AcEEl_Bo2AhziS-93r6b8bu',\r\n            'url': 'https://www.youtube.com/playlist?list=PL_26vmg8W_AcEEl_Bo2AhziS-93r6b8bu'\r\n        }\r\n    }\r\n    return playlists\r\n\r\n\r\ndef get_playlist_id(name: str) -> str:\r\n    playlists: dict[str, dict] = get_playlists()\r\n    return playlists[name]['id']\r\n    \r\n    \r\ndef get_playlist_url(name: str) -> str:\r\n    playlists: dict[str, dict] = get_playlists()\r\n    return playlists[name]['url']\r\n"}
{"image_path": "data\\train\\00601.png", "code": "\r\n\r\ndef get_channels() -> list[Channel]:\r\n    logging.info('Getting the channel details from the database.')\r\n    channels: list[Channel] = get_all_channels(get_db)\r\n    logging.info('Fetched the channel details from the database.')\r\n    return channels\r\n\r\ndef get_channel_names() -> list[str]:\r\n    logging.info('Fetching the channel names.')\r\n    channels: list[Channel] = get_all_channels(get_db)\r\n    logging.info('Fetched the channel names.')\r\n    return [channel.title for channel in channels]\r\n\r\n\r\ndef get_channel_id(name: str) -> str:\r\n    channel: Channel = get_channel_by_title(name, get_db)\r\n    return channel.id\r\n\r\n\r\ndef find_latest_video(channel_id: str, youtube_client: YouTube) -> Video:\r\n    if redis.get(name=f'latest:{channel_id}'):\r\n        logging.info('Found video in cache, retrieving it.')\r\n        video_str: str = redis.get(name=f'latest:{channel_id}')\r\n        video: Video = Video(**loads(video_str))\r\n        logging.info('Successfully retrieved video from cache.')\r\n    else:\r\n        logging.info('Video missing from cache, retrieving from youtube.')\r\n        part: SearchPart = SearchPart()\r\n        optional_parameters: SearchOptionalParameters = SearchOptionalParameters(\r\n            q='',\r\n            maxResults=1,\r\n            type=['video'],\r\n            channelId=channel_id,\r\n            order='date'\r\n        )\r\n        search: YouTubeRequest = YouTubeRequest(part=part, optional_parameters=optional_parameters)\r\n        response: YouTubeResponse = youtube_client.search(search)\r\n        logging.info('Retrieved the latest video from youtube.')\r\n        search_responses: list[Search] = response.items\r\n"}
{"image_path": "data\\train\\00602.png", "code": "        search_resp: Search = search_responses[0]\r\n        video: Video = Video(**search_resp.model_dump(exclude={'thumbnails'}))\r\n        video_str: str = dumps(video.dict(), default=str)\r\n        logging.info('caching the retrieved video.')\r\n        redis.set(name=f'latest:{channel_id}', value=video_str)\r\n        logging.info('Successfully cached the retrieved video.')\r\n        logging.info('Setting an expiration time of %d for the cached video.', config.expiration_time)\r\n        redis.setex(f'latest:{channel_id}', value=video_str, time=timedelta(seconds=config.expiration_time))\r\n    return video\r\n\r\ndef add_video_to_playlist(video: Video, \r\n                          playlist_id: str, \r\n                          youtube: YouTube, \r\n                          position: int = 0) -> PlaylistItem | None:\r\n    playlist_item: PlaylistItem = None\r\n    if redis.setnx(name=f'{playlist_id}:{video.resource_id}', value=video.resource_id):\r\n        logging.info('The video \"%s\" odes not exist in playlist, adding it.', video.title)\r\n        resource_id: VideoResourceId = VideoResourceId(videoId=video.resource_id)\r\n        snippet: CreatePlaylistItemSnippet = CreatePlaylistItemSnippet(\r\n            playlistId=playlist_id,\r\n            resourceId=resource_id,\r\n            position=position\r\n        )\r\n        create: CreatePlaylistItem = CreatePlaylistItem(snippet=snippet)\r\n        logging.info('Inserting \"%s\" into playlist.', video.title)\r\n        playlist_item: PlaylistItem = youtube.insert_playlist_item(create)\r\n        logging.info('Inserted \"%s\" to playlist.', video.title)\r\n        logging.info('Adding \"%s\" to \"unwatched list\".', video.title)\r\n        video.save()\r\n        logging.info('Added \"%s\" to \"unwatched list\".', video.title)\r\n        logging.info('Setting the video expiration time of %d for video.', config.expiration_time)\r\n        video.expire(num_seconds=3600)\r\n    return playlist_item\r\n\r\n\r\ndef delete_video_playlist(playlist_item_id: str, youtube: YouTube) -> None:\r\n    youtube.delete_playlist_item(playlist_item_id)\r\n    \r\n    \r\ndef workflow(youtube: YouTube, channel_names: list[str], playlist_name: str = 'Daily Videos'):\r\n"}
{"image_path": "data\\train\\00603.png", "code": "    logging.info('Getting the playlist id for %s', playlist_name)\r\n    playlist_id: str = get_playlist_id(playlist_name)\r\n    logging.info('The playlist %s id is %s', playlist_name, playlist_id)\r\n    playlist_items: list[str] = []\r\n    for channel_name in channel_names:\r\n        logging.info('Getting the channel id for \"%s\".', channel_name)\r\n        channel_id: str = get_channel_id(channel_name)\r\n        logging.info('The channel \"%s\" has id \"%s\".', channel_name, channel_id)\r\n        logging.info('Getting the latest video for channel \"%s\".', channel_name)\r\n        latest_video: Video = find_latest_video(channel_id, youtube)\r\n        logging.info('Fetched the latest video for %s.', channel_name)\r\n        logging.info('The latest video for channel: \"%s\" is :\"%s\"', channel_name, latest_video.title)\r\n        logging.info('Creating a playlist item for video: \"%s\"', latest_video.title)\r\n        playlist_item: PlaylistItem = add_video_to_playlist(latest_video, playlist_id, youtube, position=0)\r\n        if playlist_item:\r\n            logging.info('Added \"%s\" to \"%s\".', latest_video.title, playlist_name)\r\n            playlist_items.append({\r\n                'id': playlist_item.id,\r\n                'title': playlist_item.snippet.title\r\n            })\r\n        else:\r\n            logging.info('The video \"%s\" already exists in playlist \"%s\".', latest_video.title, playlist_name)\r\n        logging.info('Video id: %s.', latest_video.resource_id)\r\n    if playlist_items:\r\n        logging.info('Added all the latest videos to the playlist.')\r\n    else:\r\n        logging.info('Did not add any videos to playlist.')\r\n    return playlist_items\r\n\r\n\r\nclient_secret_file: str = 'client_secret.json'\r\nyoutube: YouTube = get_youtube_client(client_secret_file)\r\n# playlist_id: str = get_playlist_id('Daily Videos')\r\n# channel_id: str = get_channel_id('CNBC')\r\n# latest_video: Video = find_latest_video(channel_id, youtube)\r\n# playlist_item: PlaylistItem = add_video_to_playlist(latest_video.resource_id, playlist_id, youtube, position=0)\r\n# delete_video_playlist('UExfMjZ2bWc4V19BY0VFbF9CbzJBaHppUy05M3I2YjhidS41NkI0NEY2RDEwNTU3Q0M2', youtube)\r\n# ids = ['UExfMjZ2bWc4V19BY0VFbF9CbzJBaHppUy05M3I2YjhidS41NkI0NEY2RDEwNTU3Q0M2', 'UExfMjZ2bWc4V19BY0VFbF9CbzJBaHppUy05M3I2YjhidS4yODlGNEE0NkRGMEEzMEQy', 'UExfMjZ2bWc4V19BY0VFbF9CbzJBaHppUy05M3I2YjhidS4wMTcyMDhGQUE4NTIzM0Y5', 'UExfMjZ2bWc4V19BY0VFbF9CbzJBaHppUy05M3I2YjhidS41MjE1MkI0OTQ2QzJGNzNG', 'UExfMjZ2bWc4V19BY0VFbF9CbzJBaHppUy05M3I2YjhidS4wOTA3OTZBNzVEMTUzOTMy', 'UExfMjZ2bWc4V19BY0VFbF9CbzJBaHppUy05M3I2YjhidS4xMkVGQjNCMUM1N0RFNEUx', 'UExfMjZ2bWc4V19BY0VFbF9CbzJBaHppUy05M3I2YjhidS41MzJCQjBCNDIyRkJDN0VD', 'UExfMjZ2bWc4V19BY0VFbF9CbzJBaHppUy05M3I2YjhidS5DQUNERDQ2NkIzRUQxNTY1', 'UExfMjZ2bWc4V19BY0VFbF9CbzJBaHppUy05M3I2YjhidS45NDk1REZENzhEMzU5MDQz']\r\n# for id in ids:\r\n#     delete_video_playlist(id, youtube)\r\n"}
{"image_path": "data\\train\\00604.png", "code": "channel_names: list[str] = get_channel_names()\r\nplaylist_name: str = 'Daily Videos'\r\nplaylist_items: list[str] = workflow(youtube, channel_names)\r\n\r\n# print(get_channel_id('Asianometry'))\r\n# print(redis.setex(name='PL_26vmg8W_AcEEl_Bo2AhziS-93r6b8bu:DqkZCzjdtbw', time=1, value=''))\r\n# print(redis.setex(name='PL_26vmg8W_AcEEl_Bo2AhziS-93r6b8bu:VzW_BtXSw6A', time=1, value=''))\r\n# print(redis.get(name='PL_26vmg8W_AcEEl_Bo2AhziS-93r6b8bu:DqkZCzjdtbw'))\r\n# print(find_latest_video('UC1LpsuAUaKoMzzJSEt5WImw', youtube))\r\n# channels: list[Channel] = get_all_channels(get_db)\r\n# latest_videos: list[Video] = [find_latest_video(channel.id, youtube) for channel in channels]\r\n# videos: list[Video] = Video.find().all()\r\n# for channel in channels:\r\n#     redis.setex(f'latest:{channel.id}', value='video_str', time=1)\r\n# for video in latest_videos:\r\n#     pl_id: str = 'PL_26vmg8W_AcEEl_Bo2AhziS-93r6b8bu'\r\n#     redis.setex(name=f'{pl_id}:{video.resource_id}', time=1, value='')\r\n# for video in videos:\r\n#     video.expire(num_seconds=1)"}
{"image_path": "data\\train\\00605.png", "code": "from api import create_app\r\n\r\n\r\napp = create_app()"}
{"image_path": "data\\train\\00606.png", "code": "from datetime import datetime\r\nfrom uuid import uuid4\r\nfrom redis_om import Migrator\r\nfrom redis_om.model import NotFoundError\r\nfrom api.database.models import Video\r\nfrom youtube.models import Search\r\nfrom youtube import YouTube\r\nfrom youtube.resources.schemas import(\r\n    SearchFilter, SearchPart, SearchOptionalParameters, YouTubeRequest, YouTubeResponse\r\n)\r\n\r\n\r\nclient_secret_file: str = 'client_secret.json'\r\nyoutube: YouTube = YouTube(client_secret_file=client_secret_file)\r\nyoutube.authenticate()\r\n\r\nMigrator().run()\r\n\r\n# part: SearchPart = SearchPart()\r\n# optional_parameters: SearchOptionalParameters = SearchOptionalParameters(\r\n#     q='Python programming',\r\n#     maxResults=2,\r\n#     type=['video']\r\n# )\r\n# search: YouTubeRequest = YouTubeRequest(part=part, optional_parameters=optional_parameters)\r\n# response: YouTubeResponse = youtube.search(search)\r\n# search_resp: Search = response.items[0]\r\n\r\n# video: Video = Video(**search_resp.model_dump(exclude={'thumbnails'}))\r\n# print(video)\r\nvideos: list[Video] = Video.find().all()\r\n# for video in videos:\r\n#     video.expire(num_seconds=1)\r\nprint(videos)"}
{"image_path": "data\\train\\00607.png", "code": "from celery_app import celery_app\r\n\r\n\r\nif __name__ == '__main__':\r\n    args = ['worker', '--loglevel=INFO']\r\n    # celery_app.autodiscover_tasks(['tasks'])\r\n    celery_app.worker_main(argv=args)"}
{"image_path": "data\\train\\00608.png", "code": "from pydantic_settings import BaseSettings\r\nfrom dotenv import load_dotenv\r\n\r\nload_dotenv()\r\n\r\n\r\nclass PostgresSettings(BaseSettings):\r\n    postgres_host: str\r\n    postgres_port: int\r\n    postgres_user: str\r\n    postgres_password: str\r\n    postgres_db: str\r\n    \r\n    @property\r\n    def sqlalchemy_db_url(self) -> str:\r\n        return f\"postgresql://{self.postgres_user}:{self.postgres_password}@{self.postgres_host}:{self.postgres_port}/{self.postgres_db}\"\r\n\r\n\r\nclass RedisSettings(BaseSettings):\r\n    redis_host: str\r\n    redis_port: int\r\n\r\n    \r\nclass CeleryConfig(BaseSettings):\r\n    celery_broker_url: str\r\n    celery_result_backend: str\r\n\r\n\r\nclass Config(BaseSettings):\r\n    expiration_time: int\r\n"}
{"image_path": "data\\train\\00609.png", "code": "from youtube import YouTube\r\nfrom youtube.models import Channel\r\nfrom youtube.resources.schemas import YouTubeResponse\r\n\r\n\r\nclient_secret_file: str = 'client_secret.json'\r\nyoutube: YouTube = YouTube(client_secret_file=client_secret_file)\r\nyoutube.authenticate()\r\n\r\nchannel_name: str = 'Ticker Symbol You'\r\nsearch_response: YouTubeResponse = youtube.find_channel_by_name(channel_name)\r\nprint(search_response.items[0])"}
{"image_path": "data\\train\\00610.png", "code": "from json import load\r\nfrom typing import Any\r\nimport streamlit as st\r\nfrom youtube import YouTube\r\nfrom youtube.models import Search, Video\r\nfrom youtube.resources.schemas import (\r\n    CreatePlaylistSchema, CreatePlaylistSnippet, CreateStatus, CreatePlaylistItem, CreatePlaylistItemSnippet,\r\n    VideoResourceId, YouTubeRequest, SearchPart, SearchOptionalParameters, SearchFilter\r\n)\r\nfrom typing import Any\r\n\r\n\r\nclient_secret_file: str = 'client_secret.json'\r\nyoutube: YouTube = YouTube(client_secret_file=client_secret_file)\r\nyoutube.authenticate()\r\n\r\n\r\ndef load_data(file_name: str = 'live-news.json') -> dict[str, Any]:\r\n    \"\"\"Load a json file.\"\"\"\r\n    with open(file_name, 'r', encoding='utf-8') as f:\r\n        data: dict[str, Any] = load(f)\r\n    return data\r\n\r\ndef search_news(text: str) -> list[dict[str, Any]]:\r\n    part: SearchPart = SearchPart()\r\n    optional_parameters: SearchOptionalParameters = SearchOptionalParameters(\r\n        q=text,\r\n        maxResults=5,\r\n        eventType='live',\r\n        type=['video']\r\n    )\r\n    search = YouTubeRequest(part=part, optional_parameters=optional_parameters)\r\n    results: list[Search] = youtube.search(search).items\r\n    results: dict[str, Any] = [result.model_dump() for result in results]\r\n    return results\r\n\r\ndef search_video(video_id: str) -> dict[str, Any]:\r\n    return youtube.find_video_by_id(video_id).model_dump()\r\n\r\ndef get_thumbnail_url(data: dict[str, Any]) -> str:\r\n"}
{"image_path": "data\\train\\00611.png", "code": "    \"\"\"Get a video thumbnail.\"\"\"\r\n    thumbnail_key: dict[str, Any] = {}\r\n    if data.get('high'):\r\n        thumbnail_key = data.get('high')\r\n    elif data.get('medium'):\r\n        thumbnail_key = data.get('high')\r\n    elif data.get('standard'):\r\n        thumbnail_key = data.get('high')\r\n    else:\r\n        thumbnail_key = data.get('high')\r\n    return thumbnail_key.get('url')\r\n\r\ndef get_caption(data: dict[str, Any]) -> str:\r\n    return data.get('title', 'Caption')\r\n\r\ndef get_description(data: dict[str, Any]) -> str:\r\n    return data.get('description', 'Description')\r\n\r\nst.title(\"Live News Bot.\")\r\n\r\n# React to user input\r\nif prompt := st.chat_input(\"What is up?\"):\r\n    # Display user message in chat message container\r\n    with st.chat_message('user'):\r\n        st.markdown(f'Finding latest news videos mentioning \"{prompt}\"')\r\n    # Display assistant response in chat message container\r\n    with st.spinner('Searching for the latest live news coverage...'):\r\n        search_results: list[dict[str, Any]] = search_news(prompt)\r\n    # search_results: list[dict[str, Any]] = load_data()\r\n    for search_result in search_results: \r\n        video_id: str = search_result.get('resource_id')\r\n        with st.spinner('Loading the news piece...'):\r\n            video: dict[str, Any] = search_video(video_id)\r\n        with st.chat_message(\"assistant\"):\r\n            url: str = f'https://www.youtube.com/watch?v={video_id}'\r\n            st.video(url)\r\n            st.markdown(get_description(video['snippet']))\r\n\r\n# videos: list[dict[str, Any]] = load_data()\r\n# video: dict[str, Any] = search_video(videos[0].get('resource_id'))\r\n"}
{"image_path": "data\\train\\00612.png", "code": "# print(video)"}
{"image_path": "data\\train\\00613.png", "code": "from langchain.agents import AgentType, initialize_agent\r\nfrom langchain.chat_models import ChatOpenAI\r\nfrom langchain.tools import BaseTool, StructuredTool, Tool, tool\r\nfrom dotenv import load_dotenv\r\nfrom pydantic.v1 import BaseModel, Field\r\nfrom typing import Optional, Type\r\nfrom pydantic_settings import BaseSettings\r\nfrom langchain.callbacks.manager import (\r\n    AsyncCallbackManagerForToolRun,\r\n    CallbackManagerForToolRun,\r\n)\r\nfrom youtube import YouTube\r\nfrom youtube.models import Search\r\nfrom youtube.resources.schemas import (\r\n    CreatePlaylistSchema, CreatePlaylistSnippet, CreateStatus, CreatePlaylistItem, CreatePlaylistItemSnippet,\r\n    VideoResourceId, YouTubeRequest, SearchPart, SearchOptionalParameters, SearchFilter, \r\n    YouTubeResponse\r\n)\r\n\r\n\r\nload_dotenv()\r\n\r\nclass Config(BaseSettings):\r\n    open_ai_token: str\r\n\r\nconfig: Config = Config()\r\nclient_secret_file: str = 'client_secret.json'\r\nyoutube: YouTube = YouTube(client_secret_file=client_secret_file)\r\nyoutube.authenticate()\r\n\r\nclass YouTubeChannelTitleSearch(BaseModel):\r\n    title: str\r\n\r\n\r\nclass YouTubeChannelTitleSearchTool(BaseTool):\r\n    name = \"youtube_title_channel_search\"\r\n    description = \"\"\"\r\n    useful when you need to find information about a channel when provided with the title. \r\n    To use this tool you must provide the channel title.\r\n    \"\"\"\r\n"}
{"image_path": "data\\train\\00614.png", "code": "    args_schema: Type[BaseModel] = YouTubeChannelTitleSearch\r\n\r\n    def _run(\r\n        self, title: str, \r\n        run_manager: Optional[CallbackManagerForToolRun] = None\r\n    ) -> str:\r\n        \"\"\"Use the tool.\"\"\"\r\n        youtube_response: YouTubeResponse = youtube.find_channel_by_name(title)\r\n        search_results: list[Search] = youtube_response.items\r\n        return search_results[0]\r\n\r\n    async def _arun(\r\n        self, query: str, run_manager: Optional[AsyncCallbackManagerForToolRun] = None\r\n    ) -> str:\r\n        \"\"\"Use the tool asynchronously.\"\"\"\r\n        raise NotImplementedError(\"Calculator does not support async\")\r\n    \r\n\r\nclass YouTubeChannelSearch(BaseModel):\r\n    id: str\r\n\r\n\r\nclass YouTubeChannelSearchTool(BaseTool):\r\n    name = \"youtube_channel_search\"\r\n    description = \"\"\"\r\n    useful when you ned to find information about a channel when provided with the channel id. \r\n    To use this tool you must provide the channel id.\r\n    \"\"\"\r\n    args_schema: Type[BaseModel] = YouTubeChannelSearch\r\n\r\n    def _run(\r\n        self, \r\n        id: str, \r\n        run_manager: Optional[CallbackManagerForToolRun] = None\r\n    ) -> str:\r\n        \"\"\"Use the tool.\"\"\"\r\n        youtube_channel: YouTubeResponse = youtube.find_channel_by_id(id)\r\n        return youtube_channel\r\n\r\n    async def _arun(\r\n"}
{"image_path": "data\\train\\00615.png", "code": "        self, query: str, run_manager: Optional[AsyncCallbackManagerForToolRun] = None\r\n    ) -> str:\r\n        \"\"\"Use the tool asynchronously.\"\"\"\r\n        raise NotImplementedError(\"Calculator does not support async\")\r\n\r\n\r\nclass YouTubeChannelVideoSearchTool(BaseTool):\r\n    name = \"youtube_channel_video_search\"\r\n    description = \"useful for when you need to answer questions about videos for a youtube channel\"\r\n    args_schema: Type[BaseModel] = YouTubeChannelSearch\r\n\r\n    def _run(\r\n        self, query: str, run_manager: Optional[CallbackManagerForToolRun] = None\r\n    ) -> str:\r\n        \"\"\"Use the tool.\"\"\"\r\n        return ''\r\n\r\n    async def _arun(\r\n        self, query: str, run_manager: Optional[AsyncCallbackManagerForToolRun] = None\r\n    ) -> str:\r\n        \"\"\"Use the tool asynchronously.\"\"\"\r\n        raise NotImplementedError(\"Calculator does not support async\")\r\n\r\nllm = ChatOpenAI(\r\n    temperature=0, \r\n    openai_api_key=config.open_ai_token,\r\n    )\r\n\r\ntools = [\r\n    YouTubeChannelTitleSearchTool(), \r\n    YouTubeChannelVideoSearchTool(),\r\n    YouTubeChannelSearchTool()\r\n    ]\r\nagent = initialize_agent(\r\n    tools, \r\n    llm, \r\n    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, \r\n    verbose=True,\r\n    handle_parsing_errors=True\r\n)\r\n"}
{"image_path": "data\\train\\00616.png", "code": "\r\nquery: str = \"\"\"\r\nFind the id of the youtube channel \"Ark Invest\", then using the id, find the number of subcribers \r\nfor the channel.\r\n\"\"\"\r\n\r\nres = agent.run(query)\r\nprint(res)"}
{"image_path": "data\\train\\00617.png", "code": "from celery import Celery\r\nfrom config import CeleryConfig\r\n\r\n\r\ncelery_app: Celery = Celery(__name__)\r\ncelery_app.config_from_object(CeleryConfig)\r\ncelery_app.conf.beat_schedule = {\r\n        'clear-daily-playlist': {\r\n            'task': 'tasks.clear_daily_playlist',\r\n            'schedule': 10\r\n        }\r\n    }\r\ncelery_app.autodiscover_tasks(['tasks'])\r\n"}
{"image_path": "data\\train\\00618.png", "code": "from celery_app import celery_app\r\nimport logging\r\nfrom play_list import get_youtube_client, get_channel_names, workflow\r\nfrom youtube import YouTube\r\n\r\n\r\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s', datefmt='%d-%b-%y %H:%M:%S')\r\n\r\n\r\n@celery_app.task\r\ndef create_daily_playlist() -> None:\r\n    client_secret_file: str = 'client_secret.json'\r\n    logging.info('Getting the youtube client.')\r\n    youtube: YouTube = get_youtube_client(client_secret_file)\r\n    logging.info('Getting the channel names.')\r\n    channel_names: list[str] = get_channel_names()[:2]\r\n    logging.info('Fetched the channel names: ')\r\n    logging.info(channel_names)\r\n    playlist_name: str = 'Daily Videos'\r\n    logging.info('Fetching and adding latest videos to the playlist \"%s\".', playlist_name)\r\n    playlist_items: list[str] = workflow(youtube, channel_names, playlist_name)\r\n    if playlist_items:\r\n        logging.info('Added the following playlist items: ')\r\n        logging.info(playlist_items)\r\n        logging.info('Notifying via email.')\r\n    return playlist_items\r\n\r\n\r\n@celery_app.task\r\ndef clear_daily_playlist() -> None:\r\n    logging.info('Clearing daily playlist.')"}
{"image_path": "data\\train\\00619.png", "code": "from celery import Celery\r\nfrom config import CeleryConfig\r\n\r\n\r\ncelery_app: Celery = Celery(__name__)\r\ncelery_app.config_from_object(CeleryConfig)\r\ncelery_app.conf.beat_schedule = {\r\n        'create-daily-playlist': {\r\n            'task': 'tasks.create_daily_playlist',\r\n            'schedule': 10\r\n        }\r\n    }\r\ncelery_app.autodiscover_tasks(['tasks'])\r\n"}
{"image_path": "data\\train\\00620.png", "code": "from youtube import YouTube\r\nfrom youtube.models import Search\r\nfrom youtube.resources.schemas import (\r\n    CreatePlaylistSchema, CreatePlaylistSnippet, CreateStatus, CreatePlaylistItem, CreatePlaylistItemSnippet,\r\n    VideoResourceId, YouTubeRequest, SearchPart, SearchOptionalParameters, SearchFilter,\r\n    CommentThreadPart, CommentThreadFilter, CommentThreadOptionalParameters, YouTubeResponse,\r\n    Part, Filter, OptionalParameters\r\n)\r\nfrom typing import Any\r\n\r\n\r\nclient_secret_file: str = 'client_secret.json'\r\nyoutube: YouTube = YouTube(client_secret_file=client_secret_file)\r\nyoutube.authenticate()\r\n# part = Part()\r\n# optional_parameters: OptionalParameters = OptionalParameters(\r\n#     q='news',\r\n#     maxResults=2,\r\n#     eventType='live',\r\n#     type=['video']\r\n# )\r\n# optional_parameters: OptionalParameters = OptionalParameters(\r\n#     q='Python programming',\r\n#     maxResults=2,\r\n#     type=['video', 'channel', 'playlist'],\r\n# )\r\n# search = SearchSchema(part=part, optional_parameters=optional_parameters)\r\n\r\n# print(youtube.search(search))\r\n# search_iterator = youtube.get_search_iterator(search)\r\n# print(next(search_iterator))\r\n# print(next(search_iterator))\r\n# print(next(search_iterator))\r\n# print(youtube.find_video_by_id('rfscVS0vtbw'))\r\n# print(youtube.find_channel_by_name('East Meets West'))\r\n# print(youtube.get_video_ratings(['s7AvT7cGdSo']))\r\n# print(youtube.find_most_popular_video_by_regionn(region_code='KE'))\r\n# print(youtube.rate_video('s7AvT7cGdSo', 'like'))\r\n# print(youtube.update_video())\r\n# print(youtube.upload_video())\r\n"}
{"image_path": "data\\train\\00621.png", "code": "# print(youtube.find_channel_by_name('The Joy Ride'))\r\n# print(youtube.find_channel_playlists('UCCjULCQvh2cQQLzYe4DC2Nw'))\r\n# print(youtube.find_my_playlists())\r\n# snippet: CreatePlaylistSnippet = CreatePlaylistSnippet(\r\n#     title='Another Test Playlist 5'\r\n# )\r\n# playlist_schema: CreatePlaylistSchema = CreatePlaylistSchema(\r\n#     snippet=snippet\r\n# )\r\n# print(youtube.insert_playlist(playlist_schema))\r\n# snippet: CreatePlaylistSnippet = CreatePlaylistSnippet(\r\n#     title='Another Test Playlist 6',\r\n#     description='New description.',\r\n#     defaultLanguage='en'\r\n# )\r\n# playlist_schema: CreatePlaylistSchema = CreatePlaylistSchema(\r\n#     snippet=snippet,\r\n#     status=CreateStatus(privacyStatus='public')\r\n# )\r\n# print(youtube.update_playlist('PL_26vmg8W_AfJWy6SVtoSmtYWimhexwF7', playlist_schema))\r\n# print(youtube.delete_playlist('PL_26vmg8W_AfeubZM4lQJiBU8UbCl-R3L'))\r\n# print(youtube.find_channel_by_name('Isaac Author'))\r\n# print(youtube.find_playlist_items('PLgCR4dyaQRlq0SM6y7cQqspDnfqiNHfWf'))\r\n# print(youtube.find_playlist_items_by_ids(['UExnQ1I0ZHlhUVJscTBTTTZ5N2NRcXNwRG5mcWlOSGZXZi5EMEEwRUY5M0RDRTU3NDJC', \r\n#                         'UExnQ1I0ZHlhUVJscTBTTTZ5N2NRcXNwRG5mcWlOSGZXZi45NDk1REZENzhEMzU5MDQz', \r\n#                         'UExnQ1I0ZHlhUVJscTBTTTZ5N2NRcXNwRG5mcWlOSGZXZi41MzJCQjBCNDIyRkJDN0VD']))\r\n\r\n# video_resource: VideoResourceId = VideoResourceId(videoId='j0OvCL-6ic4')\r\n# snippet: CreatePlaylistItemSnippet = CreatePlaylistItemSnippet(\r\n#     playlistId='PL_26vmg8W_AfJWy6SVtoSmtYWimhexwF7',\r\n#     resourceId=video_resource\r\n# )\r\n# create = CreatePlaylistItem(snippet=snippet)\r\n# print(youtube.insert_playlist_item(create))\r\n# playlist_id='PL_26vmg8W_AfJWy6SVtoSmtYWimhexwF7', \r\n# playlist_item_id='UExfMjZ2bWc4V19BZkpXeTZTVnRvU210WVdpbWhleHdGNy41MzJCQjBCNDIyRkJDN0VD'\r\n# video_id='j0OvCL-6ic4' \r\n# position=6\r\n# print(youtube.update_playlist_item(playlist_id, playlist_item_id, video_id, position))\r\n# print(youtube.delete_playlist_item('UExnQ1I0ZHlhUVJsclpDZEtoN2ZQb1FwejVGYXI3Xy1HSS4yODlGNEE0NkRGMEEzMEQy'))\r\n"}
{"image_path": "data\\train\\00622.png", "code": "# channel_list = ['Asianometry', '']\r\n# watched_list = []\r\n# playlist_id = 'PL_26vmg8W_AfJWy6SVtoSmtYWimhexwF7'\r\n# playlist_title = ''\r\n# channel_name = 'Asianometry'\r\n# channel_id = ''\r\n# video_id = ''\r\n# channels = youtube.find_channel_by_name(channel_name)\r\n# for channel in channels.items:\r\n#     if channel.title == channel_name:\r\n#         channel_id = channel.channel_id\r\n# part = Part()\r\n# optional_parameters: OptionalParameters = OptionalParameters(\r\n#     q='',\r\n#     maxResults=1,\r\n#     type=['video'],\r\n#     channelId=channel_id,\r\n#     order='date'\r\n# )\r\n# search = SearchSchema(part=part, optional_parameters=optional_parameters)\r\n# search_result = youtube.search(search)\r\n# videos = search_result.items\r\n# latest_video = videos[0]\r\n# video_id = latest_video.resource_id\r\n# video_resource: VideoResourceId = VideoResourceId(videoId=video_id)\r\n# snippet: CreatePlaylistItemSnippet = CreatePlaylistItemSnippet(\r\n#     playlistId=playlist_id,\r\n#     resourceId=video_resource\r\n# )\r\n# create = CreatePlaylistItem(snippet=snippet)\r\n# playlist_item = youtube.insert_playlist_item(create)\r\n# print(f'Added {playlist_item.snippet.title} to the playlist.')\r\n# print(youtube.get_video_categories())\r\n\r\n# def search_save():\r\n#     from json import dump\r\n#     part: SearchPart = SearchPart()\r\n#     optional_parameters: SearchOptionalParameters = SearchOptionalParameters(\r\n#         q='israel palestine conflict',\r\n#         maxResults=5,\r\n"}
{"image_path": "data\\train\\00623.png", "code": "#         eventType='live',\r\n#         type=['video']\r\n#     )\r\n#     search = YouTubeRequest(part=part, optional_parameters=optional_parameters)\r\n#     results: list[Search] = youtube.search(search).items\r\n#     results: dict[str, Any] = [result.model_dump() for result in results]\r\n#     with open('live-news.json', 'w', encoding='utf-8') as f:\r\n#         dump(results, f, indent=4, default=str)\r\n#     print(results)\r\n    \r\n# search_save()\r\n# part: Part = CommentThreadPart()\r\n# filter: Filter = CommentThreadFilter(videoId='crYum29M-VE')\r\n# optional: OptionalParameters = CommentThreadOptionalParameters(\r\n#     maxResults=10\r\n# )\r\n# req: YouTubeRequest = YouTubeRequest(\r\n#     part=part,\r\n#     optional_parameters=optional,\r\n#     filter=filter\r\n# )\r\n# res: YouTubeResponse = youtube.find_video_comments(request=req)\r\n# print(res)\r\nprint(youtube.list_activities())"}
{"image_path": "data\\train\\00624.png", "code": "from setuptools import find_packages, setup\r\n\r\n# For consistent encoding\r\nfrom codecs import open\r\nfrom os import path\r\n\r\n# The directory containing this file\r\nHERE = path.abspath(path.dirname(__file__))\r\n\r\n# Get the long description from the README file\r\nwith open(path.join(HERE, 'README.md'), encoding='utf-8') as f:\r\n    LONG_DESCRIPTION = f.read()\r\n\r\nVERSION = '0.5.1'\r\nDESCRIPTION = 'A python library that wraps around the YouTube V3 API. You can use it find and manage YouTube resources including Videos, Playlists, Channels and Comments.'\r\n\r\nkey_words = [\r\n    'youtube', 'youtube-api', 'youtube comments', 'youtube videos',\r\n    'youtube channels', 'youtube comment thread', 'create youtube playlist'\r\n]\r\n\r\ninstall_requires = [\r\n    'google-api-python-client',\r\n    'google-auth-oauthlib'\r\n]\r\n\r\nsetup(\r\n    name='ayv',\r\n    packages=find_packages(\r\n        include=[\r\n            'youtube',\r\n            'youtube.oauth',\r\n            'youtube.models',\r\n            'youtube.resources',\r\n            'youtube.resources.video',\r\n            'youtube.exceptions',\r\n            'youtube.resources.channel',\r\n            'youtube.resources.playlist',\r\n            'youtube.resources.playlist_item',\r\n            'youtube.resources.comment_thread',\r\n"}
{"image_path": "data\\train\\00625.png", "code": "            'youtube.resources.mixins'\r\n        ]\r\n        ),\r\n    version=VERSION,\r\n    description=DESCRIPTION,\r\n    long_description_content_type='text/markdown',\r\n    long_description=LONG_DESCRIPTION,\r\n    url='https://youtube-wrapper.readthedocs.io/en/latest/index.html',\r\n    author='Lyle Okoth',\r\n    author_email='lyceokoth@gmail.com',\r\n    license='MIT',\r\n    install_requires=install_requires,\r\n    keywords=key_words,\r\n    classifiers=[\r\n        'Intended Audience :: Developers',\r\n        'License :: OSI Approved :: MIT License',\r\n        'Programming Language :: Python',\r\n        'Programming Language :: Python :: 3',\r\n        'Programming Language :: Python :: 3.10',\r\n        'Programming Language :: Python :: 3.11',\r\n        'Operating System :: OS Independent'\r\n    ],\r\n)\r\n"}
{"image_path": "data\\train\\00626.png", "code": "from youtube import YouTube\r\n\r\nclient_secret_file = '/home/downloads/client_secret.json'\r\nyoutube = YouTube(client_secret_file)\r\nyoutube.authenticate()\r\n\r\ndef get_channel_id():\r\n    videos = youtube.find_video_by_id('pIzyo4cCGxU')\r\n    channel_id = videos[0].channel_id\r\n    return channel_id\r\n\r\ndef get_channel_details(channel_id):\r\n    channel = youtube.find_channel_by_id(channel_id)\r\n    return channel\r\n\r\ndef get_channel_playlists(channel_id):\r\n        channel_playlists = youtube.find_channel_playlists(channel_id)\r\n        return channel_playlists\r\n\r\ndef get_playlist_items(playlist_id):\r\n    search_iterator = youtube.find_playlist_items(playlist_id, max_results=10)\r\n    playlists = list(next(search_iterator))\r\n    return playlists\r\n\r\ndef get_playlist_item_video_id(playlist_item):\r\n    video_id = playlist_item.video_id\r\n    return video_id\r\n\r\ndef get_videos(video_ids):\r\n    videos = youtube.find_video_by_id(video_ids)\r\n    return videos\r\n\r\ndef get_video_comments(video_id):\r\n    search_iterator = youtube.find_video_comments(video_id, max_results=20)\r\n    video_comments = list(next(search_iterator))\r\n    return video_comments\r\n\r\ndef main():\r\n    # channel_id = get_channel_id()\r\n    # channel = get_channel_details(channel_id)\r\n"}
{"image_path": "data\\train\\00627.png", "code": "    # channel_playlists = get_channel_playlists('UC5WVOSvL9bc6kwCMXXeFLLw')\r\n    # playlist_items = get_playlist_items('PLouh1K1d9jkYZo8h1zPH3P1ScAWA8gxbu')\r\n    # playlist_video_ids = list(map(get_playlist_item_video_id, playlist_items))\r\n    # playlist_videos = get_videos(playlist_video_ids)\r\n    video_comments = get_video_comments('pIzyo4cCGxU')\r\n    print(video_comments)\r\n\r\nif __name__ == '__main__':\r\n    main()"}
{"image_path": "data\\train\\00628.png", "code": "from youtube import YouTube\r\nimport json\r\nimport os\r\nfrom typing import Optional\r\nfrom youtube.models.video_model import Video\r\n\r\ndef to_json(channels):\r\n    with open('channels.json', 'w', encoding='utf-8') as f:\r\n        f.write(json.dumps(channels, indent=4))\r\n        \r\ndef save_to_channels(video: Video, file_name: Optional[str] = \"kenyan_channels.json\") -> None:\r\n    kenyan_channels = []\r\n    if video:\r\n        if os.path.exists(file_name):\r\n            with open(file_name, 'r', encoding='utf-8') as f:\r\n                try:\r\n                    kenyan_channels = json.loads(f.read())\r\n                except json.decoder.JSONDecodeError:\r\n                    pass\r\n        with open(file_name, 'w', encoding='utf-8') as f:\r\n            data = {\r\n                video.channel_title: video.channel_id\r\n            }\r\n            if not data in kenyan_channels:\r\n                kenyan_channels.append(data)\r\n            f.write(json.dumps(kenyan_channels, indent=2))\r\n            print(kenyan_channels)\r\n    \r\n\r\ndef print_videos(videos):\r\n    vids = []\r\n    for video in videos:\r\n        vid = {\r\n            'title': video.video_title,\r\n            'channel': video.channel_title\r\n        }\r\n        vids.append(vid)\r\n    print(vids)\r\n\r\n# client_secrets_file = '/home/lyle/Downloads/python_learning_site.json'\r\n"}
{"image_path": "data\\train\\00629.png", "code": "client_secrets_file = '/home/lyle/Downloads/client_secret.json'\r\ncredentials_path = '.'\r\nyoutube = YouTube(client_secrets_file)\r\nyoutube.authenticate(credentials_directory=credentials_path)\r\nsearch_iterator = youtube.search_video('Python for beginners' ,max_results=2)\r\nprint(list(next(search_iterator)))\r\n# print(list(next(search_iterator)))\r\n# print(len(search_iterator.items))\r\n# print_videos(next(search_iterator))\r\n# print_videos(next(search_iterator))\r\n# print_videos(next(search_iterator))\r\n# print(next(search_iterator))\r\n# print_videos(list(next(search_iterator)))\r\n# print_videos(next(search_iterator))\r\n# print_videos(next(search_iterator))\r\n# videos = youtube.find_video_by_id('RFDK1rdJ_gg')\r\n# print(videos)\r\n# save_to_channels(video)\r\n# ids = ['rfscVS0vtbw', 'TFa38ONq5PY']\r\n# youtube.find_videos(ids)\r\n# youtube.find_most_popular_video_by_region('us')\r\n# search_iterator = youtube.search_channel('Python for beginners',max_results=2)\r\n# channel = youtube.find_channel_by_id('UCu8luTDe_Xxd2ahAXsCWX5g')\r\n# print(channel)\r\n# print(channel.to_json())\r\n# to_json([channel.to_dict()])\r\n# search_iterator = youtube.search_channel('Python for beginners',max_results=2)\r\n# print(next(search_iterator))\r\n# channel = youtube.find_channel_by_name('GoogleDevelopers')\r\n# channel = youtube.find_channel_by_name('@PROROBOTS')\r\n# print(channel)\r\n# search_iterator = youtube.find_video_comments('VSB2vjWa1LA', max_results=20)\r\n# print(next(search_iterator))\r\n# print(next(search_iterator))\r\n# search_iterator = youtube.find_all_channel_comments('UCu8luTDe_Xxd2ahAXsCWX5g', max_results=20)\r\n# print(next(search_iterator))\r\n# print(next(search_iterator))\r\n# search_iterator = youtube.search_playlist('Python for beginners',max_results=20)\r\n# print(next(search_iterator))\r\n# print(next(search_iterator))\r\n"}
{"image_path": "data\\train\\00630.png", "code": "# channel_playlists = youtube.find_channel_playlists('UC5WVOSvL9bc6kwCMXXeFLLw')\r\n# print(channel_playlists)\r\n# search_iterator = youtube.find_playlist_items('PLsyeobzWxl7poL9JTVyndKe62ieoN-MZ3', max_results=25)\r\n# print(next(search_iterator))\r\n# print(youtube.search())"}
{"image_path": "data\\train\\00631.png", "code": "import torch\r\nimport os\r\nfrom torch import nn\r\nfrom torchvision import transforms\r\nimport numpy as np\r\nimport os\r\nfrom PIL import Image\r\nimport torch\r\nimport os\r\nfrom torch import nn\r\nimport torch.nn.functional as F\r\nimport random\r\n\r\n\r\nclass MaizeNet(nn.Module):\r\n  def __init__(self, K) -> None:\r\n      super(MaizeNet, self).__init__()\r\n\r\n      self.conv_layers = nn.Sequential(\r\n          # convolution 1\r\n          nn.Conv2d(in_channels=3, out_channels=32, kernel_size=3, padding=1),\r\n          nn.ReLU(),\r\n          nn.BatchNorm2d(32),\r\n          nn.Conv2d(in_channels=32, out_channels=32, kernel_size=3, padding=1),\r\n          nn.ReLU(),\r\n          nn.BatchNorm2d(32),\r\n          nn.MaxPool2d(2),\r\n          # Convolution 2\r\n          nn.Conv2d(in_channels=32, out_channels=64, kernel_size=3, padding=1),\r\n          nn.ReLU(),\r\n          nn.BatchNorm2d(64),\r\n          nn.Conv2d(in_channels=64, out_channels=64, kernel_size=3, padding=1),\r\n          nn.ReLU(),\r\n          nn.BatchNorm2d(64),\r\n          nn.MaxPool2d(2),\r\n          # Convolution 3\r\n          nn.Conv2d(in_channels=64, out_channels=128, kernel_size=3, padding=1),\r\n          nn.ReLU(),\r\n          nn.BatchNorm2d(128),\r\n          nn.Conv2d(in_channels=128, out_channels=128, kernel_size=3, padding=1),\r\n"}
{"image_path": "data\\train\\00632.png", "code": "          nn.ReLU(),\r\n          nn.BatchNorm2d(128),\r\n          nn.MaxPool2d(2),\r\n          # Convolution 4\r\n          nn.Conv2d(in_channels=128, out_channels=256, kernel_size=3, padding=1),\r\n          nn.ReLU(),\r\n          nn.BatchNorm2d(256),\r\n          nn.Conv2d(in_channels=256, out_channels=256, kernel_size=3, padding=1),\r\n          nn.ReLU(),\r\n          nn.BatchNorm2d(256),\r\n          nn.MaxPool2d(2),\r\n      )\r\n\r\n      self.dense_layers = nn.Sequential(\r\n          # Dropout layer\r\n          nn.Dropout(0.5),\r\n          # first fully connected layer\r\n          nn.Linear(224*224, 1024),\r\n          # Relu activation function\r\n          nn.ReLU(),\r\n          nn.Dropout(0.4),\r\n          # Final output layer\r\n          nn.Linear(1024, K),\r\n      )\r\n\r\n  def forward(self, output):\r\n    # Convolution Layers\r\n    out = self.conv_layers(output)\r\n\r\n    # Flatten the layers\r\n    out = out.view(-1, 224*224)\r\n\r\n    # Fully connected Dense Layers\r\n    out = self.dense_layers(out)\r\n\r\n    return out\r\n\r\n\r\ndef load_model(model_path: str = os.environ['MODEL_PATH']):\r\n    \"\"\"Load the pytorch model.\"\"\"\r\n"}
{"image_path": "data\\train\\00633.png", "code": "    n_classes = 4\r\n    maizenet = MaizeNet(n_classes)\r\n    maizenet.load_state_dict(torch.load(model_path, map_location=torch.device('cpu') ))\r\n    return maizenet\r\n\r\ndef preprocess_image(image):\r\n    mean = np.array([0.5, 0.5, 0.5])\r\n    std = np.array([0.25, 0.25, 0.25])\r\n    data_transform = transforms.Compose([\r\n            transforms.RandomResizedCrop(224), # resize and crop image to 224 x 224 pixels\r\n            transforms.RandomHorizontalFlip(), # flip the images horizontally\r\n            transforms.ToTensor(), # convert to pytorch tensor data type\r\n            transforms.Normalize(mean, std) # normalize the input image dataset.\r\n        ])\r\n    transformed_image = data_transform(image).to('cpu')\r\n    transformed_image = torch.unsqueeze(transformed_image, 0)\r\n    return transformed_image\r\n\r\ndef evaluate_image(image, model):\r\n    transformed_image = preprocess_image(image)\r\n    labels = ['Maize Leaf Rust', 'Northern Leaf Blight', 'Healthy', 'Gray Leaf Spot']\r\n    model.eval()\r\n    prediction = F.softmax(model(transformed_image), dim = 1)\r\n    data = {\r\n        'Maize Leaf Rust': round(float(prediction[0][0]), 4) * 100,\r\n        'Northern Leaf Blight': round(float(prediction[0][1]) * 100, 4),\r\n        'Healthy': round(float(prediction[0][2]), 4) * 100,\r\n        'Gray Leaf Spot': round(float(prediction[0][3]) * 100, 4)\r\n    }\r\n    prediction = prediction.argmax()\r\n    return labels[prediction], data\r\n"}
{"image_path": "data\\train\\00634.png", "code": "from google_calendar import GoogleCalendar\r\nimport os\r\n\r\nclient_secret: str = os.environ['CLIENT_SECRET_FILE']\r\ngoogle_calendar: GoogleCalendar = GoogleCalendar(secret_file=client_secret)\r\ngoogle_calendar.authenticate()"}
{"image_path": "data\\train\\00635.png", "code": "import torch\r\nimport os\r\nfrom torch import nn\r\nfrom torchvision import transforms\r\nimport numpy as np\r\nimport os\r\nfrom PIL import Image\r\nimport torch\r\nimport os\r\nfrom torch import nn\r\nimport torch.nn.functional as F\r\nimport random\r\n\r\n\r\nclass MaizeNet(nn.Module):\r\n  def __init__(self, K) -> None:\r\n      super(MaizeNet, self).__init__()\r\n\r\n      self.conv_layers = nn.Sequential(\r\n          # convolution 1\r\n          nn.Conv2d(in_channels=3, out_channels=32, kernel_size=3, padding=1),\r\n          nn.ReLU(),\r\n          nn.BatchNorm2d(32),\r\n          nn.Conv2d(in_channels=32, out_channels=32, kernel_size=3, padding=1),\r\n          nn.ReLU(),\r\n          nn.BatchNorm2d(32),\r\n          nn.MaxPool2d(2),\r\n          # Convolution 2\r\n          nn.Conv2d(in_channels=32, out_channels=64, kernel_size=3, padding=1),\r\n          nn.ReLU(),\r\n          nn.BatchNorm2d(64),\r\n          nn.Conv2d(in_channels=64, out_channels=64, kernel_size=3, padding=1),\r\n          nn.ReLU(),\r\n          nn.BatchNorm2d(64),\r\n          nn.MaxPool2d(2),\r\n          # Convolution 3\r\n          nn.Conv2d(in_channels=64, out_channels=128, kernel_size=3, padding=1),\r\n          nn.ReLU(),\r\n          nn.BatchNorm2d(128),\r\n          nn.Conv2d(in_channels=128, out_channels=128, kernel_size=3, padding=1),\r\n"}
{"image_path": "data\\train\\00636.png", "code": "          nn.ReLU(),\r\n          nn.BatchNorm2d(128),\r\n          nn.MaxPool2d(2),\r\n          # Convolution 4\r\n          nn.Conv2d(in_channels=128, out_channels=256, kernel_size=3, padding=1),\r\n          nn.ReLU(),\r\n          nn.BatchNorm2d(256),\r\n          nn.Conv2d(in_channels=256, out_channels=256, kernel_size=3, padding=1),\r\n          nn.ReLU(),\r\n          nn.BatchNorm2d(256),\r\n          nn.MaxPool2d(2),\r\n      )\r\n\r\n      self.dense_layers = nn.Sequential(\r\n          # Dropout layer\r\n          nn.Dropout(0.5),\r\n          # first fully connected layer\r\n          nn.Linear(224*224, 1024),\r\n          # Relu activation function\r\n          nn.ReLU(),\r\n          nn.Dropout(0.4),\r\n          # Final output layer\r\n          nn.Linear(1024, K),\r\n      )\r\n\r\n  def forward(self, output):\r\n    # Convolution Layers\r\n    out = self.conv_layers(output)\r\n\r\n    # Flatten the layers\r\n    out = out.view(-1, 224*224)\r\n\r\n    # Fully connected Dense Layers\r\n    out = self.dense_layers(out)\r\n\r\n    return out\r\n\r\n\r\ndef load_model(model_path: str = os.environ['MODEL_PATH']):\r\n    \"\"\"Load the pytorch model.\"\"\"\r\n"}
{"image_path": "data\\train\\00637.png", "code": "    n_classes = 4\r\n    maizenet = MaizeNet(n_classes)\r\n    maizenet.load_state_dict(torch.load(model_path, map_location=torch.device('cpu') ))\r\n    return maizenet\r\n\r\ndef preprocess_image(image):\r\n    mean = np.array([0.5, 0.5, 0.5])\r\n    std = np.array([0.25, 0.25, 0.25])\r\n    data_transform = transforms.Compose([\r\n            transforms.RandomResizedCrop(224), # resize and crop image to 224 x 224 pixels\r\n            transforms.RandomHorizontalFlip(), # flip the images horizontally\r\n            transforms.ToTensor(), # convert to pytorch tensor data type\r\n            transforms.Normalize(mean, std) # normalize the input image dataset.\r\n        ])\r\n    transformed_image = data_transform(image).to('cpu')\r\n    transformed_image = torch.unsqueeze(transformed_image, 0)\r\n    return transformed_image\r\n\r\ndef evaluate_image(image, model):\r\n    transformed_image = preprocess_image(image)\r\n    labels = ['Maize Leaf Rust', 'Northern Leaf Blight', 'Healthy', 'Gray Leaf Spot']\r\n    model.eval()\r\n    prediction = F.softmax(model(transformed_image), dim = 1)\r\n    data = {\r\n        'Maize Leaf Rust': round(float(prediction[0][0]), 4) * 100,\r\n        'Northern Leaf Blight': round(float(prediction[0][1]) * 100, 4),\r\n        'Healthy': round(float(prediction[0][2]), 4) * 100,\r\n        'Gray Leaf Spot': round(float(prediction[0][3]) * 100, 4)\r\n    }\r\n    prediction = prediction.argmax()\r\n    return labels[prediction], data\r\n"}
{"image_path": "data\\train\\00638.png", "code": "from youtube import YouTube\r\n\r\nclient_secrets_file = \"/home/lyle/Downloads/search.json\"\r\nyoutube_client = YouTube(client_secret_file=client_secrets_file)\r\nyoutube_client_object = youtube_client.authenticate()\r\nyoutube_client.youtube_client = youtube_client_object\r\n"}
{"image_path": "data\\train\\00639.png", "code": "import os\r\n\r\nfrom langchain.agents import AgentExecutor, Tool\r\nfrom langchain.agents.format_scratchpad import format_to_openai_function_messages\r\nfrom langchain.agents.output_parsers import OpenAIFunctionsAgentOutputParser\r\nfrom langchain.chat_models import ChatOpenAI\r\nfrom langchain.embeddings import OpenAIEmbeddings\r\nfrom langchain.prompts import ChatPromptTemplate, MessagesPlaceholder\r\nfrom langchain.schema.document import Document\r\nfrom langchain.tools.render import format_tool_to_openai_function\r\nfrom langchain.vectorstores.faiss import FAISS\r\n\r\nfrom .tools import YouTubeSearchVideoTool\r\nfrom .tools.channel import MyYouTubeChannelDetailsTool, YouTubeChannelDetailsTool\r\nfrom .tools.comment import (\r\n    FindMyCommentsTool,\r\n    FindUserCommentsTool,\r\n    ListVideoCommentRepliesTool,\r\n    ListVideoCommentsTool,\r\n    ReplyCommentTool,\r\n)\r\nfrom .tools.playlist import (\r\n    CreatePlaylistTool,\r\n    DeleteYoutubePlaylistsTool,\r\n    InsertVideoIntoPlaylistTool,\r\n    ListChannelPlaylistsTool,\r\n    ListPlaylistVideosTool,\r\n    ListUserPlaylistsTool,\r\n)\r\nfrom .tools.video import YouTubeVideoDetailsTool\r\n\r\nOPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\")\r\nOPENAI_MODEL = os.environ.get(\"OPENAI_MODEL\")  # \"gpt-3.5-turbo-0613\"\r\nllm = ChatOpenAI(temperature=0, model=OPENAI_MODEL, api_key=OPENAI_API_KEY)\r\ntools = [\r\n    YouTubeSearchVideoTool(),\r\n    ListUserPlaylistsTool(),\r\n    ListPlaylistVideosTool(),\r\n    ListVideoCommentsTool(),\r\n    YouTubeVideoDetailsTool(),\r\n"}
{"image_path": "data\\train\\00640.png", "code": "    YouTubeChannelDetailsTool(),\r\n    DeleteYoutubePlaylistsTool(),\r\n    InsertVideoIntoPlaylistTool(),\r\n    CreatePlaylistTool(),\r\n    ListChannelPlaylistsTool(),\r\n    MyYouTubeChannelDetailsTool(),\r\n    FindUserCommentsTool(),\r\n    FindMyCommentsTool(),\r\n    ListVideoCommentRepliesTool(),\r\n    ReplyCommentTool(),\r\n]\r\n\r\n\r\ndef get_tools(query: str, tools: list[Tool] = tools) -> str:\r\n    \"\"\"Get the agent tools.\"\"\"\r\n    documents: list[Document] = [\r\n        Document(page_content=tool.description, metadata={\"index\": i})\r\n        for i, tool in enumerate(tools)\r\n    ]\r\n    vectore_store = FAISS.from_documents(documents, OpenAIEmbeddings())\r\n    retriver = vectore_store.as_retriever()\r\n    retrieved = retriver.get_relevant_documents(query)\r\n    return [tools[document.metadata[\"index\"]] for document in retrieved]\r\n\r\n\r\ndef get_agent_executor():\r\n    \"\"\"Get the agent\"\"\"\r\n    prompt = ChatPromptTemplate.from_messages(\r\n        [\r\n            (\r\n                \"system\",\r\n                \"You are a funny and friendly youtube assistant. Your task is to help the user with tasks related to youtube..\",\r\n            ),\r\n            (\"user\", \"{input}\"),\r\n            MessagesPlaceholder(variable_name=\"agent_scratchpad\"),\r\n        ]\r\n    )\r\n\r\n    functions = [format_tool_to_openai_function(t) for t in tools]\r\n\r\n"}
{"image_path": "data\\train\\00641.png", "code": "    llm_with_tools = llm.bind(functions=functions)\r\n\r\n    agent = (\r\n        {\r\n            \"input\": lambda x: x[\"input\"],\r\n            \"agent_scratchpad\": lambda x: format_to_openai_function_messages(\r\n                x[\"intermediate_steps\"]\r\n            ),\r\n        }\r\n        | prompt\r\n        | llm_with_tools\r\n        | OpenAIFunctionsAgentOutputParser()\r\n    )\r\n\r\n    agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)\r\n    return agent_executor\r\n"}
{"image_path": "data\\train\\00642.png", "code": "from pydantic import BaseModel, Field\r\nfrom schemas import DatasetMetadata\r\nfrom datetime import datetime\r\nfrom json import dump\r\n\r\n\r\nclass ExperimentConfig(BaseModel):\r\n    data_dir: str\r\n    models_directory: str\r\n    features_dir: str\r\n    dataset_metadata: DatasetMetadata\r\n    label_columns: list[str] = Field(default_factory=list)\r\n    feature_cols: list[str] = Field(default_factory=list)\r\n    columns_to_drop: list[str] = Field(default_factory=list)\r\n    numerical_features: list[str] = Field(default_factory=list)\r\n    categorical_features: list[str] = Field(default_factory=list)\r\n    \r\n    def save_experiment_config(self, path: str,\r\n            title: str = '', \r\n            description: str = '', \r\n            date: datetime=datetime.now()\r\n        ) -> None:\r\n        with open(path, 'w', encoding='utf-8') as f:\r\n            dump(self.model_dump(), f, indent=4)\r\n        \r\n        \r\n"}
{"image_path": "data\\train\\00643.png", "code": "from config.config import app_config\r\nfrom os import path\r\nfrom zipfile import ZipFile\r\nimport logging\r\nimport pandas as pd\r\nfrom pandas import DataFrame\r\nfrom sklearn.pipeline import Pipeline\r\nfrom joblib import load\r\nfrom notification import get_gmail_client, create_message, send_message\r\n\r\n\r\ndef extract_dataset(archive_name: str = 'archive.zip', file_name: str = 'Titanic-Dataset.csv') -> None:\r\n    \"\"\"Extract the downloaded archive file into the data folder.\"\"\"\r\n    # Ubuntu OS\r\n    downloads_path: str = path.join(path.expanduser('~'), 'Downloads')\r\n    archive_path: str = path.join(downloads_path, archive_name)\r\n    try:\r\n        with ZipFile(archive_path, 'r') as zip_:\r\n            try:\r\n                zip_.extract(file_name, app_config.data_dir)\r\n                logging.info(f'The file {file_name} has been extracted to {path.join(app_config.data_dir, file_name)}.')\r\n            except KeyError:\r\n                print(f'There is no file \"{file_name}\" in the archive \"{archive_path}\".')\r\n                logging.error(f'There is no file \"{file_name}\" in the archive \"{archive_path}\".')\r\n    except FileNotFoundError:\r\n        print(f'There is no archive \"{archive_path}\".')\r\n        logging.error(f'There is no archive \"{archive_path}\".')\r\n    return path.join(app_config.data_dir, file_name)\r\n\r\n\r\ndef load_data(file_path: str = 'Titanic-Dataset.csv') -> DataFrame:\r\n    \"\"\"Load the Titanic dataset into a dataframe.\"\"\"\r\n    try:\r\n        data: DataFrame = pd.read_csv(file_path)\r\n    except FileNotFoundError:\r\n        print(f'There is no file such file \"{file_path}\".')\r\n        logging.error(f'There is no file such file \"{file_path}\".')\r\n    return data\r\n\r\n\r\n"}
{"image_path": "data\\train\\00644.png", "code": "def load_model(model_path: str) -> Pipeline:\r\n    \"\"\"Load a saved model.\"\"\"\r\n    try:\r\n        model: Pipeline = load(model_path)\r\n    except FileNotFoundError:\r\n        logging.error(f'There is no such model \"{model_path}\".')\r\n    return model\r\n\r\n\r\ndef send_email():\r\n    logging.info('Sending email.')\r\n    secrets_path = app_config.secret_file\r\n    gmail_client = get_gmail_client(secrets_path)\r\n    message = create_message()\r\n    message = send_message(gmail_client, message)\r\n    logging.info('Email Sent.')\r\n    logging.info(message)\r\n"}
{"image_path": "data\\train\\00645.png", "code": "from sklearn.compose import ColumnTransformer\r\nfrom sklearn.pipeline import Pipeline\r\nfrom sklearn.preprocessing import StandardScaler, OneHotEncoder\r\nfrom sklearn.impute import SimpleImputer\r\nfrom sklearn.pipeline import Pipeline\r\nfrom experiment_config import ExperimentConfig\r\n\r\n\r\ndef create_numeric_pipeline() -> Pipeline:\r\n    num_pipeline: Pipeline = Pipeline(steps=[\r\n        ('imputer', SimpleImputer(strategy='mean')),\r\n        ('scaler', StandardScaler())\r\n    ])\r\n    return num_pipeline\r\n\r\ndef create_categorical_pipeline() -> Pipeline:\r\n    cat_pipeline: Pipeline = Pipeline(steps=[\r\n        ('imputer', SimpleImputer(strategy='most_frequent')),\r\n        ('encoder', OneHotEncoder())\r\n    ])\r\n    return cat_pipeline\r\n\r\ndef create_experiment_pipeline(experiment_config: ExperimentConfig) -> ColumnTransformer:\r\n    preprocessor: ColumnTransformer = ColumnTransformer(\r\n        transformers=[\r\n            ('drop_columns', 'drop', experiment_config.columns_to_drop),\r\n            ('num', create_numeric_pipeline(), experiment_config.numerical_features),\r\n            ('cat', create_categorical_pipeline(), experiment_config.categorical_features)\r\n        ],\r\n        remainder='passthrough'\r\n    )\r\n    return preprocessor"}
{"image_path": "data\\train\\00646.png", "code": "from sklearn.gaussian_process.kernels import RBF, DotProduct, Matern, RationalQuadratic, WhiteKernel\r\n\r\n\r\nnames = [\r\n    \"Nearest Neighbors\",\r\n    \"Linear SVM\",\r\n    \"RBF SVM\",\r\n    \"Gaussian Process\",\r\n    \"Decision Tree\",\r\n    \"Random Forest\",\r\n    \"Neural Net\",\r\n    \"AdaBoost\",\r\n    \"Naive Bayes\",\r\n    \"QDA\",\r\n]\r\nknn = dict(\r\n    leaf_size=list(range(1, 15)),\r\n    n_neighbors=list(range(1, 10)),\r\n    p=[1, 2]\r\n)\r\n\r\ngaussian_process = dict(\r\n    kernel=[1*RBF(), 1*DotProduct(), 1*Matern(),  1*RationalQuadratic(), 1*WhiteKernel()]\r\n)\r\n\r\ndecision_tree = dict(\r\n    criterion=['gini', 'entropy'],\r\n    max_depth=list(range(1, 10)),\r\n    min_samples_split=list(range(1, 10)),\r\n    min_samples_leaf=list(range(1, 10))\r\n)\r\n\r\nhyperparameters: dict[str, dict] = {\r\n    \"Nearest Neighbors\": knn,\r\n    \"Gaussian Process\": gaussian_process,\r\n    \"Decision Tree\": decision_tree\r\n}"}
{"image_path": "data\\train\\00647.png", "code": "from redis import Redis\r\nfrom config.config import app_config\r\nfrom celery import Celery\r\nfrom utils import extract_dataset\r\nfrom schemas import Model, TrainedModel, TunedModel\r\nimport logging\r\nfrom schemas import Metrics\r\nfrom datetime import datetime\r\nfrom sklearn.metrics import accuracy_score, precision_score, f1_score, recall_score\r\nfrom time import perf_counter\r\nfrom sklearn.pipeline import Pipeline\r\nfrom experiment_param_grids import hyperparameters\r\nfrom sklearn.model_selection import GridSearchCV\r\nfrom sklearn.base import BaseEstimator\r\nfrom schemas.train_config import TrainConfig\r\nfrom os import path\r\nfrom utils import send_email\r\n\r\n\r\nredis: Redis = Redis(host=app_config.redis.redis_host, port=app_config.redis.redis_port, decode_responses=True)\r\ncelery = Celery(__name__)\r\ncelery.conf.broker_url = app_config.celery_broker_url\r\ncelery.conf.result_backend = app_config.celery_result_backend\r\ncelery.conf.event_serializer = 'pickle' # this event_serializer is optional. somehow i missed this when writing this solution and it still worked without.\r\ncelery.conf.task_serializer = 'pickle'\r\ncelery.conf.result_serializer = 'pickle'\r\ncelery.conf.accept_content = ['application/json', 'application/x-python-serialize']\r\n\r\n\r\n@celery.task(name='send_training_report_task')\r\ndef send_training_report_task(training_result):\r\n    try:\r\n        logging.info('Sending the email')\r\n        send_email()\r\n    except Exception as e:\r\n        logging.error(f'Unable to send email: {str(e)}')\r\n    else:\r\n        logging.info('Email sent')\r\n    return training_result\r\n\r\n"}
{"image_path": "data\\train\\00648.png", "code": "\r\n@celery.task(name=\"train_model_task\")\r\ndef train_model_task(train_config: TrainConfig):\r\n    train_results: dict = fit_pipeline(train_config=train_config)\r\n    trained_model: TrainedModel = TrainedModel(\r\n        classifier_name=train_results['model_name'],\r\n        train_date=datetime.now(),\r\n        save_path=path.join(app_config.models_dir, 'trained', train_results['model_name']),\r\n        owner='Lyle Okoth',\r\n        metrics=train_results['metrics'],\r\n        train_time=train_results['train_time']\r\n    )\r\n    trained_model.post_model_metrics(app_config, redis)\r\n    return {\r\n        'Model Name': train_results['model_name'],\r\n        'Train Time': train_results['train_time'],\r\n        'Metrics': train_results['metrics']\r\n    }\r\n    \r\n\r\n@celery.task(name='tune_model')\r\ndef tune_model(train_config: TrainConfig):\r\n    train_features = train_config.preprocessor.fit_transform(train_config.train_features)\r\n    test_features = train_config.preprocessor.fit_transform(train_config.test_features)\r\n    clf = GridSearchCV(train_config.model, hyperparameters[train_config.classifier_name], cv=10)\r\n    best_model = clf.fit(train_features, train_config.train_labels.values.ravel())\r\n    best_params = best_model.best_estimator_.get_params()\r\n    preds = best_model.predict(test_features)\r\n    accuracy = accuracy_score(preds, train_config.test_labels)\r\n    return {\r\n        'params': best_params,\r\n        'acuracy': accuracy,\r\n        'name': train_config.classifier_name\r\n    }\r\n    \r\ndef fit_pipeline(train_config: TrainConfig, model_params: dict = {}, train: bool = True) -> dict:\r\n    logging.info('Training and saving the tuned model')\r\n    untrained_model: BaseEstimator = train_config.model\r\n    pipeline: Pipeline = Pipeline(steps=[\r\n            ('preprocessor', train_config.preprocessor),\r\n"}
{"image_path": "data\\train\\00649.png", "code": "            ('classifier', untrained_model)\r\n        ])\r\n    if model_params:\r\n        untrained_model.set_params(**model_params)\r\n    train_start_time: float = perf_counter()\r\n    pipeline.fit(train_config.train_features, train_config.train_labels.values.ravel())\r\n    train_stop_time: float = perf_counter()\r\n    predictions: list[int] = pipeline.predict(train_config.test_features).tolist()\r\n    accuracy: float = accuracy_score(train_config.test_labels, predictions)\r\n    precision: float = precision_score(train_config.test_labels, predictions)\r\n    recall: float = recall_score(train_config.test_labels, predictions)\r\n    f1: float = f1_score(train_config.test_labels, predictions)\r\n    metrics: Metrics = Metrics(\r\n        accuracy=round(accuracy,2),\r\n        precision=round(precision,2),\r\n        recall=round(recall,2),\r\n        f1=round(f1,2)\r\n    )\r\n    model_train_time = train_stop_time - train_start_time\r\n    if train:\r\n        save_path: str = path.join(app_config.models_dir, 'trained', train_config.classifier_name)\r\n    else:\r\n        save_path: str = path.join(app_config.models_dir, 'tuned', train_config.classifier_name)\r\n    Model.save_model(pipeline, save_path)\r\n    return {\r\n        'model_name': train_config.classifier_name,\r\n        'metrics': metrics,\r\n        'train_time': model_train_time\r\n    }\r\n    \r\n    \r\n@celery.task(name='train_tuned_model')\r\ndef train_tuned_model(tuned_model_data: dict, train_config: TrainConfig):\r\n    train_results: dict = fit_pipeline(train_config=train_config, model_params=tuned_model_data['params'])\r\n    tuned_model: TunedModel = TunedModel(\r\n        classifier_name=train_results['model_name'],\r\n        train_date=datetime.now(),\r\n        save_path=path.join(app_config.models_dir, 'trained', train_results['model_name']),\r\n        owner='Lyle Okoth',\r\n        metrics=train_results['metrics'],\r\n"}
{"image_path": "data\\train\\00650.png", "code": "        train_time=train_results['train_time']\r\n    )\r\n    logging.info('Posting the model metrics.')\r\n    tuned_model.post_model_metrics(app_config, redis)\r\n    return {\r\n        'Model Name': train_results['model_name'],\r\n        'Train Time': train_results['train_time'],\r\n        'Metrics': train_results['metrics']\r\n    }\r\n    "}
{"image_path": "data\\train\\00651.png", "code": "# Get the data\r\nfrom utils import extract_dataset, load_data\r\nfrom experiment import Experiment\r\nfrom pandas import DataFrame\r\nfrom schemas import DatasetMetadata\r\nfrom uuid import uuid4\r\nfrom os import path\r\nfrom config.config import app_config\r\nfrom experiment_config import ExperimentConfig\r\nfrom experiment_models import models\r\nfrom experiment_pipelines import create_experiment_pipeline\r\nimport logging\r\n\r\n\r\nlogging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s', datefmt='%d-%b-%y %H:%M:%S')\r\n# Unzip and store the downloaded dataset with its metadata\r\narchive_name: str = 'archive.zip'\r\nfile_name: str = 'Titanic-Dataset.csv'\r\ndata_path: str = extract_dataset(archive_name, file_name)\r\ndata_path: str = extract_dataset()\r\ndata: DataFrame = load_data(data_path)\r\ndataset_metadata: DatasetMetadata = DatasetMetadata(\r\n    source='https://www.kaggle.com/datasets/yasserh/titanic-dataset',\r\n    cols=data.columns.values.tolist(),\r\n    description='A dataset that shows the survivors of the titanic tragedy.',\r\n    path=data_path,\r\n    id=f'Dataset_{str(uuid4())}'\r\n)\r\ndataset_metadata_path: str = path.join(app_config.data_dir, 'titanic_metadata.json')\r\ndataset_metadata.save(dataset_metadata_path)\r\n\r\n# Create an experiment for training various models\r\nlabel_cols: list[str] = ['Survived']\r\nfeature_cols: list[str] = ['Pclass', 'Sex', 'Age', 'SibSp', 'Parch', 'Fare', 'Embarked', \"PassengerId\", \"Name\", \"Ticket\", \"Cabin\"]\r\ncolumns_to_drop: list[str] = [\"PassengerId\", \"Name\", \"Ticket\", \"Cabin\"]\r\nnumerical_features: list[str] = [\"Age\", \"Fare\"]\r\ncategorical_features: list[str] = [\"Pclass\", \"Sex\", \"Embarked\"]\r\nexperiment_config: ExperimentConfig = ExperimentConfig(\r\n    data_dir=app_config.data_dir,\r\n    models_directory=app_config.models_dir,\r\n"}
{"image_path": "data\\train\\00652.png", "code": "    features_dir=app_config.features_dir,\r\n    dataset_metadata=dataset_metadata,\r\n    label_columns=label_cols,\r\n    feature_cols=feature_cols,\r\n    columns_to_drop=columns_to_drop,\r\n    numerical_features=numerical_features,\r\n    categorical_features=categorical_features\r\n)\r\n\r\nexperiment: Experiment = Experiment(\r\n    experiment_config=experiment_config,\r\n    preprocessor=create_experiment_pipeline(experiment_config),\r\n    models=models\r\n)\r\nexperiment.run()\r\n# experiment.get_results()\r\n# experiment.tune_best_models()\r\n# experiment.get_tuned_models()\r\n# print(experiment.get_best_models(start=-3, end=-1)) "}
{"image_path": "data\\train\\00653.png", "code": "from experiment_config import ExperimentConfig\r\nfrom sklearn.compose import ColumnTransformer\r\nfrom sklearn.base import BaseEstimator\r\nfrom schemas import DataSet, Model\r\nfrom pandas import DataFrame, Series\r\nfrom sklearn.model_selection import train_test_split\r\nfrom sklearn.pipeline import Pipeline\r\nfrom extensions import train_model_task, send_training_report_task, redis, tune_model, train_tuned_model\r\nfrom celery.result import AsyncResult\r\nimport logging\r\nfrom celery import chord\r\nfrom experiment_models import models\r\nfrom time import sleep\r\nfrom config.config import app_config\r\nfrom schemas.train_config import TrainConfig\r\n\r\n\r\nclass Experiment:\r\n    def __init__(self, experiment_config: ExperimentConfig, preprocessor: ColumnTransformer, models: dict[str, BaseEstimator]):\r\n        self.experiment_config = experiment_config\r\n        self.preprocessor = preprocessor\r\n        self.models = models\r\n        self.dataset: DataSet = DataSet(metadata=experiment_config.dataset_metadata)\r\n        self.trained_models: list[Model] = []\r\n        self.train_task_ids: list[str] = []\r\n    \r\n    def get_features(self) -> DataFrame:\r\n        data: DataFrame = self.dataset.get_dataset()\r\n        features: DataFrame = data[self.experiment_config.feature_cols]\r\n        return features\r\n\r\n    def get_labels(self) -> Series:\r\n        data: DataFrame = self.dataset.get_dataset()\r\n        labels: Series = data[self.experiment_config.label_columns]\r\n        return labels\r\n\r\n    def get_train_test_data(self) -> ((DataFrame, Series), (DataFrame, Series)):\r\n        features = self.get_features()\r\n        labels = self.get_labels()\r\n        train_features, test_features, train_labels, test_labels = train_test_split(\r\n"}
{"image_path": "data\\train\\00654.png", "code": "            features, labels, test_size=0.2, random_state=42, stratify=labels\r\n        )\r\n        return (train_features, train_labels), (test_features, test_labels)\r\n\r\n    def save_features(self) -> DataFrame:\r\n        pass\r\n\r\n    def save_labels(self) -> DataFrame:\r\n        pass\r\n\r\n    def train_model(self, model: Model) -> float:\r\n        (train_features, train_labels), (test_features, test_labels) = self.get_train_test_data()\r\n        pipeline: Pipeline = Pipeline(steps=[\r\n            ('preprocessor', self.preprocessor),\r\n            ('classifier', model.model)\r\n        ])\r\n        logging.info('Queing the model \"%s\" for training.', model.name)\r\n        res: AsyncResult = train_model_task.delay(pipeline, train_features, train_labels, test_features, test_labels, model.name, model.save_path)\r\n        self.train_task_ids.append(res.id)\r\n        return res.id\r\n        \r\n\r\n    def run(self) -> None:  \r\n        self._train_results = chord((train_model_task.s(\r\n            self.create_train_config(model=model.model, name=model.classifier_name, save_path=model.save_path)\r\n            ) for model in self.models), send_training_report_task.s())()\r\n      \r\n    def get_results(self) -> list[Model]:\r\n        \"\"\"Get the training result.\"\"\"\r\n        logging.info('Getting the training results')\r\n        print(self._train_results.get())\r\n        \r\n    def get_best_models(self, start: int = 0, end: int = -1) -> Model:\r\n        best_models = redis.zrange(name=app_config.accuracy_channel, start=start, end=end, withscores=True)\r\n        return best_models\r\n        \r\n    def tune_best_models(self) -> None:\r\n        logging.info('Tuning the best models.')\r\n        best_models = self.get_best_models(start=-3, end=-1)\r\n        logging.info(best_models)\r\n"}
{"image_path": "data\\train\\00655.png", "code": "        self.tuned_model_ids = []\r\n        for model_path, _ in best_models:\r\n            logging.info(model_path)\r\n            model_name: str = model_path.split('/')[-1]\r\n            for model in models:\r\n                if model_name == model.classifier_name:\r\n                    train_config: TrainConfig = self.create_train_config(model.model, model.classifier_name, model.save_path)\r\n                    res = tune_model.apply_async((train_config,), \r\n                        link=train_tuned_model.s(train_config,)\r\n                    )\r\n                    self.tuned_model_ids.append(res.id)\r\n                    logging.info('%s queued for tuning and retraining.', model_name)\r\n                        \r\n    def get_tuned_models(self):\r\n        best_model_names = [name.split('/')[-1] for name, _ in self.get_best_models(start=-3, end=-1)]\r\n        while self.tuned_model_ids:\r\n            for index, id in enumerate(self.tuned_model_ids):\r\n                res: AsyncResult = AsyncResult(id)\r\n                if res.ready():\r\n                    logging.info('Tuned Model result for %s is ready.', res.result['name'])\r\n                    logging.info(res.result)\r\n                    self.tuned_model_ids.pop(index)\r\n                    best_model_names.remove(res.result['name'])\r\n                names = ', '.join(best_model_names)\r\n                if names:\r\n                    logging.info('Tuned Model result for %s are not ready.', names)\r\n                sleep(3)\r\n                \r\n    def create_train_config(self, model: BaseEstimator, name: str, save_path: str) -> TrainConfig:\r\n        (train_features, train_labels), (test_features, test_labels) = self.get_train_test_data()\r\n        train_config: TrainConfig = TrainConfig(\r\n            preprocessor=self.preprocessor,\r\n            model=model,\r\n            classifier_name=name,\r\n            save_path=save_path,\r\n            train_features=train_features,\r\n            train_labels=train_labels,\r\n            test_features=test_features,\r\n            test_labels=test_labels\r\n        )\r\n"}
{"image_path": "data\\train\\00656.png", "code": "        return train_config"}
{"image_path": "data\\train\\00657.png", "code": "from sklearn.ensemble import RandomForestClassifier\r\nfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\r\nfrom sklearn.ensemble import AdaBoostClassifier\r\nfrom sklearn.gaussian_process import GaussianProcessClassifier\r\nfrom sklearn.gaussian_process.kernels import RBF\r\nfrom sklearn.naive_bayes import GaussianNB\r\nfrom sklearn.neighbors import KNeighborsClassifier\r\nfrom sklearn.neural_network import MLPClassifier\r\nfrom sklearn.svm import SVC\r\nfrom sklearn.tree import DecisionTreeClassifier\r\nfrom schemas import Model, UntrainedModel\r\nfrom os import path\r\nfrom config.config import app_config\r\nfrom datetime import datetime\r\n\r\n\r\nnames = [\r\n    \"Nearest Neighbors\",\r\n    \"Linear SVM\",\r\n    \"RBF SVM\",\r\n    \"Gaussian Process\",\r\n    \"Decision Tree\",\r\n    \"Random Forest\",\r\n    \"Neural Net\",\r\n    \"AdaBoost\",\r\n    \"Naive Bayes\",\r\n    \"QDA\",\r\n]\r\n\r\nclassifiers = [\r\n    KNeighborsClassifier(3),\r\n    SVC(kernel=\"linear\", C=0.025, random_state=42),\r\n    SVC(gamma=2, C=1, random_state=42),\r\n    GaussianProcessClassifier(1.0 * RBF(1.0), random_state=42),\r\n    DecisionTreeClassifier(random_state=42),\r\n    RandomForestClassifier(\r\n        max_depth=5, n_estimators=10, max_features=1, random_state=42\r\n    ),\r\n    MLPClassifier(alpha=1, max_iter=1000, random_state=42),\r\n    AdaBoostClassifier(random_state=42),\r\n"}
{"image_path": "data\\train\\00658.png", "code": "    GaussianNB(),\r\n    QuadraticDiscriminantAnalysis(),\r\n]\r\nmodels: list[Model] = [\r\n    UntrainedModel(\r\n        save_path=path.join(app_config.models_dir, 'trained', model_name),\r\n        model=model,\r\n        classifier_name=model_name,\r\n        train_date=datetime.now(),\r\n        owner='Lyle Okoth'\r\n    ) \r\n    for model_name, model in zip(names, classifiers)\r\n]"}
{"image_path": "data\\train\\00659.png", "code": "from api import create_app\r\nfrom api.helpers import generate_data, post_data\r\nimport os\r\n\r\n\r\napp = create_app()\r\n\r\ndef seed_data():\r\n    data = generate_data(count=1)\r\n    url: str = os.environ.get('url', 'http://127.0.0.1:8000/predict')\r\n    post_data(data=data, url=url)\r\n    \r\nif __name__ == '__main__':\r\n    seed_data()"}
{"image_path": "data\\train\\00660.png", "code": "import logging\r\nfrom logging import Handler\r\nfrom typing import Optional\r\n\r\n\r\ndef create_logger(handlers: Optional[Handler] = []) -> None:\r\n    logging_format: str = \"%(asctime)s - %(levelname)s - %(message)s\"\r\n    date_format: str = \"[%X]\"\r\n    logging.basicConfig(\r\n        format=logging_format,\r\n        datefmt=date_format,\r\n        handlers=handlers,\r\n        level=logging.INFO,\r\n    )\r\n"}
{"image_path": "data\\train\\00661.png", "code": "from dotenv import load_dotenv\r\n\r\nload_dotenv()\r\nimport logging\r\nfrom logging import Handler\r\n\r\nfrom rich.logging import RichHandler\r\n\r\nfrom .agent_nelly import AgentNelly\r\nfrom .logger import create_logger\r\nfrom .states import Introduction\r\nfrom .ui import RichUI\r\n\r\nif __name__ == \"__main__\":\r\n    handlers: list[Handler] = [RichHandler()]\r\n    create_logger(handlers=handlers)\r\n    logging.getLogger().setLevel(logging.WARN)\r\n    from .states import QA, DataAnalysis\r\n\r\n    agent_nelly = AgentNelly(ui=RichUI(), initial_state=Introduction())\r\n    agent_nelly.analyze_product_review()\r\n"}
{"image_path": "data\\train\\00662.png", "code": "import logging\r\n\r\nfrom .agent_state import AgentState\r\nfrom .states import State\r\nfrom .ui import BaseUI\r\n\r\n\r\nclass AgentNelly:\r\n    def __init__(self, ui: BaseUI, initial_state: State) -> None:\r\n        self._ui: BaseUI = ui\r\n        self._ui.agent = self\r\n        self._ui.launch()\r\n        self._agent_state = AgentState()\r\n        self.transition_to(initial_state)\r\n\r\n    @property\r\n    def ui(self) -> BaseUI:\r\n        return self._ui\r\n\r\n    @property\r\n    def agent_state(self) -> AgentState:\r\n        return self._agent_state\r\n\r\n    def transition_to(self, state: State) -> None:\r\n        if state:\r\n            logging.info(\"Transitioning to the state: %s\", type(state).__name__)\r\n            self._state = state\r\n            self._state.agent = self\r\n        else:\r\n            self._state = None\r\n\r\n    def analyze_product_review(self) -> None:\r\n        while self._state:\r\n            try:\r\n                self._state.execute()\r\n            except KeyboardInterrupt:\r\n                from .ui.utils import (agent_confirm_prompt,\r\n                                       agent_question_prompt)\r\n\r\n                end_chat: bool = agent_confirm_prompt(\r\n"}
{"image_path": "data\\train\\00663.png", "code": "                    question=\"Are you sure you want to end this chat?\"\r\n                )\r\n                if end_chat:\r\n                    agent_question_prompt(\"Goodbye\")\r\n                    break\r\n"}
{"image_path": "data\\train\\00664.png", "code": "from typing import Optional\r\n\r\nfrom pydantic import BaseModel, Field\r\n\r\n\r\nclass AgentState(BaseModel):\r\n    product: Optional[str] = Field(\r\n        description=\"The product being reviewed\", default=None\r\n    )\r\n    channel: Optional[str] = Field(description=\"The youtube channel used\", default=None)\r\n    video: Optional[str] = Field(description=\"The video being reviewed\", default=None)\r\n    transcript: Optional[str] = Field(description=\"The video transcript\", default=None)\r\n    comments: Optional[list[str]] = Field(\r\n        description=\"The video comments\", default_factory=list\r\n    )\r\n    summary: Optional[str] = Field(description=\"The video summary\", default=None)\r\n    analysis_summary: Optional[str] = Field(\r\n        description=\"The video analysis_summary\", default=None\r\n    )\r\n    features: Optional[str] = Field(\r\n        description=\"The product features reviewed\", default=None\r\n    )\r\n    questions: Optional[list[str]] = Field(\r\n        description=\"The questions that the analyst had\", default_factory=list\r\n    )\r\n"}
{"image_path": "data\\train\\00665.png", "code": "from langchain.tools import tool\r\nfrom .helpers import advanced_video_search\r\nfrom youtube.models import Search\r\n\r\n\r\nclass FindProductVideoTools():\r\n    @tool\r\n    def find_product_video_id(product: str) -> str:\r\n        \"\"\"Useful when you need to find a product review video from youtube.\"\"\"\r\n        query: str = f'reviews of the latest {product}'\r\n        search_results: list[Search] = advanced_video_search(query)\r\n        return search_results[0].resource_id\r\n        \r\n        "}
{"image_path": "data\\train\\00666.png", "code": "from langchain.tools import tool\r\nfrom .helpers import list_video_comments\r\nfrom youtube.models import Comment\r\n\r\n\r\nclass FindProductReviewTools():\r\n    @tool\r\n    def find_product_reviews(video_id: str) -> str:\r\n        \"\"\"Useful when you need to find a product reviews from youtube video comments.\"\"\"\r\n        comments: list[Comment] = list_video_comments(video_id)\r\n        comments: list[str] = [comment.snippet.text_display for comment in comments]\r\n        return ' '.join(comments)"}
{"image_path": "data\\train\\00667.png", "code": "from .find_product_reviews_tool import FindProductReviewTools\r\nfrom .find_product_tool import FindProductVideoTools"}
{"image_path": "data\\train\\00668.png", "code": "from youtube import YouTube\r\n\r\n\r\nclient_secrets_file = '/home/lyle/Downloads/search.json'\r\nyoutube_client = YouTube(client_secret_file=client_secrets_file)\r\nyoutube_client_object = youtube_client.authenticate()\r\nyoutube_client.youtube_client = youtube_client_object"}
{"image_path": "data\\train\\00669.png", "code": "from typing import Optional\r\nfrom youtube.schemas import (\r\n    SearchPart, SearchOptionalParameters, YouTubeResponse, YouTubeRequest\r\n)\r\nfrom youtube.schemas import (\r\n    CommentThreadFilter, CommentThreadOptionalParameters, CommentThreadPart\r\n)\r\nfrom youtube.models import Search, Comment\r\nfrom .extensions import youtube_client\r\nfrom collections.abc import Iterator\r\n\r\n\r\ndef advanced_video_search( \r\n    query: str,\r\n    channel_id: Optional[str] = None,\r\n    max_results: Optional[int] = 10,\r\n    order: Optional[str] = None,\r\n    published_after: Optional[str] = None,\r\n    published_before: Optional[str] = None,\r\n    region_code: Optional[str] = None,\r\n    relevance_language: Optional[str] = 'en',\r\n    video_caption: Optional[str] = None,\r\n    video_category_id: Optional[str] = None,\r\n    video_definition: Optional[str] = None,\r\n    video_dimension: Optional[str] = None,\r\n    video_duration: Optional[str] = None,\r\n    video_paid_product_placement: Optional[str] = None,\r\n    video_syndicated: Optional[str] = None,\r\n    video_type: Optional[str] = 'any'\r\n    ) -> list[Search]:\r\n    \"\"\"Search the given channel for the given videos.\"\"\"\r\n    search_part: SearchPart = SearchPart()\r\n    optional_params: SearchOptionalParameters = SearchOptionalParameters(\r\n        channelId=channel_id,\r\n        q=query,\r\n        maxResults=max_results,\r\n        order=order,\r\n        publishedAfter=published_after,\r\n        publishedBefore=published_before,\r\n        regionCode=region_code,\r\n"}
{"image_path": "data\\train\\00670.png", "code": "        relevanceLanguage=relevance_language,\r\n        type=['video'],\r\n        videoCaption=video_caption,\r\n        videoCategoryId=video_category_id,\r\n        videoDefinition=video_definition,\r\n        videoDimension=video_dimension,\r\n        videoDuration=video_duration,\r\n        videoPaidProductPlacement=video_paid_product_placement,\r\n        videoSyndicated=video_syndicated,\r\n        videoType=video_type\r\n    )\r\n    search_schema: YouTubeRequest = YouTubeRequest(\r\n        part=search_part, optional_parameters=optional_params\r\n    )\r\n    response: YouTubeResponse = youtube_client.search(search_schema)\r\n    items: list[Search] = response.items\r\n    return items\r\n\r\n\r\ndef list_video_comments(video_id: str) -> list[Comment]:\r\n    \"\"\"List a given videos comments\"\"\"\r\n    part: CommentThreadPart = CommentThreadPart()\r\n    filter: CommentThreadFilter = CommentThreadFilter(\r\n        videoId=video_id\r\n    )\r\n    optional: CommentThreadOptionalParameters = CommentThreadOptionalParameters(\r\n        maxResults=30\r\n    )\r\n    request:YouTubeRequest = YouTubeRequest(\r\n        part=part,\r\n        filter=filter,\r\n        optional_parameters=optional\r\n    )\r\n    comment_iterator: Iterator = youtube_client.get_comments_iterator(request)\r\n    video_comments: list[Comment] = list()\r\n    done: bool = False\r\n    comment_count: int = 0\r\n    for comment_threads in comment_iterator:\r\n        if done:\r\n            break\r\n"}
{"image_path": "data\\train\\00671.png", "code": "        for comment_thread in comment_threads:\r\n            comment: Comment = comment_thread.snippet.top_level_comment\r\n            video_comments.append(comment)\r\n            comment_count += 1\r\n            if comment_count > 30:\r\n                done = True\r\n                break\r\n    return video_comments"}
{"image_path": "data\\train\\00672.png", "code": "from celery import Celery\r\nfrom pydantic_settings import BaseSettings\r\nfrom dotenv import load_dotenv\r\nfrom redis import Redis\r\nfrom json import dumps\r\n\r\nload_dotenv()\r\n\r\n\r\nclass BaseConfig(BaseSettings):\r\n    celery_broker_url: str\r\n    celery_result_backend: str\r\n    redis_host: str\r\n    \r\nconfig = BaseConfig()\r\n\r\ncelery = Celery(__name__)\r\ncelery.conf.broker_url = config.celery_broker_url\r\ncelery.conf.result_backend = config.celery_result_backend\r\nredis: Redis = Redis(host=config.redis_host, port=6379, db=0, decode_responses=True)\r\n\r\n@celery.task(name=\"analyze_quote\")\r\ndef analyze_quote(quote: dict) -> dict:\r\n    analyzed_quote: dict = quote\r\n    analyzed_quote.update({'result': 'Some result'})\r\n    redis.publish('analyzed_quotes', dumps(analyzed_quote))\r\n    return analyzed_quote\r\n\r\n\r\n@celery.task(name=\"send_email\")\r\ndef send_email(quote: dict) -> dict:\r\n    \r\n    return analyzed_quote"}
{"image_path": "data\\train\\00673.png", "code": "from oauth import OAuth\r\nfrom helpers import create_message, send_message\r\n\r\n    \r\ngmail_client = get_gmail_client('credentials.json')\r\nmessage = create_message()\r\nmessage = send_message(gmail_client, message)\r\nprint(message)"}
{"image_path": "data\\train\\00674.png", "code": "\r\nfrom pydantic import BaseModel, Field\r\nfrom typing import Optional\r\nfrom googleapiclient.discovery import build\r\nfrom google.oauth2.credentials import Credentials\r\nfrom google_auth_oauthlib.flow import InstalledAppFlow\r\nfrom google.auth.exceptions import RefreshError\r\nfrom typing import Any\r\nfrom os import path, mkdir\r\nfrom json import dump, load\r\nfrom models import Scopes\r\n\r\n\r\nclass OAuth(BaseModel):\r\n    secrets_file: str\r\n    scopes: list[str] = [\r\n        Scopes.drafts.value, Scopes.labels.value\r\n    ]\r\n    api_service_name: Optional[str] = 'gmail'\r\n    api_version: Optional[str] = 'v1'\r\n    credentials_file_name: Optional[str] = 'credentials.json' \r\n    credentials_dir: Optional[str] = '.gmail_credentials'\r\n    \r\n    def credentials_to_dict(self, credentials: Credentials) -> dict:\r\n        \"\"\"Convert credentials to a dict.\"\"\"\r\n        return {\r\n            'token': credentials.token,\r\n            'refresh_token': credentials.refresh_token,\r\n            'token_uri': credentials.token_uri,\r\n            'client_id': credentials.client_id,\r\n            'client_secret': credentials.client_secret,\r\n            'scopes': credentials.scopes,\r\n        }\r\n        \r\n    def create_default_credentials_path(self) -> str:\r\n        \"\"\"Create the default credentials directory.\"\"\"\r\n        current_user_home_dir = path.expanduser('~')\r\n        if not path.exists(path.join(current_user_home_dir, self.credentials_dir)):\r\n            mkdir(path.join(current_user_home_dir, self.credentials_dir))\r\n        return path.join(current_user_home_dir, self.credentials_dir)\r\n"}
{"image_path": "data\\train\\00675.png", "code": "        \r\n    def get_default_credentials_path(self) -> str:\r\n        \"\"\"Generate the default api token file location.\"\"\"\r\n        credentials_dir: str = self.create_default_credentials_path()\r\n        credentials_file_path = path.join(credentials_dir, self.credentials_file_name)\r\n        return credentials_file_path\r\n\r\n    def get_credentials(self) -> Credentials:\r\n        \"\"\"Get the credentials.\"\"\"\r\n        credentials: Credentials = None\r\n        credentials_path: str = self.get_default_credentials_path()\r\n        try:\r\n            with open(credentials_path, 'r', encoding='utf-8') as creds:\r\n                credentials = Credentials(**load(creds))\r\n        except FileNotFoundError:\r\n            pass\r\n        return credentials\r\n    \r\n    def generate_credentials(self) -> Credentials:\r\n        flow = InstalledAppFlow.from_client_secrets_file(self.secrets_file, self.scopes)\r\n        credentials = flow.run_local_server(port=0)\r\n        return credentials\r\n    \r\n    def save_credentials(self, credentials: Credentials) -> None:\r\n        credentials_dict = self.credentials_to_dict(credentials)\r\n        credentials_path: str = self.get_default_credentials_path()\r\n        with open(credentials_path, 'w', encoding='utf-8') as f:\r\n            dump(credentials_dict, f)\r\n            \r\n    def credentials_expired(self, credentials: Credentials) -> bool:\r\n        # youtube_client = self.get_youtube_client(credentials=credentials)\r\n        # youtube_find_request = youtube_client.search().list(q='', part='id')\r\n        # try:\r\n        #     youtube_find_request.execute()\r\n        # except RefreshError:\r\n        #     return True\r\n        # return False\r\n        return False\r\n            \r\n    def get_gmail_client(self, credentials: Credentials) -> Any:\r\n"}
{"image_path": "data\\train\\00676.png", "code": "        gmail_client = build(self.api_service_name, self.api_version, credentials=credentials)\r\n        return gmail_client\r\n    \r\n    def authenticate(self) -> Any:\r\n        credentials: Credentials = self.get_credentials()\r\n        if not credentials or self.credentials_expired(credentials=credentials):\r\n            credentials = self.generate_credentials()\r\n            self.save_credentials(credentials=credentials)\r\n        gmail_client = self.get_gmail_client(credentials=credentials)\r\n        return gmail_client"}
{"image_path": "data\\train\\00677.png", "code": "from email.message import EmailMessage\r\nfrom base64 import urlsafe_b64encode\r\nfrom googleapiclient.errors import HttpError\r\nfrom oauth import OAuth\r\n\r\n\r\ndef create_draft(gmail_client) -> dict:\r\n    try:\r\n        message = EmailMessage()\r\n        message.set_content('This is automated draft mail')\r\n        message['To'] = 'lyleokothdev@gmail.com'\r\n        message['From'] = 'lyceokoth@gmail.com'\r\n        message['Subject'] = 'Automated draft'\r\n        # encoded message\r\n        encoded_message = urlsafe_b64encode(message.as_bytes()).decode()\r\n        create_message = {\r\n            'message': {\r\n                'raw': encoded_message\r\n            }\r\n        }\r\n        draft = gmail_client.users().drafts().create(userId=\"me\",body=create_message).execute()\r\n        print(f'Draft id: {draft[\"id\"]}\\nDraft message: {draft[\"message\"]}')\r\n    except HttpError as error:\r\n        print(f'An error occurred: {error}')\r\n        draft = None\r\n\r\n    return draft\r\n\r\ndef create_message():\r\n    try:\r\n        message = EmailMessage()\r\n        message.set_content('This is automated draft mail')\r\n        message['To'] = 'lyleokothdev@gmail.com'\r\n        message['From'] = 'lyceokoth@gmail.com'\r\n        message['Subject'] = 'Automated draft'\r\n        # encoded message\r\n        encoded_message = urlsafe_b64encode(message.as_bytes()).decode()\r\n        create_message = {\r\n            'raw': encoded_message\r\n        }\r\n"}
{"image_path": "data\\train\\00678.png", "code": "    except HttpError as error:\r\n        print(F'An error occurred: {error}')\r\n        create_message = None\r\n    return create_message\r\n\r\ndef send_message(gmail_client, message):\r\n    try:\r\n        send_message = (gmail_client.users().messages().send\r\n                        (userId=\"me\", body=message).execute())\r\n        print(F'Message Id: {send_message[\"id\"]}')\r\n    except HttpError as error:\r\n        print(F'An error occurred: {error}')\r\n        send_message = None\r\n    return send_message\r\n\r\ndef get_gmail_client(secrets_file: str):\r\n    oauth: OAuth = OAuth(secrets_file=secrets_file)\r\n    gmail_client = oauth.authenticate()\r\n    return gmail_client"}
{"image_path": "data\\train\\00679.png", "code": "from helpers import redis\r\n\r\n\r\ndef analyzed_quotes():\r\n    sub = redis.pubsub()\r\n    sub.subscribe('analyzed_quotes')\r\n    for message in sub.listen():\r\n        if message and isinstance(message['data'], str):\r\n            quote: dict = message['data']\r\n            print(quote)\r\n            \r\nif __name__ == '__main__':\r\n    while True:\r\n        analyzed_quotes()"}
{"image_path": "data\\train\\00680.png", "code": "# -*- coding: utf-8 -*-\r\n\r\n# Define here the models for your scraped items\r\n#\r\n# See documentation in:\r\n# https://doc.scrapy.org/en/latest/topics/items.html\r\n\r\nfrom scrapy.item import Item, Field\r\nfrom itemloaders.processors import MapCompose, TakeFirst\r\nfrom datetime import datetime\r\n\r\n\r\ndef remove_quotes(text):\r\n    # strip the unicode quotes\r\n    text = text.strip(u'\\u201c'u'\\u201d')\r\n    return text\r\n\r\n\r\ndef convert_date(text):\r\n    # convert string March 14, 1879 to Python date\r\n    return datetime.strptime(text, '%B %d, %Y')\r\n\r\n\r\ndef parse_location(text):\r\n    # parse location \"in Ulm, Germany\"\r\n    # this simply remove \"in \", you can further parse city, state, country, etc.\r\n    return text[3:]\r\n\r\ndef parse_url(url: str) -> str:\r\n    url: str = [url.split('/')[-2]]\r\n    try:\r\n        int(url)\r\n    except:\r\n        return '1'\r\n    return url\r\n    \r\nclass TagItem(Item):\r\n    name = Field()\r\n\r\nclass QuoteItemSchema(Item):\r\n"}
